<?xml version="1.0" encoding="UTF-8"?>
<!-- edited with XMLSpy v2006 rel. 3 sp2 (http://www.altova.com) by Syam Gadde (Duke University) -->
<xs:schema xmlns="http://www.nbirn.net/xcede" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink" targetNamespace="http://www.nbirn.net/xcede" elementFormDefault="qualified" attributeFormDefault="unqualified">
	<xs:complexType name="abstract_resource_t">
		<xs:sequence>
			<xs:element name="provenance"/>
		</xs:sequence>
		<xs:attribute name="ID" type="xs:string"/>
		<xs:attribute name="name" type="xs:string"/>
		<xs:attribute name="description" type="xs:string"/>
	</xs:complexType>
	<xs:complexType name="binary_data_resource_t">
		<xs:complexContent>
			<xs:extension base="abstract_resource_t">
				<xs:sequence>
					<xs:element name="datarecFrag" type="frag_uri_t" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>The external data pointed to by this data record is represented as a list of "fragments", where a "fragment" is defined as a stream of data contiguously stored in the same file.  Data stored in multiple files necessitates multiple fragments, as does data stored non-contiguously within the same file.  </xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="byteOrder">
					<xs:annotation>
						<xs:documentation>This attribute describes whether the individual data elements in the data record are stored with the most-significant-byte first (msbfirst) or least-significant-byte first (lsbfirst).  This element is required if the the data type given by the "elementtype" element has a size larger than one byte.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="int8"/>
							<xs:enumeration value="uint8"/>
							<xs:enumeration value="int16"/>
							<xs:enumeration value="uint16"/>
							<xs:enumeration value="int32"/>
							<xs:enumeration value="uint32"/>
							<xs:enumeration value="int64"/>
							<xs:enumeration value="uint64"/>
							<xs:enumeration value="float32"/>
							<xs:enumeration value="float64"/>
							<xs:enumeration value="ascii"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
				<xs:attribute name="elementType">
					<xs:annotation>
						<xs:documentation>This element describes the type of individual data elements in the data record.  For numeric data types, this indicates whether the element type is a signed integer ("int"), unsigned integer ("uint"), or floating-point ("float"), as well as the number of bits allocated to each element.</xs:documentation>
					</xs:annotation>
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="lsbfirst"/>
							<xs:enumeration value="msbfirst"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="dimensioned_binary_data_resource_t">
		<xs:complexContent>
			<xs:extension base="binary_data_resource_t">
				<xs:sequence>
					<xs:element name="dimension" type="binary_data_dimension_t" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="mapped_binary_data_resouce_t">
		<xs:complexContent>
			<xs:extension base="binary_data_resource_t">
				<xs:sequence>
					<xs:element name="dimension" type="mapped_binary_data_dimension_t" maxOccurs="unbounded"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="mr_image_resource_t">
		<xs:complexContent>
			<xs:extension base="mapped_binary_data_resouce_t"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="MrImageResource" type="mr_image_resource_t"/>
	<xs:complexType name="binary_data_dimension_t">
		<xs:annotation>
			<xs:documentation xml:lang="en">This element stores information about one of the N dimensions in the data record.  Multiple instances of this element are ordered from fastest-moving to slowest-moving.  These elements provide information to describe the size (in data elements) of the N-dimensional bounding box for the data, and in some cases to describe the mapping of indexes within this bounding box to 'real-world' coordinates.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="size" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation xml:lang="en">The number of elements in the data along one traversal of this dimension.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="label" type="xs:string">
			<xs:annotation>
				<xs:documentation xml:lang="en">This is a label for the dimension.  The first three spatial dimensions (or however many exist) must be labeled, in order, 'x', 'y', and 'z'.  The first temporal dimension must be labeled 't'.
        The data record allows the writer to specify some measure of data permutation/dimension merging when data is read and presented to a higher application level.  This is useful, for example, if the data is stored in Siemens' Mosaic DICOM format, where slices of a 3-D volume are arranged to look like they are tiled onto a square 2-D area.  In this case, what would normally be called the 'z' dimension has two forks, one that occurs before the 'y' dimension (the first row in the data covers the first row of several slices), and one that occurs after the 'y' dimension.  If, as in this case, there are two or more dimensions that should be merged into one, they should be labeled 'DIMTYPE-splitRANK' where DIMTYPE is the name of the resultant merged dimension, and RANK specifies the order in which all 'split' dimensions of this type will be merged.  After merging, the resultant dimension should have the values of the highest-ranked DIMTYPE split dimension, except for the 'size' element, which will be the product of the sizes of all DIMTYPE split dimensions.  The position of the resultant dimension should be the position of the highest-ranked DIMTYPE split dimension.  The data itself should also be reordered to reflect the new dimension structure.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="outputselect" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation xml:lang="en">In the same way that the 'label' attribute allows you to specify dimensions that should be merged before presenting the data to an application, this attribute specifies a data filter along this dimension.  If this attribute exists, it should contain a whitespace-separated list of indices (indexed starting at 0).  Only data points along this dimension that occur in the index list should be presented to the application.  Likewise, the 'size' of the dimension, after selection, should be updated to reflect the new size of this dimension (which should be the number of indices in the content of this attribute).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="mapped_binary_data_dimension_t">
		<xs:complexContent>
			<xs:extension base="binary_data_dimension_t">
				<xs:sequence>
					<xs:element name="origin" type="xs:float" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="en">A value assigned to the first data element along this dimension.  For example, if this dimension corresponds to "time", this element could store the time corresponding to the first data element.  If this is a two-dimensional projection of the surface of the Earth, and this dimension takes you around the Earth parallel to the equator, this value could be the degrees longitude.  For MRI data, this is the single coordinate on the Left-to-Right, Posterior-to-Anterior, or Inferior-to-Superior axis to which this dimension most closely matches (see 'direction' element and 'rasorigin' element in 'mr_image_data_resource_t').</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="spacing" type="xs:float" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="en">This is the average distance between consecutive data elements in this dimension.  If the spacing is not regular, then it may be possible to calculate the actual distance between any two data elements in this dimension using the 'datapoints' element.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="gap" type="xs:float" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="en">This is the length of the unsampled space between consecutive data elements in this dimension, i.e. the distance between the end of one data element and the beginning of the next.  For MRI data, this can be used to specify the gap between two collected slices &#x02015; the actual width of each slice can be calculated as 'spacing' minus 'gap'.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="datapoints" type="xs:string" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="en">The content of this element is either (1) a whitespace-separated list of values, or (2) a list of 'value' elements, that can be used as a label for each data point along this dimension.  The values can be numbers representing points on an axis (this is the typical case), text strings, coordinate tuples, etc.  Any datapoint label that includes whitespace (coordinate tuples included) must be encapsulated within a child 'value' element.  If this element is missing, it is assumed that labels can be calculated using information in other fields (such as 'origin', 'spacing', etc.).  This element is particularly useful for dimensions with irregular spacing.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="direction" type="listoffloats_t" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="en">This element contains a vector (represented as a whitespace-separated list of floating-point values in the appropriate coordinate system) that is parallel to this dimension's edge of the bounding box.  The vector starts at the first element in the data and points towards subsequent elements along this dimension.  For MRI data, this should be a unit vector in (R,A,S) coordinates (positive values are Right, Anterior, or Superior respectively) &#x02015; for 'x' and 'y' dimensions, this corresponds to the two vectors in the ImagePatientOrientation field in DICOM.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="units" type="xs:string" minOccurs="0">
						<xs:annotation>
							<xs:documentation xml:lang="en">This stores the units used for all numeric values in this dimension element.  In MRI data, this should be 'ms' for all spatial dimensions ('x', 'y', 'z') and 'ms' for the temporal dimension 't'.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="datarecFrag_t">
		<xs:annotation>
			<xs:documentation>The external data pointed to by this data record is represented as a list of "fragments", where a "fragment" is defined as a stream of data contiguously stored in the same file.  Data stored in multiple files necessitates multiple fragments, as does data stored non-contiguously within the same file.  Each data fragment is represented, in data stream order, by the following group of elements.  This group should be repeated to describe multiple fragments.
      There is one shortcut to help make this list more compact.  If there is a subsequence of fragments that are co-located in the same file, the individual offsets and sizes of these fragments can be provided as multiple 'contentBlock' elements, instead of specifying a separate filename/fileoffset/filerecordsize combination for each element.
      Obviously, this list of fragments can be made arbitrarily long by defining a fragment size as small as one byte &#x02015; there is no requirement that fragment sizes be as large as possible, nor that subsequent fragments within the same file be represented in the same element group.  However, the most compact form is of course preferable.
      The data is typically presented to the application as a concatenation of the data pointed to by each of the fragments in the list (possibly transformed using the filters described in the "dimension" element)</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="uri" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation xml:lang="en">The digital resource in which to find the data in this data fragment</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="contentBlock" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>The data for this fragment may be dispersed in multiple blocks,  If this element does not exist, it is assumed that the fragment has one block with zero offset and the size is calculated using the dimension and elementtype element.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:attribute name="offset" type="xs:unsignedLong">
						<xs:annotation>
							<xs:documentation>The data for this block will start at this byte position in the resource specified by the 'uri' element.  If this attribute does not exist or is empty, it is assumed to be zero.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="size" type="xs:unsignedLong">
						<xs:annotation>
							<xs:documentation>This specifies the size(s) of this block in the resource specified by the 'uri' element.  If this attribute does not exist or is empty, it is calculated using the dimension and elementtype element.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="frag_uri_t">
		<xs:annotation>
			<xs:documentation>The external data pointed to by this uri is a "fragment", where a "fragment" is defined as a stream of data contiguously stored in the same file offset by 'offset' bytes and of 'size' bytes.</xs:documentation>
		</xs:annotation>
		<xs:simpleContent>
			<xs:extension base="xs:anyURI">
				<xs:attribute name="offset" type="xs:unsignedLong">
					<xs:annotation>
						<xs:documentation>The data for this fragment will start at this byte position in the resource specified by the 'uri' element.  If this attribute does not exist or is empty, it is assumed to be zero.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="size" type="xs:unsignedLong">
					<xs:annotation>
						<xs:documentation>This specifies the size(s) of this block in the resource specified by the 'uri' element.  If this attribute does not exist or is empty, it is calculated using the dimension and elementtype element.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<xs:simpleType name="listoffloats_t">
		<xs:list itemType="xs:float"/>
	</xs:simpleType>
</xs:schema>
