<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>XCEDE 2.0 - A Manual</title><meta name="generator" content="DocBook XSL Stylesheets V1.71.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>XCEDE 2.0 - A Manual</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#d0e5">Introduction</a></span></dt><dt><span class="chapter"><a href="#d0e12">1. Experiment&nbsp;Hierarchy</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e15">Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e31">Hierarchy Levels</a></span></dt><dt><span class="section"><a href="#d0e72">IDs and Linking</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e152">Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e155">Metadata hierarchy</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e170">2. Binary&nbsp;Data&nbsp;Resources</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e173">Overview</a></span></dt><dt><span class="section"><a href="#d0e264">Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e269">Basic data stream</a></span></dt><dt><span class="section"><a href="#d0e396">Dimensioned data</a></span></dt><dt><span class="section"><a href="#d0e430">Mapped data</a></span></dt><dt><span class="section"><a href="#d0e536">Advanced topic: split dimensions and outputSelect</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e643">3. Catalogs</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e648">Overview</a></span></dt><dt><span class="section"><a href="#d0e651">Examples</a></span></dt><dt><span class="section"><a href="#d0e654">Reference</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e657">4. Provenance</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e662">Overview</a></span></dt><dt><span class="section"><a href="#d0e665">Examples</a></span></dt><dt><span class="section"><a href="#d0e668">Reference</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e671">5. Events</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e674">Overview</a></span></dt><dt><span class="section"><a href="#d0e762">Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e786">6. Assessments</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e791">Overview</a></span></dt><dt><span class="section"><a href="#d0e794">Examples</a></span></dt><dt><span class="section"><a href="#d0e797">Reference</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e800">7. Protocols</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e805">Overview</a></span></dt><dt><span class="section"><a href="#d0e808">Examples</a></span></dt><dt><span class="section"><a href="#d0e811">Reference</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e814">8. Analysis</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e819">Overview</a></span></dt><dt><span class="section"><a href="#d0e822">Examples</a></span></dt><dt><span class="section"><a href="#d0e825">Reference</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e828">9. Terminology</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e833">Overview</a></span></dt><dt><span class="section"><a href="#d0e836">Examples</a></span></dt><dt><span class="section"><a href="#d0e839">Reference</a></span></dt></dl></dd><dt><span class="appendix"><a href="#d0e842">A. Schema</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>1.1. <a href="#hierarchy.levels">XCEDE hierarchy</a></dt><dt>1.2. <a href="#hierarchy.example_instance">Metadata hierarchy instance</a></dt><dt>2.1. <a href="#binary_data_resource.simple_example">Simple <code class="literal">binaryDataResource_t</code> example</a></dt><dt>2.2. <a href="#binary_data_resource.gzip_example"><code class="literal">binaryDataResource_t</code> with compression</a></dt><dt>2.3. <a href="#binary_data_resource.implicit_gzip_example"><code class="literal">binaryDataResource_t</code> with implicit compression</a></dt><dt>2.4. <a href="#binary_data_resource.dimension_example"><code class="literal">dimensionedBinaryDataResource_t</code> example</a></dt><dt>2.5. <a href="#binary_data_resource.matrix">Transformation matrix</a></dt><dt>2.6. <a href="#binary_data_resource.map_example"><code class="literal">mappedBinaryDataResource_t</code> example</a></dt><dt>2.7. <a href="#binary_data_resource.tile">A &#8220;<span class="quote">tiled</span>&#8221;image</a></dt><dt>2.8. <a href="#binary_data_resource.splitdim">Split dimension example</a></dt><dt>2.9. <a href="#binary_data_resource.outputSelect"><code class="literal">outputSelect</code> example</a></dt><dt>5.1. <a href="#events.timeline">An event timeline</a></dt><dt>5.2. <a href="#events.xcede_example">XCEDE Events example</a></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e5"></a>Introduction</h2></div></div></div><p>This is a manual for version 2.0 of XCEDE (XML-based Clinical and Experimental Data Exchange).  The target audience for this manual is anyone who is interested in using or learning more about XCEDE.  This manual will serve as both a tutorial and as a reference.</p><p>XCEDE is an extensible schema designed to store scientific data and metadata.  XCEDE has its origins in various XML schemas developed for collaborative neuroinformatics projects, and was developed to enable the transfer and storage of several types of data including (but not limited to) clinical, demographic, behavioral, physiological and image data.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e12"></a>Chapter&nbsp;1.&nbsp;Experiment&nbsp;Hierarchy</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e15">Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e31">Hierarchy Levels</a></span></dt><dt><span class="section"><a href="#d0e72">IDs and Linking</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e152">Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e155">Metadata hierarchy</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15"></a>Overview</h2></div></div></div><p>As illustrated in <a href="#hierarchy.levels" title="Figure&nbsp;1.1.&nbsp;XCEDE hierarchy">Figure&nbsp;1.1, &#8220;XCEDE hierarchy&#8221;</a>, the XCEDE experiment hierarchy consists of several <span class="emphasis"><em>levels</em></span> representing divisions of experiment data at various granularities.  Elements at each level contain level-specific "info" elements, whose schema types may be derived to store experiment-specific or data modality-specific metadata.  The linking mechanism between levels is flexible enough to support the omission of levels if the schema user finds them unnecessary.</p><div class="figure"><a name="hierarchy.levels"></a><p class="title"><b>Figure&nbsp;1.1.&nbsp;XCEDE hierarchy</b></p><div class="figure-contents"><div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="540"><tr><td><img src="images/hierarchy_levels.svg" width="540" alt="XCEDE hierarchy"></td></tr></table></div></div></div><br class="figure-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e31"></a>Hierarchy Levels</h3></div></div></div><p>In the typical intended usage, a <span class="emphasis"><em>project</em></span> is the top-level division of experiment data, and represents a research project which collects and analyzes data from one or more <span class="emphasis"><em>subjects</em></span> which are divided (within the project) into <span class="emphasis"><em>subject groups</em></span>.  A subject may be a member of multiple research projects, and it is the subject group that maintains and distinguishes the mappings between subjects and research projects.</p><p>A <span class="emphasis"><em>visit</em></span> may represent a subject's appearance at an experiment "site" (for collaborative projects, this could be the institution or lab at which the data is being collected or analyzed).  A visit, may be further subdivided into one or more <span class="emphasis"><em>studies</em></span>, each of would consist of one or more data collection <span class="emphasis"><em>episodes</em></span>.</p><p>Visit and study are more or less arbitrary divisions of the data that exist for convenience, and do not in themselves have any inherent meaning as far as the schema is concerned.  However, an episode is intended to represent a unit of data collection over a given time interval, and should contain one or more data <span class="emphasis"><em>acquisitions</em></span>, which should be understood to occur simultaneously over the duration of the episode.  So, for example, an episode in an fMRI study may encapsulate the acquisition of a time-series of volume images from an MR scanner, as well as other acquisitions of behavioral or physiological data; all these (simultaneous) acquisitions would be stored as part of the same episode.</p><p>It would be natural to represent the experiment hierarchy as described as a traditional XML hierarchy, where higher-level elements encapsulate lower-level elements as child elements.  However, in XCEDE, all level elements (<code class="literal">&lt;project&gt;</code>, <code class="literal">&lt;visit&gt;</code>, etc.) are stored as children of the root <code class="literal">&lt;XCEDE&gt;</code> element.   Links between levels are implicit in the level IDs assigned to each element and propagated to elements in lower levels.  One advantage of this approach is to allow users of the schema to omit levels merely by omitting the unnecessary elements and IDs/links.  Applications are also easier to write because all major elements are stored in the same place (under the XCEDE root element).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e72"></a>IDs and Linking</h3></div></div></div><p>Any level element can be the target of a link from another element.  In addition, most level elements are implicitly linked to "ancestor" level elements.  Both these types of links are created by specifying one or more <span class="emphasis"><em>level IDs</em></span> that together uniquely describe a target level element.</p><p>Every level element has a set of these level IDs, composed of the element's own <code class="literal">ID</code> attribute, plus its "ancestor" ID attributes, indicating which higher-level elements have this element in their scope.  For example, the <code class="literal">&lt;visit&gt;</code> element contains <code class="literal">subjectGroupID</code>, <code class="literal">subjectID</code>, and <code class="literal">projectID</code> attributes.</p><p>For example, a link to a visit element may specify <code class="literal">visitID</code>, <code class="literal">subjectID</code>, <code class="literal">subjectGroupID</code>, and <code class="literal">projectID</code> attributes, and a <code class="literal">level</code> attribute with the value <code class="literal">visit</code>, indicating that this link is to a visit element.  An application resolving this link will search for a visit element whose attributes match those specified in the link (the <code class="literal">visitID</code> attribute is matched against the <code class="literal">ID</code> attribute in the visit element).  Level ID attributes not specified in the link should match any value, but a link must specify enough of these IDs match at most one level element.</p><p>The elements that can link to any level element are <code class="literal">&lt;catalog&gt;</code>, <code class="literal">&lt;resource&gt;</code>, and <code class="literal">&lt;data&gt;</code> (children of the <code class="literal">&lt;XCEDE&gt;</code> root element), <code class="literal">&lt;inputRef&gt;</code> and <code class="literal">&lt;outputRef&gt;</code> (children of the <code class="literal">&lt;analysis&gt;</code> element).  Level elements (except for <code class="literal">&lt;project&gt;</code> and <code class="literal">&lt;subject&gt;</code>, which are at the top of the experiment hierarchy) can be implicitly linked to ancestor elements using the attributes provided.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e152"></a>Examples</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e155"></a>Metadata hierarchy</h3></div></div></div><p>The metadata hierarchy illustrated in <a href="#hierarchy.levels" title="Figure&nbsp;1.1.&nbsp;XCEDE hierarchy">Figure&nbsp;1.1, &#8220;XCEDE hierarchy&#8221;</a> can be represented in XCEDE as shown in <a href="#hierarchy.example_instance" title="Figure&nbsp;1.2.&nbsp;Metadata hierarchy instance">Figure&nbsp;1.2, &#8220;Metadata hierarchy instance&#8221;</a> (only those elements/attributes relevant to linking are shown; the actual metadata contents of the elements are omitted for space).</p></div><div class="figure"><a name="hierarchy.example_instance"></a><p class="title"><b>Figure&nbsp;1.2.&nbsp;Metadata hierarchy instance</b></p><div class="figure-contents"><pre class="programlisting">&lt;XCEDE xmlns="http://www.xcede.org/xcede-2"&gt;
  &lt;project ID="A"&gt;
    &lt;projectInfo&gt;
      &lt;subjectGroupList&gt;
        &lt;subjectGroup ID="X"&gt;
          &lt;subjectID&gt;1&lt;/subjectID&gt;
          &lt;subjectID&gt;2&lt;/subjectID&gt;
        &lt;/subjectGroup&gt;
      &lt;/subjectGroupList&gt;
    &lt;/projectInfo&gt;
  &lt;/project&gt;
  &lt;project ID="B"&gt;
    &lt;projectInfo&gt;
      &lt;subjectGroupList&gt;
        &lt;subjectGroup ID="Z"&gt;
          &lt;subjectID&gt;3&lt;/subjectID&gt;
        &lt;/subjectGroup&gt;
      &lt;/subjectGroupList&gt;
    &lt;/projectInfo&gt;
  &lt;/project&gt;
  &lt;subject ID="1" /&gt;
  &lt;subject ID="2" /&gt;
  &lt;subject ID="3" /&gt;
  &lt;visit ID="1"
         projectID="A" subjectID="1" subjectGroupID="X" /&gt;
  &lt;study ID="MR scan"
         projectID="A" subjectID="1" subjectGroupID="X" visitID="1" /&gt;
  &lt;episode ID="task run 1"
         projectID="A" subjectID="1" subjectGroupID="X" visitID="1" studyID="MR" /&gt;
  &lt;acquisition ID="MR image"
         projectID="A" subjectID="1" subjectGroupID="X" visitID="1" studyID="MR"
         episodeID="task run 1" /&gt;
  &lt;acquisition ID="behavioral data"
         projectID="A" subjectID="1" subjectGroupID="X" visitID="1" studyID="MR"
         episodeID="task run 1" /&gt;
  &lt;acquisition ID="heart rate"
         projectID="A" subjectID="1" subjectGroupID="X" visitID="1" studyID="MR"
         episodeID="task run 1" /&gt;
  &lt;study ID="Clinical interview"
         projectID="A" subjectID="1" subjectGroupID="X" visitID="2" /&gt;
  &lt;!-- ... etc. ... --&gt;
&lt;/XCEDE&gt;
</pre></div></div><br class="figure-break"><p></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e170"></a>Chapter&nbsp;2.&nbsp;Binary&nbsp;Data&nbsp;Resources</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e173">Overview</a></span></dt><dt><span class="section"><a href="#d0e264">Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e269">Basic data stream</a></span></dt><dt><span class="section"><a href="#d0e396">Dimensioned data</a></span></dt><dt><span class="section"><a href="#d0e430">Mapped data</a></span></dt><dt><span class="section"><a href="#d0e536">Advanced topic: split dimensions and outputSelect</a></span></dt></dl></dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e173"></a>Overview</h2></div></div></div><p>The XCEDE <span class="emphasis"><em>Binary Data Resource</em></span> component is used to provide a generic interface to a binary data stream stored in one or more external files.  Any of the binary data resource types described in this chapter can be used anywhere an <code class="literal">abstract_resource_t</code> is called for (with the appropriate <code class="literal">xsi:type</code> attribute); in the current XCEDE schema, these locations are the top-level <code class="literal">&lt;resource&gt;</code> element and the <code class="literal">&lt;dataResource&gt;</code> child element of <code class="literal">&lt;acquisition&gt;</code>.</p><p>XCEDE provides multiple layers of derived types to store more specialized information about the binary data.  The base type and each of the derived types are described in turn.</p><p><b><code class="literal">abstract_resource_t</code>.&nbsp;</b>The abstract base type <code class="literal">abstract_resource_t</code> provides a few elements and attributes that are especially important for binary data resources.  In particular, the <code class="literal">&lt;uri&gt;</code> element and its <code class="literal">offset</code> and <code class="literal">size</code> attributes point to a &#8220;<span class="quote">chunk</span>&#8221; of data stored in an external file.  A series of <code class="literal">&lt;uri&gt;</code> elements define a stream of data that may be described in greater detail by the data types described below.</p><p><b><code class="literal">binaryDataResource_t</code>.&nbsp;</b>This type derives from <code class="literal">abstract_resource_t</code> and allows an application to interpret the data stream as a sequence of data items with a given data type (<code class="literal">&lt;elementType&gt;</code>) and byte order (<code class="literal">&lt;byteOrder&gt;</code>).</p><p><b><code class="literal">dimensionedBinaryDataResource_t</code>.&nbsp;</b>The data stream, until now, could only be interpreted as a one-dimensional sequence.  This type provides <code class="literal">&lt;dimension&gt;</code> elements that allow the data stream to be interpreted as a multi-dimensional array of data items.  Each dimension has a <code class="literal">&lt;size&gt;</code> and a <code class="literal">&lt;label&gt;</code>, as well as the ability to discard subsets of the data in the data stream (using the <code class="literal">outputSelect</code> attribute).</p><p><b><code class="literal">mappedBinaryDataResource_t</code>.&nbsp;</b>This type places the multi-dimensional array of data items represented by <code class="literal">dimensionedBinaryDataResource_t</code> into an arbitrary coordinate system.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e264"></a>Examples</h2></div></div></div><p>Several examples of binary data are presented here, each showing the use of one of the different binary data types described in this chapter.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e269"></a>Basic data stream</h3></div></div></div><p>The basic binary data resource type describes a sequence of data items.  For example, consider a data file (<code class="literal">random_data_file.bin</code>) containing 2048 random 32-bit floating point numbers, stored in little-endian (least-significant-byte first) order.  The <code class="literal">&lt;dataResource&gt;</code> describing this data is shown in <a href="#binary_data_resource.simple_example" title="Figure&nbsp;2.1.&nbsp;Simple binaryDataResource_t example">Figure&nbsp;2.1, &#8220;Simple <code class="literal">binaryDataResource_t</code> example&#8221;</a>.</p><div class="figure"><a name="binary_data_resource.simple_example"></a><p class="title"><b>Figure&nbsp;2.1.&nbsp;Simple <code class="literal">binaryDataResource_t</code> example</b></p><div class="figure-contents"><pre class="programlisting">&lt;dataResource xsi:type="binaryDataResource_t"&gt;
  &lt;uri offset="0" size="8192"&gt;random_data_file.bin&lt;/uri&gt;
  &lt;elementType&gt;float32&lt;/elementType&gt;
  &lt;byteOrder&gt;lsbfirst&lt;/byteOrder&gt;
&lt;/dataResource&gt;</pre></div></div><br class="figure-break"><p>Note the <code class="literal">xsi:type</code> specifying that this <code class="literal">&lt;dataResource&gt;</code> element is of type <code class="literal">binaryDataResource_t</code>.  (The <code class="literal">xsi:</code> prefix should have already been declared previously in the XML file using something similar to <code class="literal">xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</code>)</p><p>The <code class="literal">&lt;elementType&gt;</code> element is restricted to one of several pre-defined strings (see the schema for details).  The <code class="literal">&lt;byteOrder&gt;</code> element must be <code class="literal">lsbfirst</code> for little-endian data or <code class="literal">msbfirst</code> for big-endian data.</p><p>If the <code class="literal">&lt;compression&gt;</code> element is specified, it specifies that the file(s) pointed to by the <code class="literal">&lt;uri&gt;</code> elements are compressed.  The content of the element should specify which type of compression (the only compression method specifically recognized by this specification is <code class="literal">gzip</code>).  The <code class="literal">size</code> and <code class="literal">offset</code> attributes in the <code class="literal">&lt;uri&gt;</code> element always refer to the <span class="emphasis"><em>uncompressed</em></span> data.  An example of this is shown in <a href="#binary_data_resource.gzip_example" title="Figure&nbsp;2.2.&nbsp;binaryDataResource_t with compression">Figure&nbsp;2.2, &#8220;<code class="literal">binaryDataResource_t</code> with compression&#8221;</a>.</p><div class="figure"><a name="binary_data_resource.gzip_example"></a><p class="title"><b>Figure&nbsp;2.2.&nbsp;<code class="literal">binaryDataResource_t</code> with compression</b></p><div class="figure-contents"><pre class="programlisting">&lt;dataResource xsi:type="binaryDataResource_t"&gt;
  &lt;uri offset="0" size="8192"&gt;random_data_file.bin.gz&lt;/uri&gt;
  &lt;elementType&gt;float32&lt;/elementType&gt;
  &lt;byteOrder&gt;lsbfirst&lt;/byteOrder&gt;
  &lt;compression&gt;gzip&lt;/compression&gt;
&lt;/dataResource&gt;</pre></div></div><br class="figure-break"><p>As a special case, if the application does not find the file pointed to by a URI, and the <code class="literal">&lt;compression&gt;</code> element is <span class="emphasis"><em>not</em></span> present, it may search for the same file with an appended <code class="literal">.gz</code> suffix, and if it exists, treat it as implicitly gzip-compressed data.  <a href="#binary_data_resource.implicit_gzip_example" title="Figure&nbsp;2.3.&nbsp;binaryDataResource_t with implicit compression">Figure&nbsp;2.3, &#8220;<code class="literal">binaryDataResource_t</code> with implicit compression&#8221;</a> shows how the same data in <a href="#binary_data_resource.gzip_example" title="Figure&nbsp;2.2.&nbsp;binaryDataResource_t with compression">Figure&nbsp;2.2, &#8220;<code class="literal">binaryDataResource_t</code> with compression&#8221;</a> could be expressed using this alternative method.  Pointing to the uncompressed version of the file (even when only the compressed version exists) allows the user to decompress or compress the data file at will, without affecting the ability of the application to read the data using the same <code class="literal">binaryDataResource_t</code>.  Note that the <code class="literal">&lt;uri&gt;</code> and <code class="literal">&lt;compression&gt;</code> elements must be internally consistent.  It would be an error to reference the uncompressed file <code class="literal">random_data_file.bin</code> and yet say that it was compressed using <code class="literal">&lt;compression&gt;gzip&lt;/compression&gt;</code>.  Likewise, explicit references to the compressed file (especially files that do not have the <code class="literal">.gz</code> suffix) must specify the compression method explicitly using the <code class="literal">compression</code> element.</p><div class="figure"><a name="binary_data_resource.implicit_gzip_example"></a><p class="title"><b>Figure&nbsp;2.3.&nbsp;<code class="literal">binaryDataResource_t</code> with implicit compression</b></p><div class="figure-contents"><pre class="programlisting">&lt;dataResource xsi:type="binaryDataResource_t"&gt;
  &lt;uri offset="0" size="8192"&gt;random_data_file.bin&lt;/uri&gt;
  &lt;elementType&gt;float32&lt;/elementType&gt;
  &lt;byteOrder&gt;lsbfirst&lt;/byteOrder&gt;
&lt;/dataResource&gt;</pre></div></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e396"></a>Dimensioned data</h3></div></div></div><p>Consider a camera that acquires an image using a 256x256 matrix of big-endian 32-bit signed integer voxels.  This data has two spatial dimensions, which, by convention, we label x, and y (and z if a third spatial dimension is needed, and t if there is a time dimension).  <a href="#binary_data_resource.dimension_example" title="Figure&nbsp;2.4.&nbsp;dimensionedBinaryDataResource_t example">Figure&nbsp;2.4, &#8220;<code class="literal">dimensionedBinaryDataResource_t</code> example&#8221;</a> shows how this data might be represented.</p><div class="figure"><a name="binary_data_resource.dimension_example"></a><p class="title"><b>Figure&nbsp;2.4.&nbsp;<code class="literal">dimensionedBinaryDataResource_t</code> example</b></p><div class="figure-contents"><pre class="programlisting">&lt;dataResource xsi:type="dimensionedBinaryDataResource_t"&gt;
  &lt;uri offset="0" size="262144"&gt;rawdata.img&lt;/uri&gt;
  &lt;elementType&gt;int32&lt;/elementType&gt;
  &lt;byteOrder&gt;msbfirst&lt;/byteOrder&gt;
  &lt;dimension label="x"&gt;
    &lt;size&gt;256&lt;/size&gt;
  &lt;/dimension&gt;
  &lt;dimension label="y"&gt;
    &lt;size&gt;256&lt;/size&gt;
  &lt;/dimension&gt;
&lt;/dataResource&gt;</pre></div></div><br class="figure-break"><p>Dimensions are ordered from fastest-moving to slowest-moving.  So in the above example, the x dimension index changes on each consecutive data item, but the y dimension changes every 256 elements.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e430"></a>Mapped data</h3></div></div></div><p>A &#8220;<span class="quote">mapped</span>&#8221; binary data resource is a (perhaps multidimensional) array of values, the matrix indices of which can be converted into a location in a given coordinate system.  The location of the bounding box of the data in this space is given by specifying a location (in target-space coordinates) for the the first data item, and two things for each dimension: a unit-length direction vector (in the target-space coordinate system) and the spacing between successive data items in that dimension.  The transformation matrix for a three-dimensional coordinate system has the form shown in <a href="#binary_data_resource.matrix" title="Figure&nbsp;2.5.&nbsp;Transformation matrix">Figure&nbsp;2.5, &#8220;Transformation matrix&#8221;</a>.  This transformation matrix converts from matrix indices <code class="literal">(x,y,z)</code> to a coordinate location <code class="literal">(a,b,c)</code>.  <a href="#binary_data_resource.map_example" title="Figure&nbsp;2.6.&nbsp;mappedBinaryDataResource_t example">Figure&nbsp;2.6, &#8220;<code class="literal">mappedBinaryDataResource_t</code> example&#8221;</a> shows how the components of a transformation of MR image data into scanner RAS (Right/Anterior/Superior) coordinates are represented in a <code class="literal">mappedBinaryDataResource_t</code>.  The unit vectors for each dimension are (X<sub>A</sub> X<sub>B</sub> X<sub>C</sub>) = (1 0 0), (Y<sub>A</sub> Y<sub>B</sub> Y<sub>C</sub>) = ( 0 1 0 ), and (Z<sub>A</sub> Z<sub>B</sub> Z<sub>C</sub>) = ( 0 0 1 ), and are placed in the <code class="literal">&lt;direction&gt;</code> elements in each <code class="literal">&lt;dimension&gt;</code> element.  The spacing values (S<sub>X</sub> S<sub>Y</sub> S<sub>Z</sub>) = ( 3.75mm 3.75mm 4mm ) are put in the <code class="literal">&lt;spacing&gt;</code> element in each <code class="literal">&lt;dimension&gt;</code>.  The coordinates of the first voxel in the data are given by (O<sub>A</sub> O<sub>B</sub> O<sub>C</sub>) = ( -120 -120 -52 ).</p><div class="figure"><a name="binary_data_resource.matrix"></a><p class="title"><b>Figure&nbsp;2.5.&nbsp;Transformation matrix</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/binary_data_resource_tmatrix.png" alt="Transformation matrix"></div></div></div><br class="figure-break"><div class="figure"><a name="binary_data_resource.map_example"></a><p class="title"><b>Figure&nbsp;2.6.&nbsp;<code class="literal">mappedBinaryDataResource_t</code> example</b></p><div class="figure-contents"><pre class="programlisting">&lt;dataResource xsi:type="mappedBinaryDataResource_t"&gt;
  &lt;uri offset="0" size="442368"&gt;V0001.img&lt;/uri&gt;
  &lt;uri offset="0" size="442368"&gt;V0002.img&lt;/uri&gt;
  &lt;uri offset="0" size="442368"&gt;V0003.img&lt;/uri&gt;
  &lt;uri offset="0" size="442368"&gt;V0004.img&lt;/uri&gt;
  &lt;uri offset="0" size="442368"&gt;V0005.img&lt;/uri&gt;
  &lt;!-- ... 135 more &lt;uri&gt; elements omitted for space ... --&gt;
  &lt;elementType&gt;int32&lt;/elementType&gt;
  &lt;byteOrder&gt;msbfirst&lt;/byteOrder&gt;
  &lt;dimension label="x"&gt;
    &lt;size&gt;64&lt;/size&gt;
    &lt;spacing&gt;3.75&lt;/spacing&gt;
    &lt;gap&gt;0&lt;/gap&gt;
    &lt;direction&gt;1 0 0&lt;/direction&gt;
    &lt;units&gt;mm&lt;/units&gt;
  &lt;/dimension&gt;
  &lt;dimension label="y"&gt;
    &lt;size&gt;64&lt;/size&gt;
    &lt;spacing&gt;3.75&lt;/spacing&gt;
    &lt;gap&gt;0&lt;/gap&gt;
    &lt;direction&gt;0 1 0&lt;/direction&gt;
    &lt;units&gt;mm&lt;/units&gt;
  &lt;/dimension&gt;
  &lt;dimension label="z"&gt;
    &lt;size&gt;27&lt;/size&gt;
    &lt;spacing&gt;4&lt;/spacing&gt;
    &lt;gap&gt;1&lt;/gap&gt;
    &lt;direction&gt;0 0 1&lt;/direction&gt;
    &lt;units&gt;mm&lt;/units&gt;
  &lt;/dimension&gt;
  &lt;dimension label="t"&gt;
    &lt;size&gt;140&lt;/size&gt;
    &lt;spacing&gt;2&lt;/spacing&gt;
    &lt;gap&gt;0&lt;/gap&gt;
    &lt;datapoints&gt;0 2 4 6 8&lt;/datapoints&gt;
    &lt;units&gt;sec&lt;/units&gt;
  &lt;/dimension&gt;
  &lt;originCoords&gt;-120 -120 -52&lt;/originCoords&gt;
&lt;/dataResource&gt;</pre></div></div><br class="figure-break"></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e536"></a>Advanced topic: split dimensions and outputSelect</h3></div></div></div><p>A more complicated example is given by data generated by a Siemens MR scanner.  In this case, the data represents a three-dimensional 64x64x32 image, stored in DICOM format.  However, because the earlier versions of the DICOM format did not support three-dimensional data in one file, Siemens came upon the clever idea to &#8220;<span class="quote">tile</span>&#8221; the 32 two-dimensional slices across an NxN two-dimensional grid (<a href="#binary_data_resource.tile" title="Figure&nbsp;2.7.&nbsp;A &#8220;tiled&#8221;image">Figure&nbsp;2.7, &#8220;A &#8220;<span class="quote">tiled</span>&#8221;image&#8221;</a>).</p><div class="figure"><a name="binary_data_resource.tile"></a><p class="title"><b>Figure&nbsp;2.7.&nbsp;A &#8220;<span class="quote">tiled</span>&#8221;image</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/binary_data_resource_tile.png" alt="A tiledimage"></div></div></div><br class="figure-break"><p>Applications may naturally want to express this data as a three-dimensional block, with columns, rows, and slices.  In a conventionally-stored three-dimensional XxYxZ image, the first X voxels compose the first row in the first slice, and then the next X voxels are the second row in the first slice; likewise the first X*Y voxels are the first slice, and the next X*Y voxels are the second slice, and so on.  However, in the &#8220;<span class="quote">tiled</span>&#8221; image, though the first X voxels are again the first row in the first slice, the next X voxels are the first row in the second slice!  At first it would seem that the dimension order has merely been switched, and specifying the labels of the dimensions as x, z, and y would fix things.  However, we only hit six slices' first rows before hitting going to the second row of the same six slices.  Only after going through all the rows in this fashion in the first six slices do we go on to the next six slices.</p><p>The end result is that the dimension that we are calling the z dimension has been split in two.  The two components of the z dimension are interleaved with the x and y dimensions like so: x, z<sub>1</sub>, y, z<sub>2</sub>.  The two components of the z dimension are distinguished with the <code class="literal">splitRank</code> attribute, as shown in <a href="#binary_data_resource.splitdim" title="Figure&nbsp;2.8.&nbsp;Split dimension example">Figure&nbsp;2.8, &#8220;Split dimension example&#8221;</a>.</p><div class="figure"><a name="binary_data_resource.splitdim"></a><p class="title"><b>Figure&nbsp;2.8.&nbsp;Split dimension example</b></p><div class="figure-contents"><pre class="programlisting">&lt;dataResource xsi:type="binaryDataResource_t"&gt;
  &lt;uri offset="9240" size="589824"&gt;img0001.dcm&lt;/uri&gt;
  &lt;elementType&gt;uint32&lt;/elementType&gt;
  &lt;byteOrder&gt;lsbfirst&lt;/byteOrder&gt;
  &lt;dimension label="x"&gt;
    &lt;size&gt;64&lt;/size&gt;
  &lt;/dimension&gt;
  &lt;dimension label="z" splitRank="1"&gt;
    &lt;size&gt;6&lt;/size&gt;
  &lt;/dimension&gt;
  &lt;dimension label="y"&gt;
    &lt;size&gt;64&lt;/size&gt;
  &lt;/dimension&gt;
  &lt;dimension label="z" splitRank="2"&gt;
    &lt;size&gt;6&lt;/size&gt;
  &lt;/dimension&gt;
&lt;/dataResource&gt;</pre></div></div><br class="figure-break"><p>Applications should read this data as if it were four dimensions, and then permute the data to bring the two z dimensions together (in the order specified by splitRank) in the position of the highest-ranked split dimension, and the two dimensions can then be merged into one.  The size of the new z dimension is the product of the sizes of the component split dimensions, so 6 * 6 = 36.</p><p>You may recall that the original data was acquired as a 64x64x32 volume, but the NxN tiling representation requires that the number of tiles be the square of an integer N.  One more mechanism has been added to the <code class="literal">&lt;dimension&gt;</code> element to accomodate the presence of data that should be disregarded: the <code class="literal">outputSelect</code> attribute (see <a href="#binary_data_resource.outputSelect" title="Figure&nbsp;2.9.&nbsp;outputSelect example">Figure&nbsp;2.9, &#8220;<code class="literal">outputSelect</code> example&#8221;</a>).</p><div class="figure"><a name="binary_data_resource.outputSelect"></a><p class="title"><b>Figure&nbsp;2.9.&nbsp;<code class="literal">outputSelect</code> example</b></p><div class="figure-contents"><pre class="programlisting">&lt;dataResource xsi:type="binaryDataResource_t"&gt;
  &lt;uri offset="0" size="589824"&gt;img0001.dcm&lt;/uri&gt;
  &lt;elementType&gt;uint32&lt;/elementType&gt;
  &lt;byteOrder&gt;lsbfirst&lt;/byteOrder&gt;
  &lt;dimension label="x"&gt;
    &lt;size&gt;64&lt;/size&gt;
  &lt;/dimension&gt;
  &lt;dimension label="z" splitRank="1"&gt;
    &lt;size&gt;6&lt;/size&gt;
  &lt;/dimension&gt;
  &lt;dimension label="y"&gt;
    &lt;size&gt;64&lt;/size&gt;
  &lt;/dimension&gt;
  &lt;dimension label="z" splitRank="2" outputSelect="0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31"&gt;
    &lt;size&gt;6&lt;/size&gt;
  &lt;/dimension&gt;
&lt;/dataResource&gt;</pre></div></div><br class="figure-break"><p>The <code class="literal">outputSelect</code> attribute specifies a list of indices along the given dimension (or combined dimension if it occurs on the highest-ranked component of a split dimension) that should be regarded as valid data.  Data in the other indices should be ignored.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e643"></a>Chapter&nbsp;3.&nbsp;Catalogs</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e648">Overview</a></span></dt><dt><span class="section"><a href="#d0e651">Examples</a></span></dt><dt><span class="section"><a href="#d0e654">Reference</a></span></dt></dl></div><p>This is where the catalog text goes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e648"></a>Overview</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e651"></a>Examples</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e654"></a>Reference</h2></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e657"></a>Chapter&nbsp;4.&nbsp;Provenance</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e662">Overview</a></span></dt><dt><span class="section"><a href="#d0e665">Examples</a></span></dt><dt><span class="section"><a href="#d0e668">Reference</a></span></dt></dl></div><p>This is where the provenance text goes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e662"></a>Overview</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e665"></a>Examples</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e668"></a>Reference</h2></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e671"></a>Chapter&nbsp;5.&nbsp;Events</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e674">Overview</a></span></dt><dt><span class="section"><a href="#d0e762">Examples</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e674"></a>Overview</h2></div></div></div><p><span class="emphasis"><em>Events</em></span> in XCEDE are merely time intervals annotated with arbitrary metadata.  This component can be used to represent several types of behavioral data, statistics calculated on time series data, or any other metadata whose proper interpretation requires that it be associated with a particular time interval.</p><p>An XCEDE event consists of the following:</p><div class="variablelist"><dl><dt><span class="term">onset</span></dt><dd><p>The onset (in seconds) of the time interval.</p></dd><dt><span class="term">duration</span></dt><dd><p>The duration (in seconds) of the time interval.</p></dd><dt><span class="term">type</span></dt><dd><p>Usage of this field is user-specified</p></dd><dt><span class="term">name</span></dt><dd><p>Usage of this field is user-specified</p></dd><dt><span class="term">units</span></dt><dd><p>The units of the onset and duration fields.  This field is optional, and it is recommended that users of the schema prescribe an implicit unit of measurement and use it consistently.  In that case, this field may be considered informational only.</p></dd><dt><span class="term">values</span></dt><dd><p>A <span class="emphasis"><em>value</em></span> adds named metadata to this event.</p></dd></dl></div><p>The following instance shows how each of these fields may be populated.</p><pre class="programlisting">&lt;event type="visual" name="event#1" units="sec"&gt;
  &lt;onset&gt;0&lt;/onset&gt;
  &lt;duration&gt;2&lt;/duration&gt;
  &lt;value name="shape"&gt;square&lt;/value&gt;
  &lt;value name="shapecolor"&gt;red&lt;/value&gt;
&lt;/event&gt;</pre><p>Event elements are stored within the <code class="literal">&lt;data&gt;</code> element of an <code class="literal">&lt;acquisition&gt;</code>.  The <code class="literal">&lt;data&gt;</code> element should be of type <code class="literal">events_t</code> (using <code class="literal">xsi:type</code> &#8212; see examples below).</p><p>All onsets are relative to an arbitrary time reference.  Typically, time 0 (zero) could mean the start of data acquisition.  An event list may be interpreted as concurrent with data in other <code class="literal">&lt;acquisition&gt;</code> elements (which could be other event lists).  If so, the same time reference should be used in all concurrent acquisition data.</p><p>There is no ordering constraint on events in a list.  Applications should depend on using the <code class="literal">&lt;onset&gt;</code> elements to order the events chronologically if they so desire.</p><p>An optional <code class="literal">&lt;params&gt;</code> element may precede the first event in a list, and this element stores arbitrary metadata (using the same <code class="literal">&lt;value&gt;</code> element used above) that apply to all events in the list.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e762"></a>Examples</h2></div></div></div><div class="sidebar"><p class="title"><b></b></p>This example represents stimuli and responses in a neuroimaging study as XCEDE events.  However, this is not the only type of data that can be represented using XCEDE events.  A different example will be shown later in the chapter.</div><div class="figure"><a name="events.timeline"></a><p class="title"><b>Figure&nbsp;5.1.&nbsp;An event timeline</b></p><div class="figure-contents"><div class="mediaobject"><img src="images/events_timeline.gif" alt="An event timeline"></div></div></div><br class="figure-break"><p>Consider the timeline shown in <a href="#events.timeline" title="Figure&nbsp;5.1.&nbsp;An event timeline">Figure&nbsp;5.1, &#8220;An event timeline&#8221;</a>.  We show in <a href="#events.xcede_example" title="Figure&nbsp;5.2.&nbsp;XCEDE Events example">Figure&nbsp;5.2, &#8220;XCEDE Events example&#8221;</a> how the first 5 seconds worth of the events might be represented in XCEDE.</p><div class="figure"><a name="events.xcede_example"></a><p class="title"><b>Figure&nbsp;5.2.&nbsp;XCEDE Events example</b></p><div class="figure-contents"><pre class="programlisting">&lt;XCEDE xmlns="http://www.xcede.org/xcede-2"
       xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'&gt;
  &lt;acquisition ID="my_events"&gt;
    &lt;data xsi:type="events_t"&gt;
      &lt;event type="visual"&gt;
        &lt;onset&gt;0&lt;/onset&gt;
        &lt;duration&gt;2&lt;/duration&gt;
        &lt;value name="shape"&gt;square&lt;/value&gt;
        &lt;value name="shapecolor"&gt;red&lt;/value&gt;
      &lt;/event&gt;
      &lt;event type="visual"&gt;
        &lt;onset&gt;2.5&lt;/onset&gt;
        &lt;duration&gt;2&lt;/duration&gt;
        &lt;value name="shape"&gt;square&lt;/value&gt;
        &lt;value name="shapecolor"&gt;blue&lt;/value&gt;
      &lt;/event&gt;
      &lt;event type="audio"&gt;
        &lt;onset&gt;0.3&lt;/onset&gt;
        &lt;duration&gt;1.4&lt;/onset&gt;
        &lt;value name="frequency"&gt;low&lt;/value&gt;
      &lt;/event&gt;
      &lt;event type="audio"&gt;
        &lt;onset&gt;2.0&lt;/onset&gt;
        &lt;duration&gt;1.4&lt;/onset&gt;
        &lt;value name="frequency"&gt;low&lt;/value&gt;
      &lt;/event&gt;
      &lt;event type="audio"&gt;
        &lt;onset&gt;3.5&lt;/onset&gt;
        &lt;duration&gt;1.4&lt;/onset&gt;
        &lt;value name="frequency"&gt;low&lt;/value&gt;
      &lt;/event&gt;
      &lt;event type="response"&gt;
        &lt;onset&gt;3.4&lt;/onset&gt;
        &lt;value name="button"&gt;1&lt;/value&gt;
      &lt;/event&gt;
    &lt;/data&gt;
  &lt;/acquisition&gt;
&lt;/XCEDE&gt;
</pre></div></div><br class="figure-break"><p>Each stimulus and each response are stored as separate event elements.  Note that all the visual events appear first in the XCEDE file, then the audio events, and then the response event.  This ordering is arbitrary, and the events could easily have been presented in chronological (or random!) order.  The semantic interpretation of the events within an event list must not depend on their document order.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e786"></a>Chapter&nbsp;6.&nbsp;Assessments</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e791">Overview</a></span></dt><dt><span class="section"><a href="#d0e794">Examples</a></span></dt><dt><span class="section"><a href="#d0e797">Reference</a></span></dt></dl></div><p>This is where the assessment text goes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e791"></a>Overview</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e794"></a>Examples</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e797"></a>Reference</h2></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e800"></a>Chapter&nbsp;7.&nbsp;Protocols</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e805">Overview</a></span></dt><dt><span class="section"><a href="#d0e808">Examples</a></span></dt><dt><span class="section"><a href="#d0e811">Reference</a></span></dt></dl></div><p>This is where the protocol text goes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e805"></a>Overview</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e808"></a>Examples</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e811"></a>Reference</h2></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e814"></a>Chapter&nbsp;8.&nbsp;Analysis</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e819">Overview</a></span></dt><dt><span class="section"><a href="#d0e822">Examples</a></span></dt><dt><span class="section"><a href="#d0e825">Reference</a></span></dt></dl></div><p>This is where the analysis text goes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e819"></a>Overview</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e822"></a>Examples</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e825"></a>Reference</h2></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e828"></a>Chapter&nbsp;9.&nbsp;Terminology</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d0e833">Overview</a></span></dt><dt><span class="section"><a href="#d0e836">Examples</a></span></dt><dt><span class="section"><a href="#d0e839">Reference</a></span></dt></dl></div><p>This is where the terminology text goes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e833"></a>Overview</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e836"></a>Examples</h2></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e839"></a>Reference</h2></div></div></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="d0e842"></a>Appendix&nbsp;A.&nbsp;Schema</h2></div></div></div><pre class="programlisting">
    &lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- edited with XMLSPY v2004 rel. 3 U (http://www.xmlspy.com) by dbk (UNIV CA IRVINE) --&gt;
&lt;xs:schema xmlns="http://www.xcede.org/xcede-2" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://purl.oclc.org/dsdl/schematron" xmlns:gml="http://www.opengis.net/gml" targetNamespace="http://www.xcede.org/xcede-2" elementFormDefault="qualified" attributeFormDefault="unqualified"&gt;
	&lt;xs:import namespace="http://www.opengis.net/gml" schemaLocation="http://schemas.opengis.net/gml/3.1.1/base/gml.xsd"/&gt;
	&lt;xs:annotation&gt;
		&lt;xs:documentation&gt;The XCEDE schema provides an extensive metadata hierarchy for describing and documenting research and clinical studies. The schema organizes information into five general hierarchical levels: a complete project; studies within a project; subjects involved in the studies; visits for each of the subjects; the full description of the subject's participation during each visit&lt;/xs:documentation&gt;
		&lt;xs:documentation&gt;Each of these sub-schemas is composed of information relevant to that aspect of an experiment and can be stored in separate XML files or spliced into one large file allowing for the XML data to be stored in a hierarchical directory structure along with the primary data. Each sub-schema also allows for the storage of data provenance information allowing for a traceable record of processing and/or changes to the underlying data. Additionally, the sub-schemas contain support for derived statistical data in the form of human imaging activation maps and simple statistical value lists.&lt;/xs:documentation&gt;
		&lt;xs:documentation&gt;XCEDE was originally designed in the context of neuroimaging studies and complements the Biomedical Informatics Research Network (BIRN) Human Imaging Database, an extensible database and intuitive web-based user interface for the management, discovery, retrieval, and analysis of clinical and brain imaging data. This close coupling allows for an interchangeable source-sink relationship between the database and the XML files, which can be used for the import/export of data to/from the database, the standardized transport and interchange of experimental data, the local storage of experimental information within data collections, and human and machine readable description of the actual data.&lt;/xs:documentation&gt;
	&lt;/xs:annotation&gt;
	&lt;xs:element name="XCEDE"&gt;
		&lt;xs:complexType&gt;
			&lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
				&lt;xs:element name="annotationList" minOccurs="0"&gt;
					&lt;xs:complexType&gt;
						&lt;xs:sequence&gt;
							&lt;xs:element name="annotation" type="textAnnotation_t" minOccurs="0" maxOccurs="unbounded"/&gt;
						&lt;/xs:sequence&gt;
					&lt;/xs:complexType&gt;
				&lt;/xs:element&gt;
				&lt;xs:element name="revisionList" minOccurs="0"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;container for document revision history&lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
					&lt;xs:complexType&gt;
						&lt;xs:sequence&gt;
							&lt;xs:element name="revision" type="revision_t" minOccurs="0" maxOccurs="unbounded"/&gt;
						&lt;/xs:sequence&gt;
					&lt;/xs:complexType&gt;
				&lt;/xs:element&gt;
				&lt;xs:element name="project" type="project_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="subject" type="subject_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="visit" type="visit_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="study" type="study_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="episode" type="episode_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="acquisition" type="acquisition_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="catalog" type="catalog_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="analysis" type="analysis_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="resource" type="resource_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="protocol" type="protocol_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="data" type="abstract_data_t" minOccurs="0" maxOccurs="unbounded"/&gt;
			&lt;/xs:choice&gt;
			&lt;xs:attribute name="version" type="xs:string"/&gt;
		&lt;/xs:complexType&gt;
	&lt;/xs:element&gt;
	&lt;!--*********            Top-level containers            *********--&gt;
	&lt;xs:complexType name="project_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_container_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="projectInfo" type="projectInfo_t" minOccurs="0"/&gt;
					&lt;xs:element name="contributorList" minOccurs="0"&gt;
						&lt;xs:complexType&gt;
							&lt;xs:sequence&gt;
								&lt;xs:element name="contributor" type="person_t" minOccurs="0" maxOccurs="unbounded"/&gt;
							&lt;/xs:sequence&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
					&lt;xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="subjectGroup_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;There should be one of these elements for each subject group in this
				project (e.g. control, patient).&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="subjectID" minOccurs="0" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="ID"/&gt;
		&lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="subject_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_container_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="subjectInfo" type="subjectInfo_t" minOccurs="0"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="visit_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_container_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="visitInfo" type="visitInfo_t" minOccurs="0"/&gt;
					&lt;xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
				&lt;xs:attributeGroup ref="visitExternalIDs_ag"/&gt;
				&lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="study_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_container_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="studyInfo" type="studyInfo_t" minOccurs="0"/&gt;
					&lt;xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
				&lt;xs:attributeGroup ref="studyExternalIDs_ag"/&gt;
				&lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="studyInfo_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_info_t"/&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="episode_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_container_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="episodeInfo" type="episodeInfo_t" minOccurs="0"/&gt;
					&lt;xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
				&lt;xs:attributeGroup ref="episodeExternalIDs_ag"/&gt;
				&lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="acquisition_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_container_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="acquisitionInfo" type="acquisitionInfo_t" minOccurs="0"/&gt;
					&lt;xs:choice minOccurs="0"&gt;
						&lt;xs:element name="dataResourceRef" type="ref_t"&gt;
							&lt;xs:annotation&gt;
								&lt;xs:documentation&gt;A reference to a resource as described above. The
									resource could be part of a catalog, a root level resource,
								etc.&lt;/xs:documentation&gt;
							&lt;/xs:annotation&gt;
						&lt;/xs:element&gt;
						&lt;xs:element name="dataRef" type="ref_t"&gt;
							&lt;xs:annotation&gt;
								&lt;xs:documentation&gt;A refrence to a container that the actual
									acquisition data goes into (as opposed to being in an external
									non-XCEDE format)&lt;/xs:documentation&gt;
							&lt;/xs:annotation&gt;
						&lt;/xs:element&gt;
					&lt;/xs:choice&gt;
					&lt;xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
				&lt;xs:attribute name="acquisitionProtocol" use="optional"/&gt;
				&lt;xs:attributeGroup ref="acquisitionExternalIDs_ag"/&gt;
				&lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="analysis_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;A collection of output from ana analysis of data.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_container_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="provenance" type="provenance_t" minOccurs="0" maxOccurs="unbounded"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;The record of the origin and transformations applied to source data that produced this analysis&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="inputRef" type="analysisRef_t" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="outputRef" type="analysisRef_t" minOccurs="0"/&gt;
					&lt;xs:element name="measurementGroup" type="measurementGroup_t" maxOccurs="unbounded"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;A measurementGroup contains information and data related to the outcome of an analysis.  For example, this could be a statistic (e.g. from a Statistical Parametric Map) or a measurement (e.g. the volume of the hippocmapus).&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
					&lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
						&lt;xs:element name="dataResourceRef" type="ref_t"&gt;
							&lt;xs:annotation&gt;
								&lt;xs:documentation&gt;A reference to a resource as described above. The
									resource could be part of a catalog, a root level resource,
									etc.&lt;/xs:documentation&gt;
							&lt;/xs:annotation&gt;
						&lt;/xs:element&gt;
						&lt;xs:element name="dataRef" type="ref_t"&gt;
							&lt;xs:annotation&gt;
								&lt;xs:documentation&gt;A refrence to a container that the actual
									acquisition data goes into (as opposed to being in an external
									non-XCEDE format)&lt;/xs:documentation&gt;
							&lt;/xs:annotation&gt;
						&lt;/xs:element&gt;
					&lt;/xs:choice&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="observation_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;Observations that are made concerning an entity (e.g. in a measurementGroup).  For example, following hte hippocmapus example, might be the total volume, surface area, etc.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attribute name="name" type="xs:string" use="required"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;The name (preferred label) of the observation value&lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
				&lt;/xs:attribute&gt;
				&lt;xs:attribute name="units" type="xs:string" use="optional"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;The measurement units for the returned value of the observation&lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
				&lt;/xs:attribute&gt;
				&lt;xs:attribute name="type" type="valueTypes_t" use="optional"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;The declared data type for the returned value of the observation&lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
				&lt;/xs:attribute&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="protocol_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_protocol_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="steps" minOccurs="0"&gt;
						&lt;xs:complexType&gt;
							&lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
								&lt;xs:element name="step" type="protocol_t"/&gt;
								&lt;xs:element name="stepRef" type="ref_t"/&gt;
							&lt;/xs:choice&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="items" minOccurs="0"&gt;
						&lt;xs:complexType&gt;
							&lt;xs:sequence&gt;
								&lt;xs:element name="item" type="protocolItem_t" minOccurs="0" maxOccurs="unbounded"/&gt;
							&lt;/xs:sequence&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="catalog_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_tagged_entity_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="catalogList" minOccurs="0"&gt;
						&lt;xs:complexType&gt;
							&lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
								&lt;xs:element name="catalog" type="catalog_t"/&gt;
								&lt;xs:element name="catalogRef"&gt;
									&lt;xs:complexType&gt;
										&lt;xs:attribute name="catalogID" type="xs:string"/&gt;
									&lt;/xs:complexType&gt;
								&lt;/xs:element&gt;
							&lt;/xs:choice&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="entryList" minOccurs="0"&gt;
						&lt;xs:complexType&gt;
							&lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
								&lt;xs:element name="entry" type="resource_t"/&gt;
								&lt;xs:element name="entryDataRef" type="ref_t"&gt;
									&lt;xs:annotation&gt;
										&lt;xs:documentation&gt;A reference to a data element at the top
											level of an XCEDE document&lt;/xs:documentation&gt;
									&lt;/xs:annotation&gt;
								&lt;/xs:element&gt;
								&lt;xs:element name="entryResourceRef" type="ref_t"&gt;
									&lt;xs:annotation&gt;
										&lt;xs:documentation&gt;A reference to a resource element at the
											top level of an XCEDE document&lt;/xs:documentation&gt;
									&lt;/xs:annotation&gt;
								&lt;/xs:element&gt;
							&lt;/xs:choice&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
				&lt;/xs:sequence&gt;
				&lt;xs:attributeGroup ref="ID_name_description"/&gt;
				&lt;xs:attributeGroup ref="levelRef_ag"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="resource_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;A resource is something that we haven't agreed on
			yet.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_tagged_entity_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="uri" type="frag_uri_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
				&lt;xs:attributeGroup ref="ID_name_description"/&gt;
				&lt;xs:attributeGroup ref="levelRef_ag"/&gt;
				&lt;xs:attribute name="format" type="xs:string" use="optional"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;Format of file. E.g. DICOM, Analyze,
						4dfp&lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
				&lt;/xs:attribute&gt;
				&lt;xs:attribute name="content" type="xs:string" use="optional"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;Code indicating the contents of the image. E.g. GFC,
						T88&lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
				&lt;/xs:attribute&gt;
				&lt;xs:attribute name="cachePath" use="optional"&gt;
					&lt;xs:simpleType&gt;
						&lt;xs:restriction base="xs:string"&gt;
							&lt;xs:maxLength value="255"/&gt;
						&lt;/xs:restriction&gt;
					&lt;/xs:simpleType&gt;
				&lt;/xs:attribute&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;!--*********      Top-level ID attribute groups      *********--&gt;
	&lt;xs:attributeGroup name="visitExternalIDs_ag"&gt;
		&lt;xs:attribute name="projectID" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;The content of this attribute should match the ID attribute of the
					project_t to which this element is associated.&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="projectURI" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;This is the location of a document where to find an element
					matching the projectID (see projectID attribute).&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="subjectID" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;The content of this attribute should match the ID attribute of the
					subject_t to which this element is associated.&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="subjectURI" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;This is the location of a document where to find an element
					matching the subjectID (see subjectID attribute).&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="subjectGroupID" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;content of this attribute should match the ID of one of the
					subject groups listed in the project_t associated with this element (see
					projectID and project_t).&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
	&lt;/xs:attributeGroup&gt;
	&lt;xs:attributeGroup name="studyExternalIDs_ag"&gt;
		&lt;xs:attributeGroup ref="visitExternalIDs_ag"/&gt;
		&lt;xs:attribute name="visitID" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;The content of this attribute should match the ID attribute of the
					visit_t to which this element is associated.&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="visitURI" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;This is the location of a document where to find an element
					matching the visitID (see visitID attribute).&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
	&lt;/xs:attributeGroup&gt;
	&lt;xs:attributeGroup name="episodeExternalIDs_ag"&gt;
		&lt;xs:attributeGroup ref="studyExternalIDs_ag"/&gt;
		&lt;xs:attribute name="studyID" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;The content of this attribute should match the ID attribute of the
					study_t to which this element is associated.&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="studyURI" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;This is the location of a document where to find an element
					matching the studyID (see studyID attribute).&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
	&lt;/xs:attributeGroup&gt;
	&lt;xs:attributeGroup name="acquisitionExternalIDs_ag"&gt;
		&lt;xs:attributeGroup ref="episodeExternalIDs_ag"/&gt;
		&lt;xs:attribute name="episodeID" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;The content of this attribute should match the ID attribute of the
					episode_t to which this element is associated.&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="episodeURI" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;This is the location of a document where to find an element
					matching the episodeID (see episodeID attribute).&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
	&lt;/xs:attributeGroup&gt;
	&lt;xs:attributeGroup name="allLevelExternalIDs_ag"&gt;
		&lt;xs:attributeGroup ref="acquisitionExternalIDs_ag"/&gt;
		&lt;xs:attribute name="acquisitionID" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;The content of this attribute should match the ID attribute of the
					acquisition_t to which this element is associated.&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="acquisitionURI" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;This is the location of a document where to find an element
					matching the acquisitionID (see acquisitionID attribute).&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
	&lt;/xs:attributeGroup&gt;
	&lt;xs:attributeGroup name="levelRef_ag"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;Reference to the meta-data element that this catalog is related to.
				Should point to one of the core xcede hierarchy components: project, subject, visit,
				study, acquisition.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:attribute name="level" type="levelDescriptor_t"/&gt;
		&lt;xs:attributeGroup ref="allLevelExternalIDs_ag"/&gt;
	&lt;/xs:attributeGroup&gt;
	&lt;!--*********            Abstract types            *********--&gt;
	&lt;xs:complexType name="abstract_data_t" abstract="true"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_container_t"&gt;
				&lt;xs:attributeGroup ref="levelRef_ag"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="abstract_container_t" abstract="true"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="commentList" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;A comment is a description of the entity refered to by the current element.  For example, a description of a particular subject or series.&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
				&lt;xs:complexType&gt;
					&lt;xs:sequence&gt;
						&lt;xs:element name="comment" type="authoredText_t" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;/xs:sequence&gt;
				&lt;/xs:complexType&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="annotationList" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;An annotation is a description related to the xml document and the current element.  Fore example, some processing that ahs edited content in the element itself.&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
				&lt;xs:complexType&gt;
					&lt;xs:sequence&gt;
						&lt;xs:element name="annotation" type="textAnnotation_t" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;/xs:sequence&gt;
				&lt;/xs:complexType&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="resourceList" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Informational resources related to the
					container&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
				&lt;xs:complexType&gt;
					&lt;xs:sequence&gt;
						&lt;xs:element name="resource" type="informationResource_t" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;/xs:sequence&gt;
				&lt;/xs:complexType&gt;
			&lt;/xs:element&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="ID" type="xs:string"/&gt;
		&lt;xs:attribute name="rev" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Revision number, should correspond with an appropriate revision ID
					in the XCEDE/history element&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="type" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Attribute for creating categories within a container set. For
					example, within study, types might include 'PET' or 'MR'. One could also create
					sub-classes using colon notation: "MR:STRUCT"&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attributeGroup ref="terminology_ag"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="abstract_entity_t" abstract="true"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;entity elements are used to describe the resultant scope of an analysis (e.g. anatomical entity, atlas entity)&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="description" type="xs:string" minOccurs="0"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="ID" type="xs:string"/&gt;
		&lt;xs:attribute name="preferredEntityLabel" type="xs:string" use="required"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Preferred Name for the Entity&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="abstract_info_t" abstract="true"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;info elements are present in each of the hierarchy levels. these can
				be extended to capture instance specific content (following recommendation
			5)&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="description" type="xs:string" minOccurs="0"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="abstract_protocol_t" abstract="true"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="protocolOffset" type="protocolOffset_t" minOccurs="0" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attributeGroup ref="ID_name_description"/&gt;
		&lt;xs:attributeGroup ref="terminology_ag"/&gt;
		&lt;xs:attribute name="level" type="levelDescriptor_t"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Describes the level of the XCEDE hierarchy that this protocol
					instance should be validated against&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="required" type="xs:boolean"/&gt;
		&lt;xs:attribute name="minOccurences" type="xs:integer"/&gt;
		&lt;xs:attribute name="maxOccurences" type="xs:integer"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Are these occurences within a step (i.e. during a single time
					point)? How to refer to repeats across steps?&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="minTimeFromStart" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Absolute time from start of overall protocol&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="maxTimeFromStart" type="xs:string"/&gt;
	&lt;/xs:complexType&gt;
	&lt;!--*********            Misc. types            *********--&gt;
	&lt;xs:complexType name="projectInfo_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_info_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="exptDesignList" minOccurs="0"&gt;
						&lt;xs:complexType&gt;
							&lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
								&lt;xs:element name="exptDesign"/&gt;
								&lt;xs:element name="exptDesignRef" type="ref_t"/&gt;
							&lt;/xs:choice&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="subjectGroupList" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;This provides a mapping of subjects to subject groups
								within projects. A subject can be a member of subject groups in
								multiple projects.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
						&lt;xs:complexType&gt;
							&lt;xs:sequence&gt;
								&lt;xs:element name="subjectGroup" type="subjectGroup_t" minOccurs="0" maxOccurs="unbounded"/&gt;
							&lt;/xs:sequence&gt;
							&lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
					&lt;xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
				&lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="subjectInfo_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_info_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="sex" type="terminologyString_t" minOccurs="0"/&gt;
					&lt;xs:element name="species" type="terminologyString_t" minOccurs="0"/&gt;
					&lt;xs:element name="birthdate" type="terminologyString_t" minOccurs="0"/&gt;
					&lt;xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
				&lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="visitInfo_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_info_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="timeStamp" type="xs:dateTime" minOccurs="0"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="episodeInfo_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_info_t"/&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="acquisitionInfo_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_info_t"/&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="measurementGroup_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;A measurementGroup contains information and data related to the outcome of an analysis.  For example, this could be a statistic (e.g. from a Statistical Parametric Map) or a measurement (e.g. the volume of the hippocmapus).&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_container_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="entity" type="abstract_entity_t" maxOccurs="unbounded"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;In the context of a measurement Group, is the entity being measured.  For example, the hippocampus. &lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="observation" type="observation_t" maxOccurs="unbounded"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;In the context of a measurement Group, are the observations that are made concerning the entity.  For example, following hte hippocmapus example, might be the total volume, surface area, etc.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="nomenclature_t"&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attribute name="abbreviation" type="xs:string"/&gt;
				&lt;xs:attribute name="nomenclature" type="xs:string"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="atlasEntityGML_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;entity elements are used to describe the resultant scope of an analysis&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_entity_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="atlasEntity" type="gml:AbstractGeometryType"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;Atlas entity defined through the use of GML base geometries.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="anatomicalEntity_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;Entity elements are used to describe the resultant scope of an analysis&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_entity_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="label" type="terminologyString_t" minOccurs="0" maxOccurs="unbounded"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;The set of terms that name this entity.  This set can contain a collection of synonymous terms&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
				&lt;/xs:sequence&gt;
				&lt;xs:attribute name="laterality" type="laterality_t" use="optional"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;Laterality of region (or none) &lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
				&lt;/xs:attribute&gt;
				&lt;xs:attribute name="tissueType" type="tissueType_t" use="optional"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;Tissue type of region (or none) &lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
				&lt;/xs:attribute&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="protocolItem_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="itemText" minOccurs="0"&gt;
				&lt;xs:complexType&gt;
					&lt;xs:sequence&gt;
						&lt;xs:element name="textLabel" minOccurs="0" maxOccurs="unbounded"&gt;
							&lt;xs:complexType&gt;
								&lt;xs:attribute name="location" use="required"/&gt;
								&lt;xs:attribute name="value" type="xs:string" use="required"/&gt;
							&lt;/xs:complexType&gt;
						&lt;/xs:element&gt;
					&lt;/xs:sequence&gt;
				&lt;/xs:complexType&gt;
			&lt;/xs:element&gt;
			&lt;xs:choice&gt;
				&lt;xs:element name="itemRange" type="protocolItemRange_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;xs:element name="itemChoice" minOccurs="0" maxOccurs="unbounded"&gt;
					&lt;xs:complexType&gt;
						&lt;xs:attribute name="itemCode" type="xs:string"/&gt;
						&lt;xs:attribute name="itemValue" type="xs:string"/&gt;
						&lt;xs:attribute name="ID" type="xs:string"/&gt;
						&lt;xs:attribute name="units" type="xs:string"/&gt;
					&lt;/xs:complexType&gt;
				&lt;/xs:element&gt;
			&lt;/xs:choice&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="name" type="xs:string"/&gt;
		&lt;xs:attribute name="ID" type="xs:string"/&gt;
		&lt;xs:attribute name="required" type="xs:boolean"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="nameValue_t"&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attribute name="name" type="xs:string"/&gt;
				&lt;xs:anyAttribute processContents="lax"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="metadataList_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="value" type="nameValue_t" minOccurs="0" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="ref_t"&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attribute name="ID" type="xs:string"/&gt;
				&lt;xs:attribute name="URI" type="xs:string"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="assessmentInfo_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_info_t"/&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="assessment_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_data_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="name" type="xs:string"/&gt;
					&lt;xs:element name="dataInstance" minOccurs="0" maxOccurs="unbounded"&gt;
						&lt;xs:complexType&gt;
							&lt;xs:sequence&gt;
								&lt;xs:element name="assessmentInfo" type="assessmentInfo_t" minOccurs="0"&gt;
									&lt;xs:annotation&gt;
										&lt;xs:documentation&gt;Block for describing things like
											informant, clinical rater, assessment date,
										etc&lt;/xs:documentation&gt;
									&lt;/xs:annotation&gt;
								&lt;/xs:element&gt;
								&lt;xs:element name="assessmentItem" type="assessmentItem_t" minOccurs="0" maxOccurs="unbounded"/&gt;
							&lt;/xs:sequence&gt;
							&lt;xs:attribute name="validated" type="xs:boolean"&gt;
								&lt;xs:annotation&gt;
									&lt;xs:documentation&gt;Indicates whether the instance has been
										validated (e.g. by reconciling double-entry instances).
										There should be only one validated instance per
									assessment.&lt;/xs:documentation&gt;
								&lt;/xs:annotation&gt;
							&lt;/xs:attribute&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="annotation" type="textAnnotation_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="assessmentDescItem_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="protocolItem_t"&gt;
				&lt;xs:attribute name="version" type="xs:string"/&gt;
				&lt;xs:attribute name="formRef" type="xs:string"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="assessmentItem_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="valueStatus" type="xs:string" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Information on the status of a value (e.g. subject refused to
						answer)&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="value" type="value_t"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Actual value of the assessment item as recorded on the
					form&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="normValue" type="value_t" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Normalized or scaled value of the assessment
					item&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="reconciliationNote" type="textAnnotation_t" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Normalized or scaled value of the assessment
					item&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="annotation" type="textAnnotation_t" minOccurs="0"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attributeGroup ref="terminology_ag"/&gt;
		&lt;xs:attribute name="ID"/&gt;
		&lt;xs:attribute name="name"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="investigator_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="person_t"/&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="authoredText_t"&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attributeGroup ref="authoredText_ag"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="abstract_annotation_t" abstract="true"&gt;
		&lt;xs:attributeGroup ref="authoredText_ag"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="textAnnotation_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_annotation_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="text" type="xs:string" minOccurs="0"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="nsTermAnnotation_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_annotation_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="ontologyClass" type="xs:string" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="nsOntologyAnnotation_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_annotation_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="term" type="xs:string" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="generator_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="application" type="versionedEntity_t"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Program used to generate document&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="invocation" type="xs:string"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Application input required to generate this document. Should
						be explicit such that this document can be re-generated from this
					info&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="dataSource" type="xs:string" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Description of data source with version numbers and/or
						timestamp of data&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:attributeGroup name="authoredText_ag"&gt;
		&lt;xs:attribute name="author" type="xs:string"/&gt;
		&lt;xs:attribute name="timestamp" type="xs:dateTime"/&gt;
	&lt;/xs:attributeGroup&gt;
	&lt;xs:attributeGroup name="terminology_ag"&gt;
		&lt;xs:attribute name="preferredLabel" type="xs:string" use="required"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;The preferred label of this term. This can be different than the term used by the applications (e.g. CBLM versus cerebellum)&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="abbreviation" type="xs:string" use="optional"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;The preferred abbreviation for the term&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="nomenclature" type="xs:string" use="required"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;The source ontology of this terminology/ontology term&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="termID" type="xs:string" use="required"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Applications will likely want to constrain what are valid IDs
					within the context of their application (for example, allowing only
				LSID's)&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="termPath" type="xs:string" use="optional"/&gt;
	&lt;/xs:attributeGroup&gt;
	&lt;xs:simpleType name="uniqueID_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt; Having a distinct unique ID type is a convenience for building
				referential links. The reason we are not using the native XML Schema ID attribute is
				that enforces document-wide uniqueness, whereas there may be instances of this
				bioterm schema that contain multiple namespace-qualified term or ontology class sets
				where IDs are unique within their namespace but not across the entire document.
			&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:restriction base="xs:string"&gt;
			&lt;xs:pattern value="[A-Za-z0-9\-:_.]+"/&gt;
		&lt;/xs:restriction&gt;
	&lt;/xs:simpleType&gt;
	&lt;xs:complexType name="person_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;Add additional fields (address, email, etc)&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="salutation" type="xs:string" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;e.g. Dr., Mr., Mrs.&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="givenName" type="xs:string" minOccurs="0"/&gt;
			&lt;xs:element name="middleName" type="xs:string" minOccurs="0"/&gt;
			&lt;xs:element name="surname" type="xs:string" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Used for last name or only name (e.g.
					Prince)&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="academicTitles" type="xs:string" minOccurs="0"/&gt;
			&lt;xs:element name="institution" type="xs:string" minOccurs="0"/&gt;
			&lt;xs:element name="department" type="xs:string" minOccurs="0"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="ID" type="xs:string"/&gt;
		&lt;xs:attribute name="role" type="xs:string"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="mixedType_t" mixed="true"/&gt;
	&lt;xs:complexType name="versionedEntity_t"&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attribute name="version" type="xs:string"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:simpleType name="levelDescriptor_t"&gt;
		&lt;xs:restriction base="xs:string"&gt;
			&lt;xs:enumeration value="project"/&gt;
			&lt;xs:enumeration value="subject"/&gt;
			&lt;xs:enumeration value="visit"/&gt;
			&lt;xs:enumeration value="study"/&gt;
			&lt;xs:enumeration value="episode"/&gt;
			&lt;xs:enumeration value="acquisition"/&gt;
		&lt;/xs:restriction&gt;
	&lt;/xs:simpleType&gt;
	&lt;xs:complexType name="protocolOffset_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="protocolTimeRef" type="unitString_t" minOccurs="0"/&gt;
			&lt;xs:element name="preferedTimeOffset" type="unitString_t" minOccurs="0"/&gt;
			&lt;xs:element name="minTimeOffset" type="unitString_t" minOccurs="0"/&gt;
			&lt;xs:element name="maxTimeOffset" type="unitString_t" minOccurs="0"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="protocolItemChoice_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="value" type="xs:string" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="units" type="xs:string"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="protocolItemRange_t"&gt;
		&lt;xs:attribute name="min" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Minimum value for item (inclusive)&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="max" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Maximum value for item (inclusive)&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="units" type="xs:string"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:attributeGroup name="ID_name_description"&gt;
		&lt;xs:attribute name="ID" type="xs:string"/&gt;
		&lt;xs:attribute name="name" type="xs:string"/&gt;
		&lt;xs:attribute name="description" type="xs:string"/&gt;
	&lt;/xs:attributeGroup&gt;
	&lt;xs:complexType name="terminologyString_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;A simple representation of terms for use within the schema.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attributeGroup ref="terminology_ag"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="admin"&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"/&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="unitString_t"&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attribute name="units" type="xs:string"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="revision_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="timestamp" type="xs:dateTime" minOccurs="0"/&gt;
			&lt;xs:element name="generator" type="generator_t" minOccurs="0"/&gt;
			&lt;xs:element name="annotation" type="textAnnotation_t" minOccurs="0"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="ID" type="xs:string"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="orderedString_t"&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attribute name="order" type="xs:string"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="value_t"&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attribute name="units" type="xs:string"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:simpleType name="valueTypes_t"&gt;
		&lt;xs:restriction base="xs:string"&gt;
			&lt;xs:enumeration value="float"/&gt;
			&lt;xs:enumeration value="boolean"/&gt;
			&lt;xs:enumeration value="varchar"/&gt;
			&lt;xs:enumeration value="integer"/&gt;
			&lt;xs:enumeration value="URI"/&gt;
		&lt;/xs:restriction&gt;
	&lt;/xs:simpleType&gt;
	&lt;xs:complexType name="catalogEntry_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="metadataList" type="metadataList_t" minOccurs="0"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attributeGroup ref="levelRef_ag"/&gt;
		&lt;xs:attributeGroup ref="ID_name_description"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="analysisRef_t"&gt;
		&lt;xs:attributeGroup ref="levelRef_ag"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:simpleType name="laterality_t"&gt;
		&lt;xs:restriction base="xs:string"/&gt;
	&lt;/xs:simpleType&gt;
	&lt;xs:simpleType name="tissueType_t"&gt;
		&lt;xs:restriction base="xs:string"/&gt;
	&lt;/xs:simpleType&gt;
	&lt;!--*********            Provenance types            *********--&gt;
	&lt;xs:complexType name="processStep_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="package" type="versionedEntity_t" minOccurs="0"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Software package that contains the program&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="program" type="versionedEntity_t"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Software executable to was run in this step
					&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="programInvocation" type="mixedType_t"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation&gt;Exact command line text used to run the
					executable&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="timeStamp" type="mixedType_t"/&gt;
			&lt;xs:element name="cvs" type="mixedType_t" minOccurs="0"/&gt;
			&lt;xs:element name="user" type="mixedType_t" minOccurs="0"/&gt;
			&lt;xs:element name="machine" type="mixedType_t" minOccurs="0"/&gt;
			&lt;xs:element name="platform" type="versionedEntity_t" minOccurs="0"/&gt;
			&lt;xs:element name="compiler" type="versionedEntity_t" minOccurs="0"/&gt;
			&lt;xs:element name="library" type="versionedEntity_t" minOccurs="0" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="provenance_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;Note: sourceData should be included along with application parameters
				and configuration values&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="processStep" type="processStep_t" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="ID" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;Optional identifier indicating the &lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
	&lt;/xs:complexType&gt;
	&lt;!--*********            Resource types            *********--&gt;
	&lt;xs:complexType name="informationResource_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="resource_t"/&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="dcResource_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="resource_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="title" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="creator" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="subject" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="description" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="publisher" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="contributor" type="orderedString_t" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="date" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="type" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="format" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="identifier" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="source" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="language" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="relation" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="coverage" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="rights" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="dataResource_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="resource_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="provenance" type="provenance_t" minOccurs="0"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="binaryDataResource_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;The parent type (abstract_resource_t) can describe a stream of data.
				The extensions in this derived type (binaryDataResource_t) tell you that this data
				stream is composed of a sequence of units of a given data type and byte order. If
				the &lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="dataResource_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="elementType" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;This element describes the type of individual data
								elements in the data record. For numeric data types, this indicates
								whether the element type is a signed integer ("int"), unsigned
								integer ("uint"), or floating-point ("float"), as well as the number
								of bits allocated to each element.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
						&lt;xs:simpleType&gt;
							&lt;xs:restriction base="xs:string"&gt;
								&lt;xs:enumeration value="int8"/&gt;
								&lt;xs:enumeration value="uint8"/&gt;
								&lt;xs:enumeration value="int16"/&gt;
								&lt;xs:enumeration value="uint16"/&gt;
								&lt;xs:enumeration value="int32"/&gt;
								&lt;xs:enumeration value="uint32"/&gt;
								&lt;xs:enumeration value="int64"/&gt;
								&lt;xs:enumeration value="uint64"/&gt;
								&lt;xs:enumeration value="float32"/&gt;
								&lt;xs:enumeration value="float64"/&gt;
								&lt;xs:enumeration value="ascii"/&gt;
							&lt;/xs:restriction&gt;
						&lt;/xs:simpleType&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="byteOrder" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;This element describes whether the individual data
								elements in the data record are stored with the
								most-significant-byte first (msbfirst) or least-significant-byte
								first (lsbfirst). This element is required if the the data type
								given by the "elementtype" element has a size larger than one
							byte.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
						&lt;xs:simpleType&gt;
							&lt;xs:restriction base="xs:string"&gt;
								&lt;xs:enumeration value="lsbfirst"/&gt;
								&lt;xs:enumeration value="msbfirst"/&gt;
							&lt;/xs:restriction&gt;
						&lt;/xs:simpleType&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="compression" type="xs:string" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation&gt;If this element is present, the files pointed to by
								the uri elements are compressed data files. The only compression
								method specifically named by this specification is "gzip". As a
								special case for binaryDataResource_t and derived types, files
								compressed with gzip and containing a .gz suffix can be referenced
								in the uri element without the suffix. If a file pointed to by the
								URI does not exist, the application should search for the same file
								with the .gz suffix appended -- if it exists, use that file and act
								as if the compression element had been specified with the value
								"gzip". This allows the referenced files to be compressed or
								uncompressed at will (as long as the .gz suffix is appropriately
								added/removed from the filename), without needing to change the
								URI's in this element.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="dimensionedBinaryDataResource_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation xml:lang="en"&gt;This type adds multi-dimensionality to the
				(uni-dimensional) data stream represented by
			binaryDataResource_t.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="binaryDataResource_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="dimension" type="binaryDataDimension_t" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="mappedBinaryDataResource_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation xml:lang="en"&gt;This type places the multi-dimensional data array (say a
				3-dimensional cube) into a coordinate space (say MR scanner
			coordinates).&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="binaryDataResource_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="dimension" type="mappedBinaryDataDimension_t" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="originCoords" type="xs:string" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation xml:lang="en"&gt;This is a coordinate tuple giving the
								location of the first item in the data. For example, if this is an
								MR volume, this could be a triple giving the location in RAS
								coordinates of the first voxel in the data.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="binaryDataDimension_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation xml:lang="en"&gt;This element stores information about one of the N
				dimensions in the data record. Multiple instances of this element are ordered from
				fastest-moving to slowest-moving. These elements provide information to describe the
				size (in data elements) of the N-dimensional bounding box for the data, and in some
				cases to describe the mapping of indexes within this bounding box to 'real-world'
				coordinates.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="size" type="xs:int"&gt;
				&lt;xs:annotation&gt;
					&lt;xs:documentation xml:lang="en"&gt;The number of elements in the data along one
						traversal of this dimension.&lt;/xs:documentation&gt;
				&lt;/xs:annotation&gt;
			&lt;/xs:element&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="label" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation xml:lang="en"&gt;This is a label for the dimension. The first three
					spatial dimensions (or however many exist) must be labeled, in order, 'x', 'y',
					and 'z'. The first temporal dimension must be labeled 't'.&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="splitRank" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;If this attribute exists, this dimension is a "split" dimension,
					and this dimension must be "merged" with one or more other dimensions (with the
					same label) before presenting the data to the application. This is useful, for
					example, if the data is stored in Siemens' Mosaic DICOM format, where slices of
					a 3-D volume are arranged to look like they are tiled onto a square 2-D area. In
					this case, what would normally be called the 'z' dimension has two forks, one
					that occurs before the 'y' dimension (the first row in the data covers the first
					row of several slices), and one that occurs after the 'y' dimension. If, as in
					this case, there are two or more dimensions that should be merged into one, both
					component dimensions should have the label 'z', but have splitRank attributes
					"1" and "2", which specifies the order in which all 'split' dimensions of the
					same label will be merged. After merging, the resultant 'z' dimension element
					should contain the same children of the highest-ranked split 'z' dimension,
					except for the 'size' element, which will be the product of the sizes of all 'z'
					split dimensions. The position of the resultant dimension should be the position
					of the highest-ranked 'z' split dimension. The data itself should also be
					reordered to reflect the new dimension structure.&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="outputSelect" type="xs:string"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation xml:lang="en"&gt;In the same way that the 'splitRank' attribute
					allows you to specify dimensions that should be merged before presenting the
					data to an application, this attribute specifies a data filter along this
					dimension. If this attribute exists, it should contain a whitespace-separated
					list of indices (indexed starting at 0). Only data points along this dimension
					that occur in the index list should be presented to the application. Likewise,
					the 'size' of the dimension, after selection, should be updated to reflect the
					new size of this dimension (which should be the number of indices in the content
					of this attribute).&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="mappedBinaryDataDimension_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="binaryDataDimension_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="origin" type="xs:float" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation xml:lang="en"&gt;A value assigned to the first data
								element along this dimension. For example, if this dimension
								corresponds to "time", this element could store the time
								corresponding to the first data element. If this is a
								two-dimensional projection of the surface of the Earth, and this
								dimension takes you around the Earth parallel to the equator, this
								value could be the degrees longitude. For MRI data, this is the
								single coordinate on the Left-to-Right, Posterior-to-Anterior, or
								Inferior-to-Superior axis to which this dimension most closely
								matches (see 'direction' element and 'rasOrigin' element in
								'mrImageDataResource_t').&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="spacing" type="xs:float" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation xml:lang="en"&gt;This is the average distance between
								consecutive data elements in this dimension. If the spacing is not
								regular, then it may be possible to calculate the actual distance
								between any two data elements in this dimension using the
								'datapoints' element.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="gap" type="xs:float" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation xml:lang="en"&gt;This is the length of the unsampled
								space between consecutive data elements in this dimension, i.e. the
								distance between the end of one data element and the beginning of
								the next. For MRI data, this can be used to specify the gap between
								two collected slices &amp;#x02015; the actual width of each slice
								can be calculated as 'spacing' minus 'gap'.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="datapoints" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation xml:lang="en"&gt;The content of this element is either
								(1) a whitespace-separated list of values, or (2) a list of 'value'
								elements, that can be used as a label for each data point along this
								dimension. The values can be numbers representing points on an axis
								(this is the typical case), text strings, coordinate tuples, etc.
								Any datapoint label that includes whitespace (coordinate tuples
								included) must be encapsulated within a child 'value' element. If
								this element is missing, it is assumed that labels can be calculated
								using information in other fields (such as 'origin', 'spacing',
								etc.). This element is particularly useful for dimensions with
								irregular spacing.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
						&lt;xs:complexType mixed="true"&gt;
							&lt;xs:sequence&gt;
								&lt;xs:element name="value" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
							&lt;/xs:sequence&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="direction" type="listoffloats_t" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation xml:lang="en"&gt;This element contains a vector
								(represented as a whitespace-separated list of floating-point values
								in the appropriate coordinate system) that is parallel to this
								dimension's edge of the bounding box. The vector starts at the first
								element in the data and points towards subsequent elements along
								this dimension. For MRI data, this should be a unit vector in
								(R,A,S) coordinates (positive values are Right, Anterior, or
								Superior respectively) &amp;#x02015; for 'x' and 'y' dimensions,
								this corresponds to the two vectors in the ImagePatientOrientation
								field in DICOM.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="units" type="xs:string" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation xml:lang="en"&gt;This stores the units used for all
								numeric values in this dimension element. In MRI data, this should
								be 'mm' for all spatial dimensions ('x', 'y', 'z') and 'ms' for the
								temporal dimension 't'.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
					&lt;/xs:element&gt;
					&lt;xs:element name="measurementframe" minOccurs="0"&gt;
						&lt;xs:annotation&gt;
							&lt;xs:documentation xml:lang="en"&gt;The mapping (if any) between the values
								expressed in &amp;lt;datapoints&amp;gt; and the coordinate system
								used by this datarec. For example, in DTI data, this is useful for
								mapping gradient direction vectors to the RAS coordinate space used
								in the &amp;lt;direction&amp;gt; vectors.&lt;/xs:documentation&gt;
						&lt;/xs:annotation&gt;
						&lt;xs:complexType&gt;
							&lt;xs:sequence&gt;
								&lt;xs:element name="vector" type="listoffloats_t" minOccurs="0" maxOccurs="unbounded"/&gt;
							&lt;/xs:sequence&gt;
						&lt;/xs:complexType&gt;
					&lt;/xs:element&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="frag_uri_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;The external data pointed to by this uri is a "fragment", where a
				"fragment" is defined as a stream of data contiguously stored in the same file
				offset by 'offset' bytes and of 'size' bytes.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:anyURI"&gt;
				&lt;xs:attribute name="offset" type="xs:unsignedLong"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;The data for this fragment will start at this byte
							position in the resource specified by the 'uri' element. If this
							attribute does not exist or is empty, it is assumed to be
						zero.&lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
				&lt;/xs:attribute&gt;
				&lt;xs:attribute name="size" type="xs:unsignedLong"&gt;
					&lt;xs:annotation&gt;
						&lt;xs:documentation&gt;This specifies the size of this block (in bytes) in the
							resource specified by the 'uri' element. If this attribute does not
							exist or is empty, it is calculated using the dimension and elementtype
							element.&lt;/xs:documentation&gt;
					&lt;/xs:annotation&gt;
				&lt;/xs:attribute&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:simpleType name="listoffloats_t"&gt;
		&lt;xs:list itemType="xs:float"/&gt;
	&lt;/xs:simpleType&gt;
	&lt;xs:complexType name="format_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;Container for describing imaging formats and file name extensions
				(currently underimplemented)&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="description" type="xs:string" minOccurs="0"/&gt;
			&lt;xs:element name="documentationList" minOccurs="0"&gt;
				&lt;xs:complexType&gt;
					&lt;xs:sequence&gt;
						&lt;xs:element name="documentation" type="informationResource_t" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;/xs:sequence&gt;
				&lt;/xs:complexType&gt;
			&lt;/xs:element&gt;
			&lt;xs:element name="extensionList" minOccurs="0"&gt;
				&lt;xs:complexType&gt;
					&lt;xs:sequence&gt;
						&lt;xs:element name="extension" type="xs:string" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;/xs:sequence&gt;
				&lt;/xs:complexType&gt;
			&lt;/xs:element&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="name"/&gt;
	&lt;/xs:complexType&gt;
	&lt;!--*********            Event types            *********--&gt;
	&lt;xs:complexType name="events_t"&gt;
		&lt;xs:complexContent&gt;
			&lt;xs:extension base="abstract_data_t"&gt;
				&lt;xs:sequence&gt;
					&lt;xs:element name="params" type="eventParams_t" minOccurs="0"/&gt;
					&lt;xs:element name="event" type="event_t" minOccurs="0" maxOccurs="unbounded"/&gt;
					&lt;xs:element name="description" type="xs:string" minOccurs="0"/&gt;
					&lt;xs:element name="annotation" type="textAnnotation_t" minOccurs="0" maxOccurs="unbounded"/&gt;
				&lt;/xs:sequence&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:complexContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="event_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;This element represents an interval of time, with arbitrary metadata
				(in the value element).&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="onset" type="xs:float" minOccurs="0"/&gt;
			&lt;xs:element name="duration" type="xs:float" minOccurs="0"/&gt;
			&lt;xs:element name="value" type="eventValue_t" minOccurs="0" maxOccurs="unbounded"/&gt;
			&lt;xs:element name="annotation" type="textAnnotation_t" minOccurs="0" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
		&lt;xs:attribute name="type" type="xs:string" use="optional"/&gt;
		&lt;xs:attribute name="units" type="xs:string" use="optional"&gt;
			&lt;xs:annotation&gt;
				&lt;xs:documentation&gt;This attribute is optional, but an group using this schema should
					agree on, use, and enforce measurement units consistently, to avoid the need for
					unit conversion in an application.&lt;/xs:documentation&gt;
			&lt;/xs:annotation&gt;
		&lt;/xs:attribute&gt;
		&lt;xs:attribute name="name" type="xs:string" use="optional"/&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="eventValue_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;User-specified metadata associated with an event.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:simpleContent&gt;
			&lt;xs:extension base="xs:string"&gt;
				&lt;xs:attribute name="name" type="xs:string"/&gt;
				&lt;xs:anyAttribute processContents="lax"/&gt;
			&lt;/xs:extension&gt;
		&lt;/xs:simpleContent&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="eventParams_t"&gt;
		&lt;xs:annotation&gt;
			&lt;xs:documentation&gt;These value elements apply to all events in the parent event
			list.&lt;/xs:documentation&gt;
		&lt;/xs:annotation&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="value" type="eventValue_t" minOccurs="0" maxOccurs="unbounded"/&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
	&lt;xs:complexType name="abstract_tagged_entity_t"&gt;
		&lt;xs:sequence&gt;
			&lt;xs:element name="metaFields" minOccurs="0"&gt;
				&lt;xs:complexType&gt;
					&lt;xs:sequence minOccurs="0"&gt;
						&lt;xs:element name="metaField" minOccurs="0" maxOccurs="unbounded"&gt;
							&lt;xs:complexType&gt;
								&lt;xs:simpleContent&gt;
									&lt;xs:extension base="xs:string"&gt;
										&lt;xs:attribute name="name" type="xs:string"/&gt;
									&lt;/xs:extension&gt;
								&lt;/xs:simpleContent&gt;
							&lt;/xs:complexType&gt;
						&lt;/xs:element&gt;
					&lt;/xs:sequence&gt;
				&lt;/xs:complexType&gt;
			&lt;/xs:element&gt;
		&lt;/xs:sequence&gt;
	&lt;/xs:complexType&gt;
&lt;/xs:schema&gt;

  </pre></div></div></body></html>