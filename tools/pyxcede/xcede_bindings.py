#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Mon Mar 26 16:33:24 2012 by generateDS.py version 2.7b.
#
# generateDS.py -o xcede_bindings.py -s pyxcede.py --root-element='XCEDE' \
# --namespacedef='xmlns:xcede2="http://www.xcede.org/xcede-2"' \
# --super="xcede_bindings" ../../xcede-2.1-core.xsd
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class XCEDE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, annotationList=None, revisionList=None, project=None, subject=None, visit=None, study=None, episode=None, acquisition=None, catalog=None, analysis=None, resource=None, protocol=None, data=None, provenance=None):
        self.version = _cast(None, version)
        if annotationList is None:
            self.annotationList = []
        else:
            self.annotationList = annotationList
        if revisionList is None:
            self.revisionList = []
        else:
            self.revisionList = revisionList
        if project is None:
            self.project = []
        else:
            self.project = project
        if subject is None:
            self.subject = []
        else:
            self.subject = subject
        if visit is None:
            self.visit = []
        else:
            self.visit = visit
        if study is None:
            self.study = []
        else:
            self.study = study
        if episode is None:
            self.episode = []
        else:
            self.episode = episode
        if acquisition is None:
            self.acquisition = []
        else:
            self.acquisition = acquisition
        if catalog is None:
            self.catalog = []
        else:
            self.catalog = catalog
        if analysis is None:
            self.analysis = []
        else:
            self.analysis = analysis
        if resource is None:
            self.resource = []
        else:
            self.resource = resource
        if protocol is None:
            self.protocol = []
        else:
            self.protocol = protocol
        if data is None:
            self.data = []
        else:
            self.data = data
        if provenance is None:
            self.provenance = []
        else:
            self.provenance = provenance
    def factory(*args_, **kwargs_):
        if XCEDE.subclass:
            return XCEDE.subclass(*args_, **kwargs_)
        else:
            return XCEDE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotationList(self): return self.annotationList
    def set_annotationList(self, annotationList): self.annotationList = annotationList
    def add_annotationList(self, value): self.annotationList.append(value)
    def insert_annotationList(self, index, value): self.annotationList[index] = value
    def get_revisionList(self): return self.revisionList
    def set_revisionList(self, revisionList): self.revisionList = revisionList
    def add_revisionList(self, value): self.revisionList.append(value)
    def insert_revisionList(self, index, value): self.revisionList[index] = value
    def get_project(self): return self.project
    def set_project(self, project): self.project = project
    def add_project(self, value): self.project.append(value)
    def insert_project(self, index, value): self.project[index] = value
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def add_subject(self, value): self.subject.append(value)
    def insert_subject(self, index, value): self.subject[index] = value
    def get_visit(self): return self.visit
    def set_visit(self, visit): self.visit = visit
    def add_visit(self, value): self.visit.append(value)
    def insert_visit(self, index, value): self.visit[index] = value
    def get_study(self): return self.study
    def set_study(self, study): self.study = study
    def add_study(self, value): self.study.append(value)
    def insert_study(self, index, value): self.study[index] = value
    def get_episode(self): return self.episode
    def set_episode(self, episode): self.episode = episode
    def add_episode(self, value): self.episode.append(value)
    def insert_episode(self, index, value): self.episode[index] = value
    def get_acquisition(self): return self.acquisition
    def set_acquisition(self, acquisition): self.acquisition = acquisition
    def add_acquisition(self, value): self.acquisition.append(value)
    def insert_acquisition(self, index, value): self.acquisition[index] = value
    def get_catalog(self): return self.catalog
    def set_catalog(self, catalog): self.catalog = catalog
    def add_catalog(self, value): self.catalog.append(value)
    def insert_catalog(self, index, value): self.catalog[index] = value
    def get_analysis(self): return self.analysis
    def set_analysis(self, analysis): self.analysis = analysis
    def add_analysis(self, value): self.analysis.append(value)
    def insert_analysis(self, index, value): self.analysis[index] = value
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def add_resource(self, value): self.resource.append(value)
    def insert_resource(self, index, value): self.resource[index] = value
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def add_protocol(self, value): self.protocol.append(value)
    def insert_protocol(self, index, value): self.protocol[index] = value
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def add_data(self, value): self.data.append(value)
    def insert_data(self, index, value): self.data[index] = value
    def get_provenance(self): return self.provenance
    def set_provenance(self, provenance): self.provenance = provenance
    def add_provenance(self, value): self.provenance.append(value)
    def insert_provenance(self, index, value): self.provenance[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='xcede2:', name_='XCEDE', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XCEDE')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='XCEDE'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='XCEDE', fromsubclass_=False):
        for annotationList_ in self.annotationList:
            annotationList_.export(outfile, level, namespace_, name_='annotationList')
        for revisionList_ in self.revisionList:
            revisionList_.export(outfile, level, namespace_, name_='revisionList')
        for project_ in self.project:
            project_.export(outfile, level, namespace_, name_='project')
        for subject_ in self.subject:
            subject_.export(outfile, level, namespace_, name_='subject')
        for visit_ in self.visit:
            visit_.export(outfile, level, namespace_, name_='visit')
        for study_ in self.study:
            study_.export(outfile, level, namespace_, name_='study')
        for episode_ in self.episode:
            episode_.export(outfile, level, namespace_, name_='episode')
        for acquisition_ in self.acquisition:
            acquisition_.export(outfile, level, namespace_, name_='acquisition')
        for catalog_ in self.catalog:
            catalog_.export(outfile, level, namespace_, name_='catalog')
        for analysis_ in self.analysis:
            analysis_.export(outfile, level, namespace_, name_='analysis')
        for resource_ in self.resource:
            resource_.export(outfile, level, namespace_, name_='resource')
        for protocol_ in self.protocol:
            protocol_.export(outfile, level, namespace_, name_='protocol')
        for data_ in self.get_data():
            data_.export(outfile, level, namespace_, name_='data')
        for provenance_ in self.provenance:
            provenance_.export(outfile, level, namespace_, name_='provenance')
    def hasContent_(self):
        if (
            self.annotationList or
            self.revisionList or
            self.project or
            self.subject or
            self.visit or
            self.study or
            self.episode or
            self.acquisition or
            self.catalog or
            self.analysis or
            self.resource or
            self.protocol or
            self.data or
            self.provenance
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='XCEDE'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('annotationList=[\n')
        level += 1
        for annotationList_ in self.annotationList:
            showIndent(outfile, level)
            outfile.write('model_.annotationListType(\n')
            annotationList_.exportLiteral(outfile, level, name_='annotationListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('revisionList=[\n')
        level += 1
        for revisionList_ in self.revisionList:
            showIndent(outfile, level)
            outfile.write('model_.revisionListType(\n')
            revisionList_.exportLiteral(outfile, level, name_='revisionListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('project=[\n')
        level += 1
        for project_ in self.project:
            showIndent(outfile, level)
            outfile.write('model_.project_t(\n')
            project_.exportLiteral(outfile, level, name_='project_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('subject=[\n')
        level += 1
        for subject_ in self.subject:
            showIndent(outfile, level)
            outfile.write('model_.subject_t(\n')
            subject_.exportLiteral(outfile, level, name_='subject_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('visit=[\n')
        level += 1
        for visit_ in self.visit:
            showIndent(outfile, level)
            outfile.write('model_.visit_t(\n')
            visit_.exportLiteral(outfile, level, name_='visit_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('study=[\n')
        level += 1
        for study_ in self.study:
            showIndent(outfile, level)
            outfile.write('model_.study_t(\n')
            study_.exportLiteral(outfile, level, name_='study_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('episode=[\n')
        level += 1
        for episode_ in self.episode:
            showIndent(outfile, level)
            outfile.write('model_.episode_t(\n')
            episode_.exportLiteral(outfile, level, name_='episode_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('acquisition=[\n')
        level += 1
        for acquisition_ in self.acquisition:
            showIndent(outfile, level)
            outfile.write('model_.acquisition_t(\n')
            acquisition_.exportLiteral(outfile, level, name_='acquisition_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('catalog=[\n')
        level += 1
        for catalog_ in self.catalog:
            showIndent(outfile, level)
            outfile.write('model_.catalog_t(\n')
            catalog_.exportLiteral(outfile, level, name_='catalog_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('analysis=[\n')
        level += 1
        for analysis_ in self.analysis:
            showIndent(outfile, level)
            outfile.write('model_.analysis_t(\n')
            analysis_.exportLiteral(outfile, level, name_='analysis_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resource=[\n')
        level += 1
        for resource_ in self.resource:
            showIndent(outfile, level)
            outfile.write('model_.resource_t(\n')
            resource_.exportLiteral(outfile, level, name_='resource_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('protocol=[\n')
        level += 1
        for protocol_ in self.protocol:
            showIndent(outfile, level)
            outfile.write('model_.protocol_t(\n')
            protocol_.exportLiteral(outfile, level, name_='protocol_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('data=[\n')
        level += 1
        for data_ in self.data:
            showIndent(outfile, level)
            outfile.write('model_.abstract_data_t(\n')
            data_.exportLiteral(outfile, level, name_='abstract_data_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('provenance=[\n')
        level += 1
        for provenance_ in self.provenance:
            showIndent(outfile, level)
            outfile.write('model_.Container(\n')
            provenance_.exportLiteral(outfile, level, name_='Container')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotationList':
            obj_ = annotationListType.factory()
            obj_.build(child_)
            self.annotationList.append(obj_)
        elif nodeName_ == 'revisionList':
            obj_ = revisionListType.factory()
            obj_.build(child_)
            self.revisionList.append(obj_)
        elif nodeName_ == 'project':
            obj_ = project_t.factory()
            obj_.build(child_)
            self.project.append(obj_)
        elif nodeName_ == 'subject':
            obj_ = subject_t.factory()
            obj_.build(child_)
            self.subject.append(obj_)
        elif nodeName_ == 'visit':
            obj_ = visit_t.factory()
            obj_.build(child_)
            self.visit.append(obj_)
        elif nodeName_ == 'study':
            obj_ = study_t.factory()
            obj_.build(child_)
            self.study.append(obj_)
        elif nodeName_ == 'episode':
            obj_ = episode_t.factory()
            obj_.build(child_)
            self.episode.append(obj_)
        elif nodeName_ == 'acquisition':
            obj_ = acquisition_t.factory()
            obj_.build(child_)
            self.acquisition.append(obj_)
        elif nodeName_ == 'catalog':
            obj_ = catalog_t.factory()
            obj_.build(child_)
            self.catalog.append(obj_)
        elif nodeName_ == 'analysis':
            obj_ = analysis_t.factory()
            obj_.build(child_)
            self.analysis.append(obj_)
        elif nodeName_ == 'resource':
            class_obj_ = self.get_class_obj_(child_, resource_t)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.resource.append(obj_)
        elif nodeName_ == 'protocol':
            obj_ = protocol_t.factory()
            obj_.build(child_)
            self.protocol.append(obj_)
        elif nodeName_ == 'data':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <data> element')
            self.data.append(obj_)
        elif nodeName_ == 'provenance':
            obj_ = Container.factory()
            obj_.build(child_)
            self.provenance.append(obj_)
# end class XCEDE


class subjectGroup_t(GeneratedsSuper):
    """There should be one of these elements for each subject group in this
    project (e.g. control, patient)."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, subjectID=None):
        self.ID = _cast(None, ID)
        if subjectID is None:
            self.subjectID = []
        else:
            self.subjectID = subjectID
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if subjectGroup_t.subclass:
            return subjectGroup_t.subclass(*args_, **kwargs_)
        else:
            return subjectGroup_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subjectID(self): return self.subjectID
    def set_subjectID(self, subjectID): self.subjectID = subjectID
    def add_subjectID(self, value): self.subjectID.append(value)
    def insert_subjectID(self, index, value): self.subjectID[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='subjectGroup_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subjectGroup_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='subjectGroup_t'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='subjectGroup_t', fromsubclass_=False):
        for subjectID_ in self.subjectID:
            showIndent(outfile, level)
            outfile.write('<%ssubjectID>%s</%ssubjectID>\n' % (namespace_, self.gds_format_string(quote_xml(subjectID_).encode(ExternalEncoding), input_name='subjectID'), namespace_))
    def hasContent_(self):
        if (
            self.subjectID
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subjectGroup_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subjectID=[\n')
        level += 1
        for subjectID_ in self.subjectID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(subjectID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subjectID':
            subjectID_ = child_.text
            subjectID_ = self.gds_validate_string(subjectID_, node, 'subjectID')
            self.subjectID.append(subjectID_)
# end class subjectGroup_t


class subjectID(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if subjectID.subclass:
            return subjectID.subclass(*args_, **kwargs_)
        else:
            return subjectID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xcede2:', name_='subjectID', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subjectID')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='subjectID'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='subjectID', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subjectID'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class subjectID


class levelDataRefs_t(GeneratedsSuper):
    """Points out to a level element (using level and {project|subject|subj
    ectGroup|visit|study|episode|acquisition}{ID|URI} attributes)
    and/or a data/analysis element (using {data|analysis}{ID|URI}
    attributes)."""
    subclass = None
    superclass = None
    def __init__(self, dataURI=None, dataID=None, analysisID=None, analysisURI=None, level=None):
        self.dataURI = _cast(None, dataURI)
        self.dataID = _cast(None, dataID)
        self.analysisID = _cast(None, analysisID)
        self.analysisURI = _cast(None, analysisURI)
        self.level = _cast(None, level)
        pass
    def factory(*args_, **kwargs_):
        if levelDataRefs_t.subclass:
            return levelDataRefs_t.subclass(*args_, **kwargs_)
        else:
            return levelDataRefs_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dataURI(self): return self.dataURI
    def set_dataURI(self, dataURI): self.dataURI = dataURI
    def get_dataID(self): return self.dataID
    def set_dataID(self, dataID): self.dataID = dataID
    def get_analysisID(self): return self.analysisID
    def set_analysisID(self, analysisID): self.analysisID = analysisID
    def get_analysisURI(self): return self.analysisURI
    def set_analysisURI(self, analysisURI): self.analysisURI = analysisURI
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def validate_levelDescriptor_t(self, value):
        # Validate type levelDescriptor_t, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='xcede2:', name_='levelDataRefs_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='levelDataRefs_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='levelDataRefs_t'):
        if self.dataURI is not None and 'dataURI' not in already_processed:
            already_processed.append('dataURI')
            outfile.write(' dataURI=%s' % (self.gds_format_string(quote_attrib(self.dataURI).encode(ExternalEncoding), input_name='dataURI'), ))
        if self.dataID is not None and 'dataID' not in already_processed:
            already_processed.append('dataID')
            outfile.write(' dataID=%s' % (self.gds_format_string(quote_attrib(self.dataID).encode(ExternalEncoding), input_name='dataID'), ))
        if self.analysisID is not None and 'analysisID' not in already_processed:
            already_processed.append('analysisID')
            outfile.write(' analysisID=%s' % (self.gds_format_string(quote_attrib(self.analysisID).encode(ExternalEncoding), input_name='analysisID'), ))
        if self.analysisURI is not None and 'analysisURI' not in already_processed:
            already_processed.append('analysisURI')
            outfile.write(' analysisURI=%s' % (self.gds_format_string(quote_attrib(self.analysisURI).encode(ExternalEncoding), input_name='analysisURI'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='levelDataRefs_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='levelDataRefs_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dataURI is not None and 'dataURI' not in already_processed:
            already_processed.append('dataURI')
            showIndent(outfile, level)
            outfile.write('dataURI = "%s",\n' % (self.dataURI,))
        if self.dataID is not None and 'dataID' not in already_processed:
            already_processed.append('dataID')
            showIndent(outfile, level)
            outfile.write('dataID = "%s",\n' % (self.dataID,))
        if self.analysisID is not None and 'analysisID' not in already_processed:
            already_processed.append('analysisID')
            showIndent(outfile, level)
            outfile.write('analysisID = "%s",\n' % (self.analysisID,))
        if self.analysisURI is not None and 'analysisURI' not in already_processed:
            already_processed.append('analysisURI')
            showIndent(outfile, level)
            outfile.write('analysisURI = "%s",\n' % (self.analysisURI,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = "%s",\n' % (self.level,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataURI', node)
        if value is not None and 'dataURI' not in already_processed:
            already_processed.append('dataURI')
            self.dataURI = value
        value = find_attr_value_('dataID', node)
        if value is not None and 'dataID' not in already_processed:
            already_processed.append('dataID')
            self.dataID = value
        value = find_attr_value_('analysisID', node)
        if value is not None and 'analysisID' not in already_processed:
            already_processed.append('analysisID')
            self.analysisID = value
        value = find_attr_value_('analysisURI', node)
        if value is not None and 'analysisURI' not in already_processed:
            already_processed.append('analysisURI')
            self.analysisURI = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
            self.validate_levelDescriptor_t(self.level)    # validate type levelDescriptor_t
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class levelDataRefs_t


class observation_t(GeneratedsSuper):
    """Observations that are made concerning an entity (e.g. in a
    measurementGroup). For example, following hte hippocmapus
    example, might be the total volume, surface area, etc.The name
    (preferred label) of the observation valueThe measurement units
    for the returned value of the observationThe declared data type
    for the returned value of the observation"""
    subclass = None
    superclass = None
    def __init__(self, units=None, type_=None, name=None, valueOf_=None):
        self.units = _cast(None, units)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if observation_t.subclass:
            return observation_t.subclass(*args_, **kwargs_)
        else:
            return observation_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_valueTypes_t(self, value):
        # Validate type valueTypes_t, a restriction on xs:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='observation_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='observation_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='observation_t'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='observation_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='observation_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.validate_valueTypes_t(self.type_)    # validate type valueTypes_t
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class observation_t


class abstract_entity_t(GeneratedsSuper):
    """entity elements are used to describe the resultant scope of an
    analysis (e.g. anatomical entity, atlas entity)Preferred Name
    for the Entity"""
    subclass = None
    superclass = None
    def __init__(self, preferredEntityLabel=None, ID=None, description=None, extensiontype_=None):
        self.preferredEntityLabel = _cast(None, preferredEntityLabel)
        self.ID = _cast(None, ID)
        self.description = description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstract_entity_t.subclass:
            return abstract_entity_t.subclass(*args_, **kwargs_)
        else:
            return abstract_entity_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_preferredEntityLabel(self): return self.preferredEntityLabel
    def set_preferredEntityLabel(self, preferredEntityLabel): self.preferredEntityLabel = preferredEntityLabel
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_entity_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_entity_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_entity_t'):
        if self.preferredEntityLabel is not None and 'preferredEntityLabel' not in already_processed:
            already_processed.append('preferredEntityLabel')
            outfile.write(' preferredEntityLabel=%s' % (self.gds_format_string(quote_attrib(self.preferredEntityLabel).encode(ExternalEncoding), input_name='preferredEntityLabel'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_entity_t', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_entity_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.preferredEntityLabel is not None and 'preferredEntityLabel' not in already_processed:
            already_processed.append('preferredEntityLabel')
            showIndent(outfile, level)
            outfile.write('preferredEntityLabel = "%s",\n' % (self.preferredEntityLabel,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preferredEntityLabel', node)
        if value is not None and 'preferredEntityLabel' not in already_processed:
            already_processed.append('preferredEntityLabel')
            self.preferredEntityLabel = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
# end class abstract_entity_t


class abstract_info_t(GeneratedsSuper):
    """info elements are present in each of the hierarchy levels. these can
    be extended to capture instance specific content (following
    recommendation 5)"""
    subclass = None
    superclass = None
    def __init__(self, description=None, extensiontype_=None):
        self.description = description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstract_info_t.subclass:
            return abstract_info_t.subclass(*args_, **kwargs_)
        else:
            return abstract_info_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_info_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_info_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_info_t'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_info_t', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_info_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
# end class abstract_info_t


class abstract_protocol_t(GeneratedsSuper):
    """Describes the level of the XCEDE hierarchy that this protocol
    instance should be validated againstAre these occurences within
    a step (i.e. during a single time point)? How to refer to
    repeats across steps?"""
    subclass = None
    superclass = None
    def __init__(self, termPath=None, description=None, maxOccurences=None, required=None, nomenclature=None, minOccurences=None, abbreviation=None, preferredLabel=None, termID=None, level=None, ID=None, name=None, protocolOffset=None, extensiontype_=None):
        self.termPath = _cast(None, termPath)
        self.description = _cast(None, description)
        self.maxOccurences = _cast(int, maxOccurences)
        self.required = _cast(bool, required)
        self.nomenclature = _cast(None, nomenclature)
        self.minOccurences = _cast(int, minOccurences)
        self.abbreviation = _cast(None, abbreviation)
        self.preferredLabel = _cast(None, preferredLabel)
        self.termID = _cast(None, termID)
        self.level = _cast(None, level)
        self.ID = _cast(None, ID)
        self.name = _cast(None, name)
        if protocolOffset is None:
            self.protocolOffset = []
        else:
            self.protocolOffset = protocolOffset
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstract_protocol_t.subclass:
            return abstract_protocol_t.subclass(*args_, **kwargs_)
        else:
            return abstract_protocol_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocolOffset(self): return self.protocolOffset
    def set_protocolOffset(self, protocolOffset): self.protocolOffset = protocolOffset
    def add_protocolOffset(self, value): self.protocolOffset.append(value)
    def insert_protocolOffset(self, index, value): self.protocolOffset[index] = value
    def get_termPath(self): return self.termPath
    def set_termPath(self, termPath): self.termPath = termPath
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_maxOccurences(self): return self.maxOccurences
    def set_maxOccurences(self, maxOccurences): self.maxOccurences = maxOccurences
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_nomenclature(self): return self.nomenclature
    def set_nomenclature(self, nomenclature): self.nomenclature = nomenclature
    def get_minOccurences(self): return self.minOccurences
    def set_minOccurences(self, minOccurences): self.minOccurences = minOccurences
    def get_abbreviation(self): return self.abbreviation
    def set_abbreviation(self, abbreviation): self.abbreviation = abbreviation
    def get_preferredLabel(self): return self.preferredLabel
    def set_preferredLabel(self, preferredLabel): self.preferredLabel = preferredLabel
    def get_termID(self): return self.termID
    def set_termID(self, termID): self.termID = termID
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def validate_levelDescriptor_t(self, value):
        # Validate type levelDescriptor_t, a restriction on xs:string.
        pass
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_protocol_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_protocol_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_protocol_t'):
        if self.termPath is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            outfile.write(' termPath=%s' % (self.gds_format_string(quote_attrib(self.termPath).encode(ExternalEncoding), input_name='termPath'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.maxOccurences is not None and 'maxOccurences' not in already_processed:
            already_processed.append('maxOccurences')
            outfile.write(' maxOccurences="%s"' % self.gds_format_integer(self.maxOccurences, input_name='maxOccurences'))
        if self.required is not None and 'required' not in already_processed:
            already_processed.append('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.required)), input_name='required'))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            outfile.write(' nomenclature=%s' % (self.gds_format_string(quote_attrib(self.nomenclature).encode(ExternalEncoding), input_name='nomenclature'), ))
        if self.minOccurences is not None and 'minOccurences' not in already_processed:
            already_processed.append('minOccurences')
            outfile.write(' minOccurences="%s"' % self.gds_format_integer(self.minOccurences, input_name='minOccurences'))
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            outfile.write(' abbreviation=%s' % (self.gds_format_string(quote_attrib(self.abbreviation).encode(ExternalEncoding), input_name='abbreviation'), ))
        if self.preferredLabel is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            outfile.write(' preferredLabel=%s' % (self.gds_format_string(quote_attrib(self.preferredLabel).encode(ExternalEncoding), input_name='preferredLabel'), ))
        if self.termID is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            outfile.write(' termID=%s' % (self.gds_format_string(quote_attrib(self.termID).encode(ExternalEncoding), input_name='termID'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_protocol_t', fromsubclass_=False):
        for protocolOffset_ in self.protocolOffset:
            protocolOffset_.export(outfile, level, namespace_, name_='protocolOffset')
    def hasContent_(self):
        if (
            self.protocolOffset
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_protocol_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.termPath is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            showIndent(outfile, level)
            outfile.write('termPath = "%s",\n' % (self.termPath,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.maxOccurences is not None and 'maxOccurences' not in already_processed:
            already_processed.append('maxOccurences')
            showIndent(outfile, level)
            outfile.write('maxOccurences = %d,\n' % (self.maxOccurences,))
        if self.required is not None and 'required' not in already_processed:
            already_processed.append('required')
            showIndent(outfile, level)
            outfile.write('required = %s,\n' % (self.required,))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            showIndent(outfile, level)
            outfile.write('nomenclature = "%s",\n' % (self.nomenclature,))
        if self.minOccurences is not None and 'minOccurences' not in already_processed:
            already_processed.append('minOccurences')
            showIndent(outfile, level)
            outfile.write('minOccurences = %d,\n' % (self.minOccurences,))
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            showIndent(outfile, level)
            outfile.write('abbreviation = "%s",\n' % (self.abbreviation,))
        if self.preferredLabel is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            showIndent(outfile, level)
            outfile.write('preferredLabel = "%s",\n' % (self.preferredLabel,))
        if self.termID is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            showIndent(outfile, level)
            outfile.write('termID = "%s",\n' % (self.termID,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = "%s",\n' % (self.level,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('protocolOffset=[\n')
        level += 1
        for protocolOffset_ in self.protocolOffset:
            showIndent(outfile, level)
            outfile.write('model_.protocolOffset_t(\n')
            protocolOffset_.exportLiteral(outfile, level, name_='protocolOffset_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('termPath', node)
        if value is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            self.termPath = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
        value = find_attr_value_('maxOccurences', node)
        if value is not None and 'maxOccurences' not in already_processed:
            already_processed.append('maxOccurences')
            try:
                self.maxOccurences = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.append('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('nomenclature', node)
        if value is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            self.nomenclature = value
        value = find_attr_value_('minOccurences', node)
        if value is not None and 'minOccurences' not in already_processed:
            already_processed.append('minOccurences')
            try:
                self.minOccurences = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('abbreviation', node)
        if value is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            self.abbreviation = value
        value = find_attr_value_('preferredLabel', node)
        if value is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            self.preferredLabel = value
        value = find_attr_value_('termID', node)
        if value is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            self.termID = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
            self.validate_levelDescriptor_t(self.level)    # validate type levelDescriptor_t
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocolOffset':
            obj_ = protocolOffset_t.factory()
            obj_.build(child_)
            self.protocolOffset.append(obj_)
# end class abstract_protocol_t


class projectInfo_t(abstract_info_t):
    subclass = None
    superclass = abstract_info_t
    def __init__(self, description=None, exptDesignList=None, subjectGroupList=None, anytypeobjs_=None):
        super(projectInfo_t, self).__init__(description, )
        self.exptDesignList = exptDesignList
        self.subjectGroupList = subjectGroupList
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if projectInfo_t.subclass:
            return projectInfo_t.subclass(*args_, **kwargs_)
        else:
            return projectInfo_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exptDesignList(self): return self.exptDesignList
    def set_exptDesignList(self, exptDesignList): self.exptDesignList = exptDesignList
    def get_subjectGroupList(self): return self.subjectGroupList
    def set_subjectGroupList(self, subjectGroupList): self.subjectGroupList = subjectGroupList
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='projectInfo_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='projectInfo_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='projectInfo_t'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        super(projectInfo_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='projectInfo_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='projectInfo_t', fromsubclass_=False):
        super(projectInfo_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.exptDesignList is not None:
            self.exptDesignList.export(outfile, level, namespace_, name_='exptDesignList')
        if self.subjectGroupList is not None:
            self.subjectGroupList.export(outfile, level, namespace_, name_='subjectGroupList')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.exptDesignList is not None or
            self.subjectGroupList is not None or
            self.anytypeobjs_ or
            super(projectInfo_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='projectInfo_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
        super(projectInfo_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(projectInfo_t, self).exportLiteralChildren(outfile, level, name_)
        if self.exptDesignList is not None:
            showIndent(outfile, level)
            outfile.write('exptDesignList=model_.exptDesignListType(\n')
            self.exptDesignList.exportLiteral(outfile, level, name_='exptDesignList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subjectGroupList is not None:
            showIndent(outfile, level)
            outfile.write('subjectGroupList=model_.subjectGroupListType(\n')
            self.subjectGroupList.exportLiteral(outfile, level, name_='subjectGroupList')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(projectInfo_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exptDesignList':
            obj_ = exptDesignListType.factory()
            obj_.build(child_)
            self.set_exptDesignList(obj_)
        elif nodeName_ == 'subjectGroupList':
            obj_ = subjectGroupListType.factory()
            obj_.build(child_)
            self.set_subjectGroupList(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'projectInfo_t')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(projectInfo_t, self).buildChildren(child_, node, nodeName_, True)
# end class projectInfo_t


class subjectInfo_t(abstract_info_t):
    subclass = None
    superclass = abstract_info_t
    def __init__(self, description=None, sex=None, species=None, birthdate=None, anytypeobjs_=None):
        super(subjectInfo_t, self).__init__(description, )
        self.sex = sex
        self.species = species
        self.birthdate = birthdate
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if subjectInfo_t.subclass:
            return subjectInfo_t.subclass(*args_, **kwargs_)
        else:
            return subjectInfo_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sex(self): return self.sex
    def set_sex(self, sex): self.sex = sex
    def get_species(self): return self.species
    def set_species(self, species): self.species = species
    def get_birthdate(self): return self.birthdate
    def set_birthdate(self, birthdate): self.birthdate = birthdate
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='subjectInfo_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subjectInfo_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='subjectInfo_t'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        super(subjectInfo_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='subjectInfo_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='subjectInfo_t', fromsubclass_=False):
        super(subjectInfo_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.sex is not None:
            self.sex.export(outfile, level, namespace_, name_='sex')
        if self.species is not None:
            self.species.export(outfile, level, namespace_, name_='species')
        if self.birthdate is not None:
            self.birthdate.export(outfile, level, namespace_, name_='birthdate')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.sex is not None or
            self.species is not None or
            self.birthdate is not None or
            self.anytypeobjs_ or
            super(subjectInfo_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subjectInfo_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
        super(subjectInfo_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(subjectInfo_t, self).exportLiteralChildren(outfile, level, name_)
        if self.sex is not None:
            showIndent(outfile, level)
            outfile.write('sex=model_.terminologyString_t(\n')
            self.sex.exportLiteral(outfile, level, name_='sex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.species is not None:
            showIndent(outfile, level)
            outfile.write('species=model_.terminologyString_t(\n')
            self.species.exportLiteral(outfile, level, name_='species')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.birthdate is not None:
            showIndent(outfile, level)
            outfile.write('birthdate=model_.terminologyString_t(\n')
            self.birthdate.exportLiteral(outfile, level, name_='birthdate')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(subjectInfo_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sex':
            obj_ = terminologyString_t.factory()
            obj_.build(child_)
            self.set_sex(obj_)
        elif nodeName_ == 'species':
            obj_ = terminologyString_t.factory()
            obj_.build(child_)
            self.set_species(obj_)
        elif nodeName_ == 'birthdate':
            obj_ = terminologyString_t.factory()
            obj_.build(child_)
            self.set_birthdate(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'subjectInfo_t')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(subjectInfo_t, self).buildChildren(child_, node, nodeName_, True)
# end class subjectInfo_t


class studyInfo_t(abstract_info_t):
    subclass = None
    superclass = abstract_info_t
    def __init__(self, description=None, timeStamp=None):
        super(studyInfo_t, self).__init__(description, )
        self.timeStamp = timeStamp
    def factory(*args_, **kwargs_):
        if studyInfo_t.subclass:
            return studyInfo_t.subclass(*args_, **kwargs_)
        else:
            return studyInfo_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def export(self, outfile, level, namespace_='xcede2:', name_='studyInfo_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='studyInfo_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='studyInfo_t'):
        super(studyInfo_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='studyInfo_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='studyInfo_t', fromsubclass_=False):
        super(studyInfo_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimeStamp>%s</%stimeStamp>\n' % (namespace_, self.gds_format_string(quote_xml(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), namespace_))
    def hasContent_(self):
        if (
            self.timeStamp is not None or
            super(studyInfo_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='studyInfo_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(studyInfo_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(studyInfo_t, self).exportLiteralChildren(outfile, level, name_)
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('timeStamp=%s,\n' % quote_python(self.timeStamp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(studyInfo_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timeStamp':
            timeStamp_ = child_.text
            timeStamp_ = self.gds_validate_string(timeStamp_, node, 'timeStamp')
            self.timeStamp = timeStamp_
        super(studyInfo_t, self).buildChildren(child_, node, nodeName_, True)
# end class studyInfo_t


class visitInfo_t(abstract_info_t):
    subclass = None
    superclass = abstract_info_t
    def __init__(self, description=None, timeStamp=None, subjectAge=None):
        super(visitInfo_t, self).__init__(description, )
        self.timeStamp = timeStamp
        self.subjectAge = subjectAge
    def factory(*args_, **kwargs_):
        if visitInfo_t.subclass:
            return visitInfo_t.subclass(*args_, **kwargs_)
        else:
            return visitInfo_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_subjectAge(self): return self.subjectAge
    def set_subjectAge(self, subjectAge): self.subjectAge = subjectAge
    def export(self, outfile, level, namespace_='xcede2:', name_='visitInfo_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='visitInfo_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='visitInfo_t'):
        super(visitInfo_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='visitInfo_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='visitInfo_t', fromsubclass_=False):
        super(visitInfo_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimeStamp>%s</%stimeStamp>\n' % (namespace_, self.gds_format_string(quote_xml(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), namespace_))
        if self.subjectAge is not None:
            showIndent(outfile, level)
            outfile.write('<%ssubjectAge>%s</%ssubjectAge>\n' % (namespace_, self.gds_format_string(quote_xml(self.subjectAge).encode(ExternalEncoding), input_name='subjectAge'), namespace_))
    def hasContent_(self):
        if (
            self.timeStamp is not None or
            self.subjectAge is not None or
            super(visitInfo_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='visitInfo_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(visitInfo_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(visitInfo_t, self).exportLiteralChildren(outfile, level, name_)
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('timeStamp=%s,\n' % quote_python(self.timeStamp).encode(ExternalEncoding))
        if self.subjectAge is not None:
            showIndent(outfile, level)
            outfile.write('subjectAge=%s,\n' % quote_python(self.subjectAge).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(visitInfo_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timeStamp':
            timeStamp_ = child_.text
            timeStamp_ = self.gds_validate_string(timeStamp_, node, 'timeStamp')
            self.timeStamp = timeStamp_
        elif nodeName_ == 'subjectAge':
            subjectAge_ = child_.text
            subjectAge_ = self.gds_validate_string(subjectAge_, node, 'subjectAge')
            self.subjectAge = subjectAge_
        super(visitInfo_t, self).buildChildren(child_, node, nodeName_, True)
# end class visitInfo_t


class episodeInfo_t(abstract_info_t):
    subclass = None
    superclass = abstract_info_t
    def __init__(self, description=None, timeStamp=None):
        super(episodeInfo_t, self).__init__(description, )
        self.timeStamp = timeStamp
    def factory(*args_, **kwargs_):
        if episodeInfo_t.subclass:
            return episodeInfo_t.subclass(*args_, **kwargs_)
        else:
            return episodeInfo_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def export(self, outfile, level, namespace_='xcede2:', name_='episodeInfo_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='episodeInfo_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='episodeInfo_t'):
        super(episodeInfo_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='episodeInfo_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='episodeInfo_t', fromsubclass_=False):
        super(episodeInfo_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimeStamp>%s</%stimeStamp>\n' % (namespace_, self.gds_format_string(quote_xml(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), namespace_))
    def hasContent_(self):
        if (
            self.timeStamp is not None or
            super(episodeInfo_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='episodeInfo_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(episodeInfo_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(episodeInfo_t, self).exportLiteralChildren(outfile, level, name_)
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('timeStamp=%s,\n' % quote_python(self.timeStamp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(episodeInfo_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timeStamp':
            timeStamp_ = child_.text
            timeStamp_ = self.gds_validate_string(timeStamp_, node, 'timeStamp')
            self.timeStamp = timeStamp_
        super(episodeInfo_t, self).buildChildren(child_, node, nodeName_, True)
# end class episodeInfo_t


class acquisitionInfo_t(abstract_info_t):
    subclass = None
    superclass = abstract_info_t
    def __init__(self, description=None, timeStamp=None):
        super(acquisitionInfo_t, self).__init__(description, )
        self.timeStamp = timeStamp
    def factory(*args_, **kwargs_):
        if acquisitionInfo_t.subclass:
            return acquisitionInfo_t.subclass(*args_, **kwargs_)
        else:
            return acquisitionInfo_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def export(self, outfile, level, namespace_='xcede2:', name_='acquisitionInfo_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='acquisitionInfo_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='acquisitionInfo_t'):
        super(acquisitionInfo_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='acquisitionInfo_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='acquisitionInfo_t', fromsubclass_=False):
        super(acquisitionInfo_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimeStamp>%s</%stimeStamp>\n' % (namespace_, self.gds_format_string(quote_xml(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), namespace_))
    def hasContent_(self):
        if (
            self.timeStamp is not None or
            super(acquisitionInfo_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='acquisitionInfo_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(acquisitionInfo_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(acquisitionInfo_t, self).exportLiteralChildren(outfile, level, name_)
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('timeStamp=%s,\n' % quote_python(self.timeStamp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(acquisitionInfo_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timeStamp':
            timeStamp_ = child_.text
            timeStamp_ = self.gds_validate_string(timeStamp_, node, 'timeStamp')
            self.timeStamp = timeStamp_
        super(acquisitionInfo_t, self).buildChildren(child_, node, nodeName_, True)
# end class acquisitionInfo_t


class elementType(GeneratedsSuper):
    """This element describes the type of individual data elements in the
    data record. For numeric data types, this indicates whether the
    element type is a signed integer ("int"), unsigned integer
    ("uint"), or floating-point ("float"), as well as the number of
    bits allocated to each element."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if elementType.subclass:
            return elementType.subclass(*args_, **kwargs_)
        else:
            return elementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xcede2:', name_='elementType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='elementType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='elementType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='elementType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='elementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class elementType


class byteOrder(GeneratedsSuper):
    """This element describes whether the individual data elements in the
    data record are stored with the most-significant-byte first
    (msbfirst) or least-significant-byte first (lsbfirst). This
    element is required if the the data type given by the
    "elementtype" element has a size larger than one byte."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if byteOrder.subclass:
            return byteOrder.subclass(*args_, **kwargs_)
        else:
            return byteOrder(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xcede2:', name_='byteOrder', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='byteOrder')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='byteOrder'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='byteOrder', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='byteOrder'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class byteOrder


class binaryDataDimension_t(GeneratedsSuper):
    """This element stores information about one of the N dimensions in the
    data record. Multiple instances of this element are ordered from
    fastest-moving to slowest-moving. These elements provide
    information to describe the size (in data elements) of the
    N-dimensional bounding box for the data, and in some cases to
    describe the mapping of indexes within this bounding box to
    'real-world' coordinates.This is a label for the dimension. The
    first three spatial dimensions (or however many exist) must be
    labeled, in order, 'x', 'y', and 'z'. The first temporal
    dimension must be labeled 't'.If this attribute exists, this
    dimension is a "split" dimension, and this dimension must be
    "merged" with one or more other dimensions (with the same label)
    before presenting the data to the application. This is useful,
    for example, if the data is stored in Siemens' Mosaic DICOM
    format, where slices of a 3-D volume are arranged to look like
    they are tiled onto a square 2-D area. In this case, what would
    normally be called the 'z' dimension has two forks, one that
    occurs before the 'y' dimension (the first row in the data
    covers the first row of several slices), and one that occurs
    after the 'y' dimension. If, as in this case, there are two or
    more dimensions that should be merged into one, both component
    dimensions should have the label 'z', but have splitRank
    attributes "1" and "2", which specifies the order in which all
    'split' dimensions of the same label will be merged. After
    merging, the resultant 'z' dimension element should contain the
    same children of the highest-ranked split 'z' dimension, except
    for the 'size' element, which will be the product of the sizes
    of all 'z' split dimensions. The position of the resultant
    dimension should be the position of the highest-ranked 'z' split
    dimension. The data itself should also be reordered to reflect
    the new dimension structure.In the same way that the 'splitRank'
    attribute allows you to specify dimensions that should be merged
    before presenting the data to an application, this attribute
    specifies a data filter along this dimension. If this attribute
    exists, it should contain a whitespace-separated list of indices
    (indexed starting at 0). Only data points along this dimension
    that occur in the index list should be presented to the
    application. Likewise, the 'size' of the dimension, after
    selection, should be updated to reflect the new size of this
    dimension (which should be the number of indices in the content
    of this attribute)."""
    subclass = None
    superclass = None
    def __init__(self, splitRank=None, outputSelect=None, label=None, size=None, extensiontype_=None):
        self.splitRank = _cast(None, splitRank)
        self.outputSelect = _cast(None, outputSelect)
        self.label = _cast(None, label)
        self.size = size
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if binaryDataDimension_t.subclass:
            return binaryDataDimension_t.subclass(*args_, **kwargs_)
        else:
            return binaryDataDimension_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_splitRank(self): return self.splitRank
    def set_splitRank(self, splitRank): self.splitRank = splitRank
    def get_outputSelect(self): return self.outputSelect
    def set_outputSelect(self, outputSelect): self.outputSelect = outputSelect
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='binaryDataDimension_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='binaryDataDimension_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='binaryDataDimension_t'):
        if self.splitRank is not None and 'splitRank' not in already_processed:
            already_processed.append('splitRank')
            outfile.write(' splitRank=%s' % (self.gds_format_string(quote_attrib(self.splitRank).encode(ExternalEncoding), input_name='splitRank'), ))
        if self.outputSelect is not None and 'outputSelect' not in already_processed:
            already_processed.append('outputSelect')
            outfile.write(' outputSelect=%s' % (self.gds_format_string(quote_attrib(self.outputSelect).encode(ExternalEncoding), input_name='outputSelect'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='binaryDataDimension_t', fromsubclass_=False):
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('<%ssize>%s</%ssize>\n' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_))
    def hasContent_(self):
        if (
            self.size is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='binaryDataDimension_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.splitRank is not None and 'splitRank' not in already_processed:
            already_processed.append('splitRank')
            showIndent(outfile, level)
            outfile.write('splitRank = "%s",\n' % (self.splitRank,))
        if self.outputSelect is not None and 'outputSelect' not in already_processed:
            already_processed.append('outputSelect')
            showIndent(outfile, level)
            outfile.write('outputSelect = "%s",\n' % (self.outputSelect,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('splitRank', node)
        if value is not None and 'splitRank' not in already_processed:
            already_processed.append('splitRank')
            self.splitRank = value
        value = find_attr_value_('outputSelect', node)
        if value is not None and 'outputSelect' not in already_processed:
            already_processed.append('outputSelect')
            self.outputSelect = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
# end class binaryDataDimension_t


class mappedBinaryDataDimension_t(binaryDataDimension_t):
    subclass = None
    superclass = binaryDataDimension_t
    def __init__(self, splitRank=None, outputSelect=None, label=None, size=None, origin=None, spacing=None, gap=None, datapoints=None, direction=None, units=None, measurementFrame=None):
        super(mappedBinaryDataDimension_t, self).__init__(splitRank, outputSelect, label, size, )
        self.origin = origin
        self.spacing = spacing
        self.gap = gap
        self.datapoints = datapoints
        self.direction = direction
        self.units = units
        self.measurementFrame = measurementFrame
    def factory(*args_, **kwargs_):
        if mappedBinaryDataDimension_t.subclass:
            return mappedBinaryDataDimension_t.subclass(*args_, **kwargs_)
        else:
            return mappedBinaryDataDimension_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_origin(self): return self.origin
    def set_origin(self, origin): self.origin = origin
    def get_spacing(self): return self.spacing
    def set_spacing(self, spacing): self.spacing = spacing
    def get_gap(self): return self.gap
    def set_gap(self, gap): self.gap = gap
    def get_datapoints(self): return self.datapoints
    def set_datapoints(self, datapoints): self.datapoints = datapoints
    def get_direction(self): return self.direction
    def set_direction(self, direction): self.direction = direction
    def validate_listoffloats_t(self, value):
        # Validate type listoffloats_t, a restriction on xs:float.
        pass
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_measurementFrame(self): return self.measurementFrame
    def set_measurementFrame(self, measurementFrame): self.measurementFrame = measurementFrame
    def export(self, outfile, level, namespace_='xcede2:', name_='mappedBinaryDataDimension_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mappedBinaryDataDimension_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='mappedBinaryDataDimension_t'):
        super(mappedBinaryDataDimension_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='mappedBinaryDataDimension_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='mappedBinaryDataDimension_t', fromsubclass_=False):
        super(mappedBinaryDataDimension_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('<%sorigin>%s</%sorigin>\n' % (namespace_, self.gds_format_float(self.origin, input_name='origin'), namespace_))
        if self.spacing is not None:
            showIndent(outfile, level)
            outfile.write('<%sspacing>%s</%sspacing>\n' % (namespace_, self.gds_format_float(self.spacing, input_name='spacing'), namespace_))
        if self.gap is not None:
            showIndent(outfile, level)
            outfile.write('<%sgap>%s</%sgap>\n' % (namespace_, self.gds_format_float(self.gap, input_name='gap'), namespace_))
        if self.datapoints is not None:
            self.datapoints.export(outfile, level, namespace_, name_='datapoints')
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('<%sdirection>%s</%sdirection>\n' % (namespace_, self.gds_format_float_list(self.direction, input_name='direction'), namespace_))
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('<%sunits>%s</%sunits>\n' % (namespace_, self.gds_format_string(quote_xml(self.units).encode(ExternalEncoding), input_name='units'), namespace_))
        if self.measurementFrame is not None:
            self.measurementFrame.export(outfile, level, namespace_, name_='measurementFrame')
    def hasContent_(self):
        if (
            self.origin is not None or
            self.spacing is not None or
            self.gap is not None or
            self.datapoints is not None or
            self.direction is not None or
            self.units is not None or
            self.measurementFrame is not None or
            super(mappedBinaryDataDimension_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mappedBinaryDataDimension_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(mappedBinaryDataDimension_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(mappedBinaryDataDimension_t, self).exportLiteralChildren(outfile, level, name_)
        if self.origin is not None:
            showIndent(outfile, level)
            outfile.write('origin=%f,\n' % self.origin)
        if self.spacing is not None:
            showIndent(outfile, level)
            outfile.write('spacing=%f,\n' % self.spacing)
        if self.gap is not None:
            showIndent(outfile, level)
            outfile.write('gap=%f,\n' % self.gap)
        if self.datapoints is not None:
            showIndent(outfile, level)
            outfile.write('datapoints=model_.datapointsType(\n')
            self.datapoints.exportLiteral(outfile, level, name_='datapoints')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.direction is not None:
            showIndent(outfile, level)
            outfile.write('direction=%f,\n' % self.direction)
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('units=%s,\n' % quote_python(self.units).encode(ExternalEncoding))
        if self.measurementFrame is not None:
            showIndent(outfile, level)
            outfile.write('measurementFrame=model_.measurementFrameType(\n')
            self.measurementFrame.exportLiteral(outfile, level, name_='measurementFrame')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(mappedBinaryDataDimension_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'origin':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'origin')
            self.origin = fval_
        elif nodeName_ == 'spacing':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'spacing')
            self.spacing = fval_
        elif nodeName_ == 'gap':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'gap')
            self.gap = fval_
        elif nodeName_ == 'datapoints':
            obj_ = datapointsType.factory()
            obj_.build(child_)
            self.set_datapoints(obj_)
        elif nodeName_ == 'direction':
            direction_ = child_.text
            direction_ = self.gds_validate_float_list(direction_, node, 'direction')
            self.direction = direction_
            self.direction = self.direction.split()
            self.validate_listoffloats_t(self.direction)    # validate type listoffloats_t
        elif nodeName_ == 'units':
            units_ = child_.text
            units_ = self.gds_validate_string(units_, node, 'units')
            self.units = units_
        elif nodeName_ == 'measurementFrame':
            obj_ = measurementFrameType.factory()
            obj_.build(child_)
            self.set_measurementFrame(obj_)
        super(mappedBinaryDataDimension_t, self).buildChildren(child_, node, nodeName_, True)
# end class mappedBinaryDataDimension_t


class frag_uri_t(GeneratedsSuper):
    """The external data pointed to by this uri is a "fragment", where a
    "fragment" is defined as a stream of data contiguously stored in
    the same file offset by 'offset' bytes and of 'size' bytes.The
    data for this fragment will start at this byte position in the
    resource specified by the 'uri' element. If this attribute does
    not exist or is empty, it is assumed to be zero.This specifies
    the size of this block (in bytes) in the resource specified by
    the 'uri' element. If this attribute does not exist or is empty,
    it is calculated using the dimension and elementtype element."""
    subclass = None
    superclass = None
    def __init__(self, size=None, offset=None, valueOf_=None):
        self.size = _cast(int, size)
        self.offset = _cast(int, offset)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if frag_uri_t.subclass:
            return frag_uri_t.subclass(*args_, **kwargs_)
        else:
            return frag_uri_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_offset(self): return self.offset
    def set_offset(self, offset): self.offset = offset
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='frag_uri_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='frag_uri_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='frag_uri_t'):
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.append('offset')
            outfile.write(' offset="%s"' % self.gds_format_integer(self.offset, input_name='offset'))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='frag_uri_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='frag_uri_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.size is not None and 'size' not in already_processed:
            already_processed.append('size')
            showIndent(outfile, level)
            outfile.write('size = %d,\n' % (self.size,))
        if self.offset is not None and 'offset' not in already_processed:
            already_processed.append('offset')
            showIndent(outfile, level)
            outfile.write('offset = %d,\n' % (self.offset,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.append('size')
            try:
                self.size = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('offset', node)
        if value is not None and 'offset' not in already_processed:
            already_processed.append('offset')
            try:
                self.offset = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class frag_uri_t


class format_t(GeneratedsSuper):
    """Container for describing imaging formats and file name extensions
    (currently underimplemented)"""
    subclass = None
    superclass = None
    def __init__(self, name=None, description=None, documentationList=None, extensionList=None):
        self.name = _cast(None, name)
        self.description = description
        self.documentationList = documentationList
        self.extensionList = extensionList
    def factory(*args_, **kwargs_):
        if format_t.subclass:
            return format_t.subclass(*args_, **kwargs_)
        else:
            return format_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_documentationList(self): return self.documentationList
    def set_documentationList(self, documentationList): self.documentationList = documentationList
    def get_extensionList(self): return self.extensionList
    def set_extensionList(self, extensionList): self.extensionList = extensionList
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='xcede2:', name_='format_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='format_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='format_t'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='format_t', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.documentationList is not None:
            self.documentationList.export(outfile, level, namespace_, name_='documentationList')
        if self.extensionList is not None:
            self.extensionList.export(outfile, level, namespace_, name_='extensionList')
    def hasContent_(self):
        if (
            self.description is not None or
            self.documentationList is not None or
            self.extensionList is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='format_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.documentationList is not None:
            showIndent(outfile, level)
            outfile.write('documentationList=model_.documentationListType(\n')
            self.documentationList.exportLiteral(outfile, level, name_='documentationList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extensionList is not None:
            showIndent(outfile, level)
            outfile.write('extensionList=model_.extensionListType(\n')
            self.extensionList.exportLiteral(outfile, level, name_='extensionList')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'documentationList':
            obj_ = documentationListType.factory()
            obj_.build(child_)
            self.set_documentationList(obj_)
        elif nodeName_ == 'extensionList':
            obj_ = extensionListType.factory()
            obj_.build(child_)
            self.set_extensionList(obj_)
# end class format_t


class processStep_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, parent=None, program=None, programArguments=None, parameters=None, workingURI=None, timeStamp=None, user=None, hostName=None, architecture=None, platform=None, cvs=None, compiler=None, library=None, buildTimeStamp=None, package=None, repository=None):
        self.ID = _cast(None, ID)
        self.parent = _cast(None, parent)
        self.program = program
        self.programArguments = programArguments
        self.parameters = parameters
        self.workingURI = workingURI
        self.timeStamp = timeStamp
        self.user = user
        self.hostName = hostName
        self.architecture = architecture
        self.platform = platform
        self.cvs = cvs
        self.compiler = compiler
        if library is None:
            self.library = []
        else:
            self.library = library
        self.buildTimeStamp = buildTimeStamp
        self.package = package
        self.repository = repository
    def factory(*args_, **kwargs_):
        if processStep_t.subclass:
            return processStep_t.subclass(*args_, **kwargs_)
        else:
            return processStep_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_program(self): return self.program
    def set_program(self, program): self.program = program
    def get_programArguments(self): return self.programArguments
    def set_programArguments(self, programArguments): self.programArguments = programArguments
    def get_parameters(self): return self.parameters
    def set_parameters(self, parameters): self.parameters = parameters
    def get_workingURI(self): return self.workingURI
    def set_workingURI(self, workingURI): self.workingURI = workingURI
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def get_hostName(self): return self.hostName
    def set_hostName(self, hostName): self.hostName = hostName
    def get_architecture(self): return self.architecture
    def set_architecture(self, architecture): self.architecture = architecture
    def get_platform(self): return self.platform
    def set_platform(self, platform): self.platform = platform
    def get_cvs(self): return self.cvs
    def set_cvs(self, cvs): self.cvs = cvs
    def get_compiler(self): return self.compiler
    def set_compiler(self, compiler): self.compiler = compiler
    def get_library(self): return self.library
    def set_library(self, library): self.library = library
    def add_library(self, value): self.library.append(value)
    def insert_library(self, index, value): self.library[index] = value
    def get_buildTimeStamp(self): return self.buildTimeStamp
    def set_buildTimeStamp(self, buildTimeStamp): self.buildTimeStamp = buildTimeStamp
    def get_package(self): return self.package
    def set_package(self, package): self.package = package
    def get_repository(self): return self.repository
    def set_repository(self, repository): self.repository = repository
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_parent(self): return self.parent
    def set_parent(self, parent): self.parent = parent
    def export(self, outfile, level, namespace_='xcede2:', name_='processStep_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='processStep_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='processStep_t'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            outfile.write(' parent=%s' % (self.gds_format_string(quote_attrib(self.parent).encode(ExternalEncoding), input_name='parent'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='processStep_t', fromsubclass_=False):
        if self.program is not None:
            self.program.export(outfile, level, namespace_, name_='program')
        if self.programArguments is not None:
            self.programArguments.export(outfile, level, namespace_, name_='programArguments')
        if self.parameters is not None:
            self.parameters.export(outfile, level, namespace_, name_='parameters')
        if self.workingURI is not None:
            showIndent(outfile, level)
            outfile.write('<%sworkingURI>%s</%sworkingURI>\n' % (namespace_, self.gds_format_string(quote_xml(self.workingURI).encode(ExternalEncoding), input_name='workingURI'), namespace_))
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimeStamp>%s</%stimeStamp>\n' % (namespace_, self.gds_format_string(quote_xml(self.timeStamp).encode(ExternalEncoding), input_name='timeStamp'), namespace_))
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('<%suser>%s</%suser>\n' % (namespace_, self.gds_format_string(quote_xml(self.user).encode(ExternalEncoding), input_name='user'), namespace_))
        if self.hostName is not None:
            showIndent(outfile, level)
            outfile.write('<%shostName>%s</%shostName>\n' % (namespace_, self.gds_format_string(quote_xml(self.hostName).encode(ExternalEncoding), input_name='hostName'), namespace_))
        if self.architecture is not None:
            showIndent(outfile, level)
            outfile.write('<%sarchitecture>%s</%sarchitecture>\n' % (namespace_, self.gds_format_string(quote_xml(self.architecture).encode(ExternalEncoding), input_name='architecture'), namespace_))
        if self.platform is not None:
            self.platform.export(outfile, level, namespace_, name_='platform')
        if self.cvs is not None:
            showIndent(outfile, level)
            outfile.write('<%scvs>%s</%scvs>\n' % (namespace_, self.gds_format_string(quote_xml(self.cvs).encode(ExternalEncoding), input_name='cvs'), namespace_))
        if self.compiler is not None:
            self.compiler.export(outfile, level, namespace_, name_='compiler')
        for library_ in self.library:
            library_.export(outfile, level, namespace_, name_='library')
        if self.buildTimeStamp is not None:
            showIndent(outfile, level)
            outfile.write('<%sbuildTimeStamp>%s</%sbuildTimeStamp>\n' % (namespace_, self.gds_format_string(quote_xml(self.buildTimeStamp).encode(ExternalEncoding), input_name='buildTimeStamp'), namespace_))
        if self.package is not None:
            self.package.export(outfile, level, namespace_, name_='package')
        if self.repository is not None:
            showIndent(outfile, level)
            outfile.write('<%srepository>%s</%srepository>\n' % (namespace_, self.gds_format_string(quote_xml(self.repository).encode(ExternalEncoding), input_name='repository'), namespace_))
    def hasContent_(self):
        if (
            self.program is not None or
            self.programArguments is not None or
            self.parameters is not None or
            self.workingURI is not None or
            self.timeStamp is not None or
            self.user is not None or
            self.hostName is not None or
            self.architecture is not None or
            self.platform is not None or
            self.cvs is not None or
            self.compiler is not None or
            self.library or
            self.buildTimeStamp is not None or
            self.package is not None or
            self.repository is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='processStep_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            showIndent(outfile, level)
            outfile.write('parent = "%s",\n' % (self.parent,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.program is not None:
            showIndent(outfile, level)
            outfile.write('program=model_.versionedProgramEntity_t(\n')
            self.program.exportLiteral(outfile, level, name_='program')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.programArguments is not None:
            showIndent(outfile, level)
            outfile.write('programArguments=model_.argumentsType_t(\n')
            self.programArguments.exportLiteral(outfile, level, name_='programArguments')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.parameters is not None:
            showIndent(outfile, level)
            outfile.write('parameters=model_.namedParameterList_t(\n')
            self.parameters.exportLiteral(outfile, level, name_='parameters')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.workingURI is not None:
            showIndent(outfile, level)
            outfile.write('workingURI=%s,\n' % quote_python(self.workingURI).encode(ExternalEncoding))
        if self.timeStamp is not None:
            showIndent(outfile, level)
            outfile.write('timeStamp=%s,\n' % quote_python(self.timeStamp).encode(ExternalEncoding))
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user=%s,\n' % quote_python(self.user).encode(ExternalEncoding))
        if self.hostName is not None:
            showIndent(outfile, level)
            outfile.write('hostName=%s,\n' % quote_python(self.hostName).encode(ExternalEncoding))
        if self.architecture is not None:
            showIndent(outfile, level)
            outfile.write('architecture=%s,\n' % quote_python(self.architecture).encode(ExternalEncoding))
        if self.platform is not None:
            showIndent(outfile, level)
            outfile.write('platform=model_.versionedEntity_t(\n')
            self.platform.exportLiteral(outfile, level, name_='platform')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cvs is not None:
            showIndent(outfile, level)
            outfile.write('cvs=%s,\n' % quote_python(self.cvs).encode(ExternalEncoding))
        if self.compiler is not None:
            showIndent(outfile, level)
            outfile.write('compiler=model_.versionedEntity_t(\n')
            self.compiler.exportLiteral(outfile, level, name_='compiler')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('library=[\n')
        level += 1
        for library_ in self.library:
            showIndent(outfile, level)
            outfile.write('model_.versionedEntity_t(\n')
            library_.exportLiteral(outfile, level, name_='versionedEntity_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.buildTimeStamp is not None:
            showIndent(outfile, level)
            outfile.write('buildTimeStamp=%s,\n' % quote_python(self.buildTimeStamp).encode(ExternalEncoding))
        if self.package is not None:
            showIndent(outfile, level)
            outfile.write('package=model_.versionedEntity_t(\n')
            self.package.exportLiteral(outfile, level, name_='package')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.repository is not None:
            showIndent(outfile, level)
            outfile.write('repository=%s,\n' % quote_python(self.repository).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('parent', node)
        if value is not None and 'parent' not in already_processed:
            already_processed.append('parent')
            self.parent = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'program':
            obj_ = versionedProgramEntity_t.factory()
            obj_.build(child_)
            self.set_program(obj_)
        elif nodeName_ == 'programArguments':
            obj_ = argumentsType_t.factory()
            obj_.build(child_)
            self.set_programArguments(obj_)
        elif nodeName_ == 'parameters':
            obj_ = namedParameterList_t.factory()
            obj_.build(child_)
            self.set_parameters(obj_)
        elif nodeName_ == 'workingURI':
            workingURI_ = child_.text
            workingURI_ = self.gds_validate_string(workingURI_, node, 'workingURI')
            self.workingURI = workingURI_
        elif nodeName_ == 'timeStamp':
            timeStamp_ = child_.text
            timeStamp_ = self.gds_validate_string(timeStamp_, node, 'timeStamp')
            self.timeStamp = timeStamp_
        elif nodeName_ == 'user':
            user_ = child_.text
            user_ = self.gds_validate_string(user_, node, 'user')
            self.user = user_
        elif nodeName_ == 'hostName':
            hostName_ = child_.text
            hostName_ = self.gds_validate_string(hostName_, node, 'hostName')
            self.hostName = hostName_
        elif nodeName_ == 'architecture':
            architecture_ = child_.text
            architecture_ = self.gds_validate_string(architecture_, node, 'architecture')
            self.architecture = architecture_
        elif nodeName_ == 'platform':
            obj_ = versionedEntity_t.factory()
            obj_.build(child_)
            self.set_platform(obj_)
        elif nodeName_ == 'cvs':
            cvs_ = child_.text
            cvs_ = self.gds_validate_string(cvs_, node, 'cvs')
            self.cvs = cvs_
        elif nodeName_ == 'compiler':
            obj_ = versionedEntity_t.factory()
            obj_.build(child_)
            self.set_compiler(obj_)
        elif nodeName_ == 'library':
            obj_ = versionedEntity_t.factory()
            obj_.build(child_)
            self.library.append(obj_)
        elif nodeName_ == 'buildTimeStamp':
            buildTimeStamp_ = child_.text
            buildTimeStamp_ = self.gds_validate_string(buildTimeStamp_, node, 'buildTimeStamp')
            self.buildTimeStamp = buildTimeStamp_
        elif nodeName_ == 'package':
            obj_ = versionedEntity_t.factory()
            obj_.build(child_)
            self.set_package(obj_)
        elif nodeName_ == 'repository':
            repository_ = child_.text
            repository_ = self.gds_validate_string(repository_, node, 'repository')
            self.repository = repository_
# end class processStep_t


class provenance_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, processStep=None):
        self.ID = _cast(None, ID)
        if processStep is None:
            self.processStep = []
        else:
            self.processStep = processStep
    def factory(*args_, **kwargs_):
        if provenance_t.subclass:
            return provenance_t.subclass(*args_, **kwargs_)
        else:
            return provenance_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_processStep(self): return self.processStep
    def set_processStep(self, processStep): self.processStep = processStep
    def add_processStep(self, value): self.processStep.append(value)
    def insert_processStep(self, index, value): self.processStep[index] = value
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='xcede2:', name_='provenance_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='provenance_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='provenance_t'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='provenance_t', fromsubclass_=False):
        for processStep_ in self.processStep:
            processStep_.export(outfile, level, namespace_, name_='processStep')
    def hasContent_(self):
        if (
            self.processStep
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='provenance_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('processStep=[\n')
        level += 1
        for processStep_ in self.processStep:
            showIndent(outfile, level)
            outfile.write('model_.processStep_t(\n')
            processStep_.exportLiteral(outfile, level, name_='processStep_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'processStep':
            obj_ = processStep_t.factory()
            obj_.build(child_)
            self.processStep.append(obj_)
# end class provenance_t


class argumentsType_t(GeneratedsSuper):
    """input and output arguments of the processing tool"""
    subclass = None
    superclass = None
    def __init__(self, inputs=None, outputs=None, valueOf_=None):
        self.inputs = _cast(None, inputs)
        self.outputs = _cast(None, outputs)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if argumentsType_t.subclass:
            return argumentsType_t.subclass(*args_, **kwargs_)
        else:
            return argumentsType_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inputs(self): return self.inputs
    def set_inputs(self, inputs): self.inputs = inputs
    def get_outputs(self): return self.outputs
    def set_outputs(self, outputs): self.outputs = outputs
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='argumentsType_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='argumentsType_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='argumentsType_t'):
        if self.inputs is not None and 'inputs' not in already_processed:
            already_processed.append('inputs')
            outfile.write(' inputs=%s' % (self.gds_format_string(quote_attrib(self.inputs).encode(ExternalEncoding), input_name='inputs'), ))
        if self.outputs is not None and 'outputs' not in already_processed:
            already_processed.append('outputs')
            outfile.write(' outputs=%s' % (self.gds_format_string(quote_attrib(self.outputs).encode(ExternalEncoding), input_name='outputs'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='argumentsType_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='argumentsType_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.inputs is not None and 'inputs' not in already_processed:
            already_processed.append('inputs')
            showIndent(outfile, level)
            outfile.write('inputs = "%s",\n' % (self.inputs,))
        if self.outputs is not None and 'outputs' not in already_processed:
            already_processed.append('outputs')
            showIndent(outfile, level)
            outfile.write('outputs = "%s",\n' % (self.outputs,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inputs', node)
        if value is not None and 'inputs' not in already_processed:
            already_processed.append('inputs')
            self.inputs = value
        value = find_attr_value_('outputs', node)
        if value is not None and 'outputs' not in already_processed:
            already_processed.append('outputs')
            self.outputs = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class argumentsType_t


class namedParameterList_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, param=None):
        if param is None:
            self.param = []
        else:
            self.param = param
    def factory(*args_, **kwargs_):
        if namedParameterList_t.subclass:
            return namedParameterList_t.subclass(*args_, **kwargs_)
        else:
            return namedParameterList_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_param(self): return self.param
    def set_param(self, param): self.param = param
    def add_param(self, value): self.param.append(value)
    def insert_param(self, index, value): self.param[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='namedParameterList_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='namedParameterList_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='namedParameterList_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='namedParameterList_t', fromsubclass_=False):
        for param_ in self.param:
            param_.export(outfile, level, namespace_, name_='param')
    def hasContent_(self):
        if (
            self.param
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='namedParameterList_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('param=[\n')
        level += 1
        for param_ in self.param:
            showIndent(outfile, level)
            outfile.write('model_.namedParameter_t(\n')
            param_.exportLiteral(outfile, level, name_='namedParameter_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'param':
            obj_ = namedParameter_t.factory()
            obj_.build(child_)
            self.param.append(obj_)
# end class namedParameterList_t


class namedParameter_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ispath=False, type_=None, name=None, io=None, description=None, valueOf_=None):
        self.ispath = _cast(bool, ispath)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.io = _cast(None, io)
        self.description = _cast(None, description)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if namedParameter_t.subclass:
            return namedParameter_t.subclass(*args_, **kwargs_)
        else:
            return namedParameter_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ispath(self): return self.ispath
    def set_ispath(self, ispath): self.ispath = ispath
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_valueTypes_t(self, value):
        # Validate type valueTypes_t, a restriction on xs:string.
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_io(self): return self.io
    def set_io(self, io): self.io = io
    def validate_parameterIOType_t(self, value):
        # Validate type parameterIOType_t, a restriction on xs:string.
        pass
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='namedParameter_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='namedParameter_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='namedParameter_t'):
        if self.ispath is not None and 'ispath' not in already_processed:
            already_processed.append('ispath')
            outfile.write(' ispath="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.ispath)), input_name='ispath'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.io is not None and 'io' not in already_processed:
            already_processed.append('io')
            outfile.write(' io=%s' % (quote_attrib(self.io), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='namedParameter_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='namedParameter_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ispath is not None and 'ispath' not in already_processed:
            already_processed.append('ispath')
            showIndent(outfile, level)
            outfile.write('ispath = %s,\n' % (self.ispath,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.io is not None and 'io' not in already_processed:
            already_processed.append('io')
            showIndent(outfile, level)
            outfile.write('io = "%s",\n' % (self.io,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ispath', node)
        if value is not None and 'ispath' not in already_processed:
            already_processed.append('ispath')
            if value in ('true', '1'):
                self.ispath = True
            elif value in ('false', '0'):
                self.ispath = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.validate_valueTypes_t(self.type_)    # validate type valueTypes_t
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('io', node)
        if value is not None and 'io' not in already_processed:
            already_processed.append('io')
            self.io = value
            self.validate_parameterIOType_t(self.io)    # validate type parameterIOType_t
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class namedParameter_t


class versionedEntity_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, valueOf_=None):
        self.version = _cast(None, version)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if versionedEntity_t.subclass:
            return versionedEntity_t.subclass(*args_, **kwargs_)
        else:
            return versionedEntity_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='versionedEntity_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='versionedEntity_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='versionedEntity_t'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='versionedEntity_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='versionedEntity_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class versionedEntity_t


class versionedProgramEntity_t(GeneratedsSuper):
    """package, version and build type of the processing tool"""
    subclass = None
    superclass = None
    def __init__(self, version=None, build_=None, package=None, valueOf_=None):
        self.version = _cast(None, version)
        self.build_ = _cast(None, build_)
        self.package = _cast(None, package)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if versionedProgramEntity_t.subclass:
            return versionedProgramEntity_t.subclass(*args_, **kwargs_)
        else:
            return versionedProgramEntity_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_build(self): return self.build_
    def set_build(self, build_): self.build_ = build_
    def get_package(self): return self.package
    def set_package(self, package): self.package = package
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='versionedProgramEntity_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='versionedProgramEntity_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='versionedProgramEntity_t'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.append('build_')
            outfile.write(' build=%s' % (self.gds_format_string(quote_attrib(self.build_).encode(ExternalEncoding), input_name='build'), ))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            outfile.write(' package=%s' % (self.gds_format_string(quote_attrib(self.package).encode(ExternalEncoding), input_name='package'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='versionedProgramEntity_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='versionedProgramEntity_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.build_ is not None and 'build_' not in already_processed:
            already_processed.append('build_')
            showIndent(outfile, level)
            outfile.write('build_ = "%s",\n' % (self.build_,))
        if self.package is not None and 'package' not in already_processed:
            already_processed.append('package')
            showIndent(outfile, level)
            outfile.write('package = "%s",\n' % (self.package,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('build', node)
        if value is not None and 'build' not in already_processed:
            already_processed.append('build')
            self.build_ = value
        value = find_attr_value_('package', node)
        if value is not None and 'package' not in already_processed:
            already_processed.append('package')
            self.package = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class versionedProgramEntity_t


class event_t(GeneratedsSuper):
    """This element represents an interval of time, with arbitrary metadata
    (in the value element).This attribute is optional, but an group
    using this schema should agree on, use, and enforce measurement
    units consistently, to avoid the need for unit conversion in an
    application."""
    subclass = None
    superclass = None
    def __init__(self, units=None, type_=None, name=None, onset=None, duration=None, value=None, annotation=None):
        self.units = _cast(None, units)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.onset = onset
        self.duration = duration
        if value is None:
            self.value = []
        else:
            self.value = value
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
    def factory(*args_, **kwargs_):
        if event_t.subclass:
            return event_t.subclass(*args_, **kwargs_)
        else:
            return event_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_onset(self): return self.onset
    def set_onset(self, onset): self.onset = onset
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def add_annotation(self, value): self.annotation.append(value)
    def insert_annotation(self, index, value): self.annotation[index] = value
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='xcede2:', name_='event_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='event_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='event_t'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='event_t', fromsubclass_=False):
        if self.onset is not None:
            showIndent(outfile, level)
            outfile.write('<%sonset>%s</%sonset>\n' % (namespace_, self.gds_format_float(self.onset, input_name='onset'), namespace_))
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('<%sduration>%s</%sduration>\n' % (namespace_, self.gds_format_float(self.duration, input_name='duration'), namespace_))
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value')
        for annotation_ in self.annotation:
            annotation_.export(outfile, level, namespace_, name_='annotation')
    def hasContent_(self):
        if (
            self.onset is not None or
            self.duration is not None or
            self.value or
            self.annotation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='event_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.onset is not None:
            showIndent(outfile, level)
            outfile.write('onset=%f,\n' % self.onset)
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=%f,\n' % self.duration)
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.eventValue_t(\n')
            value_.exportLiteral(outfile, level, name_='eventValue_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('annotation=[\n')
        level += 1
        for annotation_ in self.annotation:
            showIndent(outfile, level)
            outfile.write('model_.textAnnotation_t(\n')
            annotation_.exportLiteral(outfile, level, name_='textAnnotation_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'onset':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'onset')
            self.onset = fval_
        elif nodeName_ == 'duration':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'duration')
            self.duration = fval_
        elif nodeName_ == 'value':
            obj_ = eventValue_t.factory()
            obj_.build(child_)
            self.value.append(obj_)
        elif nodeName_ == 'annotation':
            obj_ = textAnnotation_t.factory()
            obj_.build(child_)
            self.annotation.append(obj_)
# end class event_t


class eventValue_t(GeneratedsSuper):
    """User-specified metadata associated with an event."""
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if eventValue_t.subclass:
            return eventValue_t.subclass(*args_, **kwargs_)
        else:
            return eventValue_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='eventValue_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventValue_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='eventValue_t'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='eventValue_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='eventValue_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class eventValue_t


class eventParams_t(GeneratedsSuper):
    """These value elements apply to all events in the parent event list."""
    subclass = None
    superclass = None
    def __init__(self, value=None):
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if eventParams_t.subclass:
            return eventParams_t.subclass(*args_, **kwargs_)
        else:
            return eventParams_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='eventParams_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='eventParams_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='eventParams_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='eventParams_t', fromsubclass_=False):
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value')
    def hasContent_(self):
        if (
            self.value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='eventParams_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.eventValue_t(\n')
            value_.exportLiteral(outfile, level, name_='eventValue_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            obj_ = eventValue_t.factory()
            obj_.build(child_)
            self.value.append(obj_)
# end class eventParams_t


class abstract_tagged_entity_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, metaFields=None, extensiontype_=None):
        self.metaFields = metaFields
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstract_tagged_entity_t.subclass:
            return abstract_tagged_entity_t.subclass(*args_, **kwargs_)
        else:
            return abstract_tagged_entity_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metaFields(self): return self.metaFields
    def set_metaFields(self, metaFields): self.metaFields = metaFields
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_tagged_entity_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_tagged_entity_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_tagged_entity_t'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_tagged_entity_t', fromsubclass_=False):
        if self.metaFields is not None:
            self.metaFields.export(outfile, level, namespace_, name_='metaFields')
    def hasContent_(self):
        if (
            self.metaFields is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_tagged_entity_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.metaFields is not None:
            showIndent(outfile, level)
            outfile.write('metaFields=model_.metaFieldsType(\n')
            self.metaFields.exportLiteral(outfile, level, name_='metaFields')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metaFields':
            obj_ = metaFieldsType.factory()
            obj_.build(child_)
            self.set_metaFields(obj_)
# end class abstract_tagged_entity_t


class protocolItem_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, required=None, name=None, ID=None, itemText=None, itemRange=None, itemChoice=None, extensiontype_=None):
        self.required = _cast(bool, required)
        self.name = _cast(None, name)
        self.ID = _cast(None, ID)
        self.itemText = itemText
        if itemRange is None:
            self.itemRange = []
        else:
            self.itemRange = itemRange
        if itemChoice is None:
            self.itemChoice = []
        else:
            self.itemChoice = itemChoice
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if protocolItem_t.subclass:
            return protocolItem_t.subclass(*args_, **kwargs_)
        else:
            return protocolItem_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_itemText(self): return self.itemText
    def set_itemText(self, itemText): self.itemText = itemText
    def get_itemRange(self): return self.itemRange
    def set_itemRange(self, itemRange): self.itemRange = itemRange
    def add_itemRange(self, value): self.itemRange.append(value)
    def insert_itemRange(self, index, value): self.itemRange[index] = value
    def get_itemChoice(self): return self.itemChoice
    def set_itemChoice(self, itemChoice): self.itemChoice = itemChoice
    def add_itemChoice(self, value): self.itemChoice.append(value)
    def insert_itemChoice(self, index, value): self.itemChoice[index] = value
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='protocolItem_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='protocolItem_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='protocolItem_t'):
        if self.required is not None and 'required' not in already_processed:
            already_processed.append('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.required)), input_name='required'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='protocolItem_t', fromsubclass_=False):
        if self.itemText is not None:
            self.itemText.export(outfile, level, namespace_, name_='itemText')
        for itemRange_ in self.itemRange:
            itemRange_.export(outfile, level, namespace_, name_='itemRange')
        for itemChoice_ in self.itemChoice:
            itemChoice_.export(outfile, level, namespace_, name_='itemChoice')
    def hasContent_(self):
        if (
            self.itemText is not None or
            self.itemRange or
            self.itemChoice
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='protocolItem_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.append('required')
            showIndent(outfile, level)
            outfile.write('required = %s,\n' % (self.required,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.itemText is not None:
            showIndent(outfile, level)
            outfile.write('itemText=model_.itemTextType(\n')
            self.itemText.exportLiteral(outfile, level, name_='itemText')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('itemRange=[\n')
        level += 1
        for itemRange_ in self.itemRange:
            showIndent(outfile, level)
            outfile.write('model_.protocolItemRange_t(\n')
            itemRange_.exportLiteral(outfile, level, name_='protocolItemRange_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('itemChoice=[\n')
        level += 1
        for itemChoice_ in self.itemChoice:
            showIndent(outfile, level)
            outfile.write('model_.itemChoiceType(\n')
            itemChoice_.exportLiteral(outfile, level, name_='itemChoiceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.append('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'itemText':
            obj_ = itemTextType.factory()
            obj_.build(child_)
            self.set_itemText(obj_)
        elif nodeName_ == 'itemRange':
            obj_ = protocolItemRange_t.factory()
            obj_.build(child_)
            self.itemRange.append(obj_)
        elif nodeName_ == 'itemChoice':
            obj_ = itemChoiceType.factory()
            obj_.build(child_)
            self.itemChoice.append(obj_)
# end class protocolItem_t


class protocolOffset_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, protocolTimeRef=None, preferredTimeOffset=None, minTimeOffset=None, maxTimeOffset=None):
        self.protocolTimeRef = protocolTimeRef
        self.preferredTimeOffset = preferredTimeOffset
        self.minTimeOffset = minTimeOffset
        self.maxTimeOffset = maxTimeOffset
    def factory(*args_, **kwargs_):
        if protocolOffset_t.subclass:
            return protocolOffset_t.subclass(*args_, **kwargs_)
        else:
            return protocolOffset_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocolTimeRef(self): return self.protocolTimeRef
    def set_protocolTimeRef(self, protocolTimeRef): self.protocolTimeRef = protocolTimeRef
    def get_preferredTimeOffset(self): return self.preferredTimeOffset
    def set_preferredTimeOffset(self, preferredTimeOffset): self.preferredTimeOffset = preferredTimeOffset
    def get_minTimeOffset(self): return self.minTimeOffset
    def set_minTimeOffset(self, minTimeOffset): self.minTimeOffset = minTimeOffset
    def get_maxTimeOffset(self): return self.maxTimeOffset
    def set_maxTimeOffset(self, maxTimeOffset): self.maxTimeOffset = maxTimeOffset
    def export(self, outfile, level, namespace_='xcede2:', name_='protocolOffset_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='protocolOffset_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='protocolOffset_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='protocolOffset_t', fromsubclass_=False):
        if self.protocolTimeRef is not None:
            showIndent(outfile, level)
            outfile.write('<%sprotocolTimeRef>%s</%sprotocolTimeRef>\n' % (namespace_, self.gds_format_string(quote_xml(self.protocolTimeRef).encode(ExternalEncoding), input_name='protocolTimeRef'), namespace_))
        if self.preferredTimeOffset is not None:
            self.preferredTimeOffset.export(outfile, level, namespace_, name_='preferredTimeOffset')
        if self.minTimeOffset is not None:
            self.minTimeOffset.export(outfile, level, namespace_, name_='minTimeOffset')
        if self.maxTimeOffset is not None:
            self.maxTimeOffset.export(outfile, level, namespace_, name_='maxTimeOffset')
    def hasContent_(self):
        if (
            self.protocolTimeRef is not None or
            self.preferredTimeOffset is not None or
            self.minTimeOffset is not None or
            self.maxTimeOffset is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='protocolOffset_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.protocolTimeRef is not None:
            showIndent(outfile, level)
            outfile.write('protocolTimeRef=%s,\n' % quote_python(self.protocolTimeRef).encode(ExternalEncoding))
        if self.preferredTimeOffset is not None:
            showIndent(outfile, level)
            outfile.write('preferredTimeOffset=model_.unitString_t(\n')
            self.preferredTimeOffset.exportLiteral(outfile, level, name_='preferredTimeOffset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.minTimeOffset is not None:
            showIndent(outfile, level)
            outfile.write('minTimeOffset=model_.unitString_t(\n')
            self.minTimeOffset.exportLiteral(outfile, level, name_='minTimeOffset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.maxTimeOffset is not None:
            showIndent(outfile, level)
            outfile.write('maxTimeOffset=model_.unitString_t(\n')
            self.maxTimeOffset.exportLiteral(outfile, level, name_='maxTimeOffset')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocolTimeRef':
            protocolTimeRef_ = child_.text
            protocolTimeRef_ = self.gds_validate_string(protocolTimeRef_, node, 'protocolTimeRef')
            self.protocolTimeRef = protocolTimeRef_
        elif nodeName_ == 'preferredTimeOffset':
            obj_ = unitString_t.factory()
            obj_.build(child_)
            self.set_preferredTimeOffset(obj_)
        elif nodeName_ == 'minTimeOffset':
            obj_ = unitString_t.factory()
            obj_.build(child_)
            self.set_minTimeOffset(obj_)
        elif nodeName_ == 'maxTimeOffset':
            obj_ = unitString_t.factory()
            obj_.build(child_)
            self.set_maxTimeOffset(obj_)
# end class protocolOffset_t


class protocolItemChoice_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, value=None):
        self.units = _cast(None, units)
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if protocolItemChoice_t.subclass:
            return protocolItemChoice_t.subclass(*args_, **kwargs_)
        else:
            return protocolItemChoice_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def export(self, outfile, level, namespace_='xcede2:', name_='protocolItemChoice_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='protocolItemChoice_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='protocolItemChoice_t'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='protocolItemChoice_t', fromsubclass_=False):
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.gds_format_string(quote_xml(value_).encode(ExternalEncoding), input_name='value'), namespace_))
    def hasContent_(self):
        if (
            self.value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='protocolItemChoice_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value.append(value_)
# end class protocolItemChoice_t


class protocolItemRange_t(GeneratedsSuper):
    """Minimum value for item (inclusive)Maximum value for item (inclusive)"""
    subclass = None
    superclass = None
    def __init__(self, units=None, max=None, min=None):
        self.units = _cast(None, units)
        self.max = _cast(None, max)
        self.min = _cast(None, min)
        pass
    def factory(*args_, **kwargs_):
        if protocolItemRange_t.subclass:
            return protocolItemRange_t.subclass(*args_, **kwargs_)
        else:
            return protocolItemRange_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def get_min(self): return self.min
    def set_min(self, min): self.min = min
    def export(self, outfile, level, namespace_='xcede2:', name_='protocolItemRange_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='protocolItemRange_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='protocolItemRange_t'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
        if self.max is not None and 'max' not in already_processed:
            already_processed.append('max')
            outfile.write(' max=%s' % (self.gds_format_string(quote_attrib(self.max).encode(ExternalEncoding), input_name='max'), ))
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            outfile.write(' min=%s' % (self.gds_format_string(quote_attrib(self.min).encode(ExternalEncoding), input_name='min'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='protocolItemRange_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='protocolItemRange_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
        if self.max is not None and 'max' not in already_processed:
            already_processed.append('max')
            showIndent(outfile, level)
            outfile.write('max = "%s",\n' % (self.max,))
        if self.min is not None and 'min' not in already_processed:
            already_processed.append('min')
            showIndent(outfile, level)
            outfile.write('min = "%s",\n' % (self.min,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.append('max')
            self.max = value
        value = find_attr_value_('min', node)
        if value is not None and 'min' not in already_processed:
            already_processed.append('min')
            self.min = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class protocolItemRange_t


class assessmentInfo_t(abstract_info_t):
    subclass = None
    superclass = abstract_info_t
    def __init__(self, description=None):
        super(assessmentInfo_t, self).__init__(description, )
        pass
    def factory(*args_, **kwargs_):
        if assessmentInfo_t.subclass:
            return assessmentInfo_t.subclass(*args_, **kwargs_)
        else:
            return assessmentInfo_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xcede2:', name_='assessmentInfo_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='assessmentInfo_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='assessmentInfo_t'):
        super(assessmentInfo_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='assessmentInfo_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='assessmentInfo_t', fromsubclass_=False):
        super(assessmentInfo_t, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(assessmentInfo_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='assessmentInfo_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(assessmentInfo_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(assessmentInfo_t, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(assessmentInfo_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(assessmentInfo_t, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class assessmentInfo_t


class assessmentDescItem_t(protocolItem_t):
    subclass = None
    superclass = protocolItem_t
    def __init__(self, required=None, name=None, ID=None, itemText=None, itemRange=None, itemChoice=None, formRef=None, version=None):
        super(assessmentDescItem_t, self).__init__(required, name, ID, itemText, itemRange, itemChoice, )
        self.formRef = _cast(None, formRef)
        self.version = _cast(None, version)
        pass
    def factory(*args_, **kwargs_):
        if assessmentDescItem_t.subclass:
            return assessmentDescItem_t.subclass(*args_, **kwargs_)
        else:
            return assessmentDescItem_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_formRef(self): return self.formRef
    def set_formRef(self, formRef): self.formRef = formRef
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def export(self, outfile, level, namespace_='xcede2:', name_='assessmentDescItem_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='assessmentDescItem_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='assessmentDescItem_t'):
        super(assessmentDescItem_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='assessmentDescItem_t')
        if self.formRef is not None and 'formRef' not in already_processed:
            already_processed.append('formRef')
            outfile.write(' formRef=%s' % (self.gds_format_string(quote_attrib(self.formRef).encode(ExternalEncoding), input_name='formRef'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='assessmentDescItem_t', fromsubclass_=False):
        super(assessmentDescItem_t, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(assessmentDescItem_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='assessmentDescItem_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.formRef is not None and 'formRef' not in already_processed:
            already_processed.append('formRef')
            showIndent(outfile, level)
            outfile.write('formRef = "%s",\n' % (self.formRef,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        super(assessmentDescItem_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(assessmentDescItem_t, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('formRef', node)
        if value is not None and 'formRef' not in already_processed:
            already_processed.append('formRef')
            self.formRef = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        super(assessmentDescItem_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(assessmentDescItem_t, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class assessmentDescItem_t


class assessmentItem_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, termPath=None, name=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, ID=None, valueStatus=None, value=None, normValue=None, reconciliationNote=None, annotation=None):
        self.termPath = _cast(None, termPath)
        self.name = _cast(None, name)
        self.nomenclature = _cast(None, nomenclature)
        self.abbreviation = _cast(None, abbreviation)
        self.preferredLabel = _cast(None, preferredLabel)
        self.termID = _cast(None, termID)
        self.ID = _cast(None, ID)
        self.valueStatus = valueStatus
        self.value = value
        self.normValue = normValue
        self.reconciliationNote = reconciliationNote
        self.annotation = annotation
    def factory(*args_, **kwargs_):
        if assessmentItem_t.subclass:
            return assessmentItem_t.subclass(*args_, **kwargs_)
        else:
            return assessmentItem_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueStatus(self): return self.valueStatus
    def set_valueStatus(self, valueStatus): self.valueStatus = valueStatus
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_normValue(self): return self.normValue
    def set_normValue(self, normValue): self.normValue = normValue
    def get_reconciliationNote(self): return self.reconciliationNote
    def set_reconciliationNote(self, reconciliationNote): self.reconciliationNote = reconciliationNote
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_termPath(self): return self.termPath
    def set_termPath(self, termPath): self.termPath = termPath
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_nomenclature(self): return self.nomenclature
    def set_nomenclature(self, nomenclature): self.nomenclature = nomenclature
    def get_abbreviation(self): return self.abbreviation
    def set_abbreviation(self, abbreviation): self.abbreviation = abbreviation
    def get_preferredLabel(self): return self.preferredLabel
    def set_preferredLabel(self, preferredLabel): self.preferredLabel = preferredLabel
    def get_termID(self): return self.termID
    def set_termID(self, termID): self.termID = termID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='xcede2:', name_='assessmentItem_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='assessmentItem_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='assessmentItem_t'):
        if self.termPath is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            outfile.write(' termPath=%s' % (self.gds_format_string(quote_attrib(self.termPath).encode(ExternalEncoding), input_name='termPath'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            outfile.write(' nomenclature=%s' % (self.gds_format_string(quote_attrib(self.nomenclature).encode(ExternalEncoding), input_name='nomenclature'), ))
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            outfile.write(' abbreviation=%s' % (self.gds_format_string(quote_attrib(self.abbreviation).encode(ExternalEncoding), input_name='abbreviation'), ))
        if self.preferredLabel is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            outfile.write(' preferredLabel=%s' % (self.gds_format_string(quote_attrib(self.preferredLabel).encode(ExternalEncoding), input_name='preferredLabel'), ))
        if self.termID is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            outfile.write(' termID=%s' % (self.gds_format_string(quote_attrib(self.termID).encode(ExternalEncoding), input_name='termID'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='assessmentItem_t', fromsubclass_=False):
        if self.valueStatus is not None:
            showIndent(outfile, level)
            outfile.write('<%svalueStatus>%s</%svalueStatus>\n' % (namespace_, self.gds_format_string(quote_xml(self.valueStatus).encode(ExternalEncoding), input_name='valueStatus'), namespace_))
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', )
        if self.normValue is not None:
            self.normValue.export(outfile, level, namespace_, name_='normValue')
        if self.reconciliationNote is not None:
            self.reconciliationNote.export(outfile, level, namespace_, name_='reconciliationNote')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
    def hasContent_(self):
        if (
            self.valueStatus is not None or
            self.value is not None or
            self.normValue is not None or
            self.reconciliationNote is not None or
            self.annotation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='assessmentItem_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.termPath is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            showIndent(outfile, level)
            outfile.write('termPath = "%s",\n' % (self.termPath,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            showIndent(outfile, level)
            outfile.write('nomenclature = "%s",\n' % (self.nomenclature,))
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            showIndent(outfile, level)
            outfile.write('abbreviation = "%s",\n' % (self.abbreviation,))
        if self.preferredLabel is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            showIndent(outfile, level)
            outfile.write('preferredLabel = "%s",\n' % (self.preferredLabel,))
        if self.termID is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            showIndent(outfile, level)
            outfile.write('termID = "%s",\n' % (self.termID,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.valueStatus is not None:
            showIndent(outfile, level)
            outfile.write('valueStatus=%s,\n' % quote_python(self.valueStatus).encode(ExternalEncoding))
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.value_t(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.normValue is not None:
            showIndent(outfile, level)
            outfile.write('normValue=model_.value_t(\n')
            self.normValue.exportLiteral(outfile, level, name_='normValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reconciliationNote is not None:
            showIndent(outfile, level)
            outfile.write('reconciliationNote=model_.textAnnotation_t(\n')
            self.reconciliationNote.exportLiteral(outfile, level, name_='reconciliationNote')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.textAnnotation_t(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('termPath', node)
        if value is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            self.termPath = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('nomenclature', node)
        if value is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            self.nomenclature = value
        value = find_attr_value_('abbreviation', node)
        if value is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            self.abbreviation = value
        value = find_attr_value_('preferredLabel', node)
        if value is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            self.preferredLabel = value
        value = find_attr_value_('termID', node)
        if value is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            self.termID = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'valueStatus':
            valueStatus_ = child_.text
            valueStatus_ = self.gds_validate_string(valueStatus_, node, 'valueStatus')
            self.valueStatus = valueStatus_
        elif nodeName_ == 'value':
            obj_ = value_t.factory()
            obj_.build(child_)
            self.set_value(obj_)
        elif nodeName_ == 'normValue':
            obj_ = value_t.factory()
            obj_.build(child_)
            self.set_normValue(obj_)
        elif nodeName_ == 'reconciliationNote':
            obj_ = textAnnotation_t.factory()
            obj_.build(child_)
            self.set_reconciliationNote(obj_)
        elif nodeName_ == 'annotation':
            obj_ = textAnnotation_t.factory()
            obj_.build(child_)
            self.set_annotation(obj_)
# end class assessmentItem_t


class terminologyString_t(GeneratedsSuper):
    """A simple representation of terms for use within the schema."""
    subclass = None
    superclass = None
    def __init__(self, abbreviation=None, preferredLabel=None, termID=None, termPath=None, nomenclature=None, valueOf_=None):
        self.abbreviation = _cast(None, abbreviation)
        self.preferredLabel = _cast(None, preferredLabel)
        self.termID = _cast(None, termID)
        self.termPath = _cast(None, termPath)
        self.nomenclature = _cast(None, nomenclature)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if terminologyString_t.subclass:
            return terminologyString_t.subclass(*args_, **kwargs_)
        else:
            return terminologyString_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_abbreviation(self): return self.abbreviation
    def set_abbreviation(self, abbreviation): self.abbreviation = abbreviation
    def get_preferredLabel(self): return self.preferredLabel
    def set_preferredLabel(self, preferredLabel): self.preferredLabel = preferredLabel
    def get_termID(self): return self.termID
    def set_termID(self, termID): self.termID = termID
    def get_termPath(self): return self.termPath
    def set_termPath(self, termPath): self.termPath = termPath
    def get_nomenclature(self): return self.nomenclature
    def set_nomenclature(self, nomenclature): self.nomenclature = nomenclature
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='terminologyString_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='terminologyString_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='terminologyString_t'):
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            outfile.write(' abbreviation=%s' % (self.gds_format_string(quote_attrib(self.abbreviation).encode(ExternalEncoding), input_name='abbreviation'), ))
        if self.preferredLabel is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            outfile.write(' preferredLabel=%s' % (self.gds_format_string(quote_attrib(self.preferredLabel).encode(ExternalEncoding), input_name='preferredLabel'), ))
        if self.termID is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            outfile.write(' termID=%s' % (self.gds_format_string(quote_attrib(self.termID).encode(ExternalEncoding), input_name='termID'), ))
        if self.termPath is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            outfile.write(' termPath=%s' % (self.gds_format_string(quote_attrib(self.termPath).encode(ExternalEncoding), input_name='termPath'), ))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            outfile.write(' nomenclature=%s' % (self.gds_format_string(quote_attrib(self.nomenclature).encode(ExternalEncoding), input_name='nomenclature'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='terminologyString_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='terminologyString_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            showIndent(outfile, level)
            outfile.write('abbreviation = "%s",\n' % (self.abbreviation,))
        if self.preferredLabel is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            showIndent(outfile, level)
            outfile.write('preferredLabel = "%s",\n' % (self.preferredLabel,))
        if self.termID is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            showIndent(outfile, level)
            outfile.write('termID = "%s",\n' % (self.termID,))
        if self.termPath is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            showIndent(outfile, level)
            outfile.write('termPath = "%s",\n' % (self.termPath,))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            showIndent(outfile, level)
            outfile.write('nomenclature = "%s",\n' % (self.nomenclature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('abbreviation', node)
        if value is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            self.abbreviation = value
        value = find_attr_value_('preferredLabel', node)
        if value is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            self.preferredLabel = value
        value = find_attr_value_('termID', node)
        if value is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            self.termID = value
        value = find_attr_value_('termPath', node)
        if value is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            self.termPath = value
        value = find_attr_value_('nomenclature', node)
        if value is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            self.nomenclature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class terminologyString_t


class nomenclature_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, abbreviation=None, nomenclature=None, valueOf_=None):
        self.abbreviation = _cast(None, abbreviation)
        self.nomenclature = _cast(None, nomenclature)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nomenclature_t.subclass:
            return nomenclature_t.subclass(*args_, **kwargs_)
        else:
            return nomenclature_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_abbreviation(self): return self.abbreviation
    def set_abbreviation(self, abbreviation): self.abbreviation = abbreviation
    def get_nomenclature(self): return self.nomenclature
    def set_nomenclature(self, nomenclature): self.nomenclature = nomenclature
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='nomenclature_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nomenclature_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='nomenclature_t'):
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            outfile.write(' abbreviation=%s' % (self.gds_format_string(quote_attrib(self.abbreviation).encode(ExternalEncoding), input_name='abbreviation'), ))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            outfile.write(' nomenclature=%s' % (self.gds_format_string(quote_attrib(self.nomenclature).encode(ExternalEncoding), input_name='nomenclature'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='nomenclature_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nomenclature_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            showIndent(outfile, level)
            outfile.write('abbreviation = "%s",\n' % (self.abbreviation,))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            showIndent(outfile, level)
            outfile.write('nomenclature = "%s",\n' % (self.nomenclature,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('abbreviation', node)
        if value is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            self.abbreviation = value
        value = find_attr_value_('nomenclature', node)
        if value is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            self.nomenclature = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nomenclature_t


class atlasEntity_t(abstract_entity_t):
    """entity elements are used to describe the resultant scope of an
    analysis"""
    subclass = None
    superclass = abstract_entity_t
    def __init__(self, preferredEntityLabel=None, ID=None, description=None, geometry=None):
        super(atlasEntity_t, self).__init__(preferredEntityLabel, ID, description, )
        self.geometry = geometry
    def factory(*args_, **kwargs_):
        if atlasEntity_t.subclass:
            return atlasEntity_t.subclass(*args_, **kwargs_)
        else:
            return atlasEntity_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_geometry(self): return self.geometry
    def set_geometry(self, geometry): self.geometry = geometry
    def export(self, outfile, level, namespace_='xcede2:', name_='atlasEntity_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='atlasEntity_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='atlasEntity_t'):
        super(atlasEntity_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='atlasEntity_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='atlasEntity_t', fromsubclass_=False):
        super(atlasEntity_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.geometry is not None:
            self.geometry.export(outfile, level, namespace_, name_='geometry')
    def hasContent_(self):
        if (
            self.geometry is not None or
            super(atlasEntity_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='atlasEntity_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(atlasEntity_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(atlasEntity_t, self).exportLiteralChildren(outfile, level, name_)
        if self.abstract_geometry_t is not None:
            showIndent(outfile, level)
            outfile.write('abstract_geometry_t=model_.abstract_geometry_t(\n')
            self.abstract_geometry_t.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(atlasEntity_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'geometry':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <geometry> element')
            self.set_geometry(obj_)
        super(atlasEntity_t, self).buildChildren(child_, node, nodeName_, True)
# end class atlasEntity_t


class abstract_geometry_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if abstract_geometry_t.subclass:
            return abstract_geometry_t.subclass(*args_, **kwargs_)
        else:
            return abstract_geometry_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_geometry_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_geometry_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_geometry_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_geometry_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_geometry_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class abstract_geometry_t


class anatomicalEntity_t(abstract_entity_t):
    """Entity elements are used to describe the resultant scope of an
    analysisLaterality of region (or none) Tissue type of region (or
    none)"""
    subclass = None
    superclass = abstract_entity_t
    def __init__(self, preferredEntityLabel=None, ID=None, description=None, laterality=None, tissueType=None, label=None):
        super(anatomicalEntity_t, self).__init__(preferredEntityLabel, ID, description, )
        self.laterality = _cast(None, laterality)
        self.tissueType = _cast(None, tissueType)
        if label is None:
            self.label = []
        else:
            self.label = label
    def factory(*args_, **kwargs_):
        if anatomicalEntity_t.subclass:
            return anatomicalEntity_t.subclass(*args_, **kwargs_)
        else:
            return anatomicalEntity_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def add_label(self, value): self.label.append(value)
    def insert_label(self, index, value): self.label[index] = value
    def get_laterality(self): return self.laterality
    def set_laterality(self, laterality): self.laterality = laterality
    def validate_laterality_t(self, value):
        # Validate type laterality_t, a restriction on xs:string.
        pass
    def get_tissueType(self): return self.tissueType
    def set_tissueType(self, tissueType): self.tissueType = tissueType
    def validate_tissueType_t(self, value):
        # Validate type tissueType_t, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='xcede2:', name_='anatomicalEntity_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='anatomicalEntity_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='anatomicalEntity_t'):
        super(anatomicalEntity_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='anatomicalEntity_t')
        if self.laterality is not None and 'laterality' not in already_processed:
            already_processed.append('laterality')
            outfile.write(' laterality=%s' % (quote_attrib(self.laterality), ))
        if self.tissueType is not None and 'tissueType' not in already_processed:
            already_processed.append('tissueType')
            outfile.write(' tissueType=%s' % (quote_attrib(self.tissueType), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='anatomicalEntity_t', fromsubclass_=False):
        super(anatomicalEntity_t, self).exportChildren(outfile, level, namespace_, name_, True)
        for label_ in self.label:
            label_.export(outfile, level, namespace_, name_='label')
    def hasContent_(self):
        if (
            self.label or
            super(anatomicalEntity_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='anatomicalEntity_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.laterality is not None and 'laterality' not in already_processed:
            already_processed.append('laterality')
            showIndent(outfile, level)
            outfile.write('laterality = "%s",\n' % (self.laterality,))
        if self.tissueType is not None and 'tissueType' not in already_processed:
            already_processed.append('tissueType')
            showIndent(outfile, level)
            outfile.write('tissueType = "%s",\n' % (self.tissueType,))
        super(anatomicalEntity_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(anatomicalEntity_t, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('label=[\n')
        level += 1
        for label_ in self.label:
            showIndent(outfile, level)
            outfile.write('model_.terminologyString_t(\n')
            label_.exportLiteral(outfile, level, name_='terminologyString_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('laterality', node)
        if value is not None and 'laterality' not in already_processed:
            already_processed.append('laterality')
            self.laterality = value
            self.validate_laterality_t(self.laterality)    # validate type laterality_t
        value = find_attr_value_('tissueType', node)
        if value is not None and 'tissueType' not in already_processed:
            already_processed.append('tissueType')
            self.tissueType = value
            self.validate_tissueType_t(self.tissueType)    # validate type tissueType_t
        super(anatomicalEntity_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'label':
            obj_ = terminologyString_t.factory()
            obj_.build(child_)
            self.label.append(obj_)
        super(anatomicalEntity_t, self).buildChildren(child_, node, nodeName_, True)
# end class anatomicalEntity_t


class nameValue_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if nameValue_t.subclass:
            return nameValue_t.subclass(*args_, **kwargs_)
        else:
            return nameValue_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='nameValue_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nameValue_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='nameValue_t'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='nameValue_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nameValue_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nameValue_t


class metadataList_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if metadataList_t.subclass:
            return metadataList_t.subclass(*args_, **kwargs_)
        else:
            return metadataList_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='metadataList_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metadataList_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='metadataList_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='metadataList_t', fromsubclass_=False):
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value')
    def hasContent_(self):
        if (
            self.value
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metadataList_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.nameValue_t(\n')
            value_.exportLiteral(outfile, level, name_='nameValue_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            obj_ = nameValue_t.factory()
            obj_.build(child_)
            self.value.append(obj_)
# end class metadataList_t


class ref_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, URI=None, valueOf_=None):
        self.ID = _cast(None, ID)
        self.URI = _cast(None, URI)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ref_t.subclass:
            return ref_t.subclass(*args_, **kwargs_)
        else:
            return ref_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='ref_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ref_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='ref_t'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.append('URI')
            outfile.write(' URI=%s' % (self.gds_format_string(quote_attrib(self.URI).encode(ExternalEncoding), input_name='URI'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='ref_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ref_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.append('URI')
            showIndent(outfile, level)
            outfile.write('URI = "%s",\n' % (self.URI,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.append('URI')
            self.URI = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ref_t


class authoredText_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, author=None, valueOf_=None):
        self.timestamp = _cast(None, timestamp)
        self.author = _cast(None, author)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if authoredText_t.subclass:
            return authoredText_t.subclass(*args_, **kwargs_)
        else:
            return authoredText_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_author(self): return self.author
    def set_author(self, author): self.author = author
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='authoredText_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='authoredText_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='authoredText_t'):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            outfile.write(' timestamp=%s' % (self.gds_format_string(quote_attrib(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), ))
        if self.author is not None and 'author' not in already_processed:
            already_processed.append('author')
            outfile.write(' author=%s' % (self.gds_format_string(quote_attrib(self.author).encode(ExternalEncoding), input_name='author'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='authoredText_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='authoredText_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            showIndent(outfile, level)
            outfile.write('timestamp = "%s",\n' % (self.timestamp,))
        if self.author is not None and 'author' not in already_processed:
            already_processed.append('author')
            showIndent(outfile, level)
            outfile.write('author = "%s",\n' % (self.author,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            self.timestamp = value
        value = find_attr_value_('author', node)
        if value is not None and 'author' not in already_processed:
            already_processed.append('author')
            self.author = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class authoredText_t


class abstract_annotation_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, author=None, extensiontype_=None):
        self.timestamp = _cast(None, timestamp)
        self.author = _cast(None, author)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstract_annotation_t.subclass:
            return abstract_annotation_t.subclass(*args_, **kwargs_)
        else:
            return abstract_annotation_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_author(self): return self.author
    def set_author(self, author): self.author = author
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_annotation_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_annotation_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_annotation_t'):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            outfile.write(' timestamp=%s' % (self.gds_format_string(quote_attrib(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), ))
        if self.author is not None and 'author' not in already_processed:
            already_processed.append('author')
            outfile.write(' author=%s' % (self.gds_format_string(quote_attrib(self.author).encode(ExternalEncoding), input_name='author'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_annotation_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_annotation_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            showIndent(outfile, level)
            outfile.write('timestamp = "%s",\n' % (self.timestamp,))
        if self.author is not None and 'author' not in already_processed:
            already_processed.append('author')
            showIndent(outfile, level)
            outfile.write('author = "%s",\n' % (self.author,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.append('timestamp')
            self.timestamp = value
        value = find_attr_value_('author', node)
        if value is not None and 'author' not in already_processed:
            already_processed.append('author')
            self.author = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class abstract_annotation_t


class textAnnotation_t(abstract_annotation_t):
    subclass = None
    superclass = abstract_annotation_t
    def __init__(self, timestamp=None, author=None, comment=None):
        super(textAnnotation_t, self).__init__(timestamp, author, )
        self.comment = comment
    def factory(*args_, **kwargs_):
        if textAnnotation_t.subclass:
            return textAnnotation_t.subclass(*args_, **kwargs_)
        else:
            return textAnnotation_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def validate_comment_t(self, value):
        # Validate type comment_t, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='xcede2:', name_='textAnnotation_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='textAnnotation_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='textAnnotation_t'):
        super(textAnnotation_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='textAnnotation_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='textAnnotation_t', fromsubclass_=False):
        super(textAnnotation_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.gds_format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.comment is not None or
            super(textAnnotation_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='textAnnotation_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(textAnnotation_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(textAnnotation_t, self).exportLiteralChildren(outfile, level, name_)
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(textAnnotation_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            comment_ = child_.text
            comment_ = self.gds_validate_string(comment_, node, 'comment')
            self.comment = comment_
            self.validate_comment_t(self.comment)    # validate type comment_t
        super(textAnnotation_t, self).buildChildren(child_, node, nodeName_, True)
# end class textAnnotation_t


class generator_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, application=None, invocation=None, dataSource=None):
        self.application = application
        self.invocation = invocation
        self.dataSource = dataSource
    def factory(*args_, **kwargs_):
        if generator_t.subclass:
            return generator_t.subclass(*args_, **kwargs_)
        else:
            return generator_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_application(self): return self.application
    def set_application(self, application): self.application = application
    def get_invocation(self): return self.invocation
    def set_invocation(self, invocation): self.invocation = invocation
    def get_dataSource(self): return self.dataSource
    def set_dataSource(self, dataSource): self.dataSource = dataSource
    def export(self, outfile, level, namespace_='xcede2:', name_='generator_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='generator_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='generator_t'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='generator_t', fromsubclass_=False):
        if self.application is not None:
            self.application.export(outfile, level, namespace_, name_='application', )
        if self.invocation is not None:
            showIndent(outfile, level)
            outfile.write('<%sinvocation>%s</%sinvocation>\n' % (namespace_, self.gds_format_string(quote_xml(self.invocation).encode(ExternalEncoding), input_name='invocation'), namespace_))
        if self.dataSource is not None:
            showIndent(outfile, level)
            outfile.write('<%sdataSource>%s</%sdataSource>\n' % (namespace_, self.gds_format_string(quote_xml(self.dataSource).encode(ExternalEncoding), input_name='dataSource'), namespace_))
    def hasContent_(self):
        if (
            self.application is not None or
            self.invocation is not None or
            self.dataSource is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='generator_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.application is not None:
            showIndent(outfile, level)
            outfile.write('application=model_.versionedEntity_t(\n')
            self.application.exportLiteral(outfile, level, name_='application')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.invocation is not None:
            showIndent(outfile, level)
            outfile.write('invocation=%s,\n' % quote_python(self.invocation).encode(ExternalEncoding))
        if self.dataSource is not None:
            showIndent(outfile, level)
            outfile.write('dataSource=%s,\n' % quote_python(self.dataSource).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'application':
            obj_ = versionedEntity_t.factory()
            obj_.build(child_)
            self.set_application(obj_)
        elif nodeName_ == 'invocation':
            invocation_ = child_.text
            invocation_ = self.gds_validate_string(invocation_, node, 'invocation')
            self.invocation = invocation_
        elif nodeName_ == 'dataSource':
            dataSource_ = child_.text
            dataSource_ = self.gds_validate_string(dataSource_, node, 'dataSource')
            self.dataSource = dataSource_
# end class generator_t


class person_t(GeneratedsSuper):
    """Add additional fields (address, email, etc)"""
    subclass = None
    superclass = None
    def __init__(self, role=None, ID=None, salutation=None, givenName=None, middleName=None, surname=None, academicTitles=None, institution=None, department=None):
        self.role = _cast(None, role)
        self.ID = _cast(None, ID)
        self.salutation = salutation
        self.givenName = givenName
        self.middleName = middleName
        self.surname = surname
        self.academicTitles = academicTitles
        self.institution = institution
        self.department = department
    def factory(*args_, **kwargs_):
        if person_t.subclass:
            return person_t.subclass(*args_, **kwargs_)
        else:
            return person_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_salutation(self): return self.salutation
    def set_salutation(self, salutation): self.salutation = salutation
    def get_givenName(self): return self.givenName
    def set_givenName(self, givenName): self.givenName = givenName
    def get_middleName(self): return self.middleName
    def set_middleName(self, middleName): self.middleName = middleName
    def get_surname(self): return self.surname
    def set_surname(self, surname): self.surname = surname
    def get_academicTitles(self): return self.academicTitles
    def set_academicTitles(self, academicTitles): self.academicTitles = academicTitles
    def get_institution(self): return self.institution
    def set_institution(self, institution): self.institution = institution
    def get_department(self): return self.department
    def set_department(self, department): self.department = department
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='xcede2:', name_='person_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='person_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='person_t'):
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            outfile.write(' role=%s' % (self.gds_format_string(quote_attrib(self.role).encode(ExternalEncoding), input_name='role'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='person_t', fromsubclass_=False):
        if self.salutation is not None:
            showIndent(outfile, level)
            outfile.write('<%ssalutation>%s</%ssalutation>\n' % (namespace_, self.gds_format_string(quote_xml(self.salutation).encode(ExternalEncoding), input_name='salutation'), namespace_))
        if self.givenName is not None:
            showIndent(outfile, level)
            outfile.write('<%sgivenName>%s</%sgivenName>\n' % (namespace_, self.gds_format_string(quote_xml(self.givenName).encode(ExternalEncoding), input_name='givenName'), namespace_))
        if self.middleName is not None:
            showIndent(outfile, level)
            outfile.write('<%smiddleName>%s</%smiddleName>\n' % (namespace_, self.gds_format_string(quote_xml(self.middleName).encode(ExternalEncoding), input_name='middleName'), namespace_))
        if self.surname is not None:
            showIndent(outfile, level)
            outfile.write('<%ssurname>%s</%ssurname>\n' % (namespace_, self.gds_format_string(quote_xml(self.surname).encode(ExternalEncoding), input_name='surname'), namespace_))
        if self.academicTitles is not None:
            showIndent(outfile, level)
            outfile.write('<%sacademicTitles>%s</%sacademicTitles>\n' % (namespace_, self.gds_format_string(quote_xml(self.academicTitles).encode(ExternalEncoding), input_name='academicTitles'), namespace_))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('<%sinstitution>%s</%sinstitution>\n' % (namespace_, self.gds_format_string(quote_xml(self.institution).encode(ExternalEncoding), input_name='institution'), namespace_))
        if self.department is not None:
            showIndent(outfile, level)
            outfile.write('<%sdepartment>%s</%sdepartment>\n' % (namespace_, self.gds_format_string(quote_xml(self.department).encode(ExternalEncoding), input_name='department'), namespace_))
    def hasContent_(self):
        if (
            self.salutation is not None or
            self.givenName is not None or
            self.middleName is not None or
            self.surname is not None or
            self.academicTitles is not None or
            self.institution is not None or
            self.department is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='person_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.role is not None and 'role' not in already_processed:
            already_processed.append('role')
            showIndent(outfile, level)
            outfile.write('role = "%s",\n' % (self.role,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.salutation is not None:
            showIndent(outfile, level)
            outfile.write('salutation=%s,\n' % quote_python(self.salutation).encode(ExternalEncoding))
        if self.givenName is not None:
            showIndent(outfile, level)
            outfile.write('givenName=%s,\n' % quote_python(self.givenName).encode(ExternalEncoding))
        if self.middleName is not None:
            showIndent(outfile, level)
            outfile.write('middleName=%s,\n' % quote_python(self.middleName).encode(ExternalEncoding))
        if self.surname is not None:
            showIndent(outfile, level)
            outfile.write('surname=%s,\n' % quote_python(self.surname).encode(ExternalEncoding))
        if self.academicTitles is not None:
            showIndent(outfile, level)
            outfile.write('academicTitles=%s,\n' % quote_python(self.academicTitles).encode(ExternalEncoding))
        if self.institution is not None:
            showIndent(outfile, level)
            outfile.write('institution=%s,\n' % quote_python(self.institution).encode(ExternalEncoding))
        if self.department is not None:
            showIndent(outfile, level)
            outfile.write('department=%s,\n' % quote_python(self.department).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('role', node)
        if value is not None and 'role' not in already_processed:
            already_processed.append('role')
            self.role = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'salutation':
            salutation_ = child_.text
            salutation_ = self.gds_validate_string(salutation_, node, 'salutation')
            self.salutation = salutation_
        elif nodeName_ == 'givenName':
            givenName_ = child_.text
            givenName_ = self.gds_validate_string(givenName_, node, 'givenName')
            self.givenName = givenName_
        elif nodeName_ == 'middleName':
            middleName_ = child_.text
            middleName_ = self.gds_validate_string(middleName_, node, 'middleName')
            self.middleName = middleName_
        elif nodeName_ == 'surname':
            surname_ = child_.text
            surname_ = self.gds_validate_string(surname_, node, 'surname')
            self.surname = surname_
        elif nodeName_ == 'academicTitles':
            academicTitles_ = child_.text
            academicTitles_ = self.gds_validate_string(academicTitles_, node, 'academicTitles')
            self.academicTitles = academicTitles_
        elif nodeName_ == 'institution':
            institution_ = child_.text
            institution_ = self.gds_validate_string(institution_, node, 'institution')
            self.institution = institution_
        elif nodeName_ == 'department':
            department_ = child_.text
            department_ = self.gds_validate_string(department_, node, 'department')
            self.department = department_
# end class person_t


class unitString_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None):
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if unitString_t.subclass:
            return unitString_t.subclass(*args_, **kwargs_)
        else:
            return unitString_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='unitString_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='unitString_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='unitString_t'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='unitString_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='unitString_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class unitString_t


class revision_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ID=None, timestamp=None, generator=None, annotation=None):
        self.ID = _cast(None, ID)
        self.timestamp = timestamp
        self.generator = generator
        self.annotation = annotation
    def factory(*args_, **kwargs_):
        if revision_t.subclass:
            return revision_t.subclass(*args_, **kwargs_)
        else:
            return revision_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='xcede2:', name_='revision_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='revision_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='revision_t'):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='revision_t', fromsubclass_=False):
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimestamp>%s</%stimestamp>\n' % (namespace_, self.gds_format_string(quote_xml(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), namespace_))
        if self.generator is not None:
            self.generator.export(outfile, level, namespace_, name_='generator')
        if self.annotation is not None:
            self.annotation.export(outfile, level, namespace_, name_='annotation')
    def hasContent_(self):
        if (
            self.timestamp is not None or
            self.generator is not None or
            self.annotation is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='revision_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp=%s,\n' % quote_python(self.timestamp).encode(ExternalEncoding))
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('generator=model_.generator_t(\n')
            self.generator.exportLiteral(outfile, level, name_='generator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotation is not None:
            showIndent(outfile, level)
            outfile.write('annotation=model_.textAnnotation_t(\n')
            self.annotation.exportLiteral(outfile, level, name_='annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timestamp':
            timestamp_ = child_.text
            timestamp_ = self.gds_validate_string(timestamp_, node, 'timestamp')
            self.timestamp = timestamp_
        elif nodeName_ == 'generator':
            obj_ = generator_t.factory()
            obj_.build(child_)
            self.set_generator(obj_)
        elif nodeName_ == 'annotation':
            obj_ = textAnnotation_t.factory()
            obj_.build(child_)
            self.set_annotation(obj_)
# end class revision_t


class orderedString_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, order=None, valueOf_=None):
        self.order = _cast(None, order)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if orderedString_t.subclass:
            return orderedString_t.subclass(*args_, **kwargs_)
        else:
            return orderedString_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_order(self): return self.order
    def set_order(self, order): self.order = order
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='orderedString_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='orderedString_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='orderedString_t'):
        if self.order is not None and 'order' not in already_processed:
            already_processed.append('order')
            outfile.write(' order=%s' % (self.gds_format_string(quote_attrib(self.order).encode(ExternalEncoding), input_name='order'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='orderedString_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='orderedString_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.order is not None and 'order' not in already_processed:
            already_processed.append('order')
            showIndent(outfile, level)
            outfile.write('order = "%s",\n' % (self.order,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.append('order')
            self.order = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class orderedString_t


class value_t(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=None):
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if value_t.subclass:
            return value_t.subclass(*args_, **kwargs_)
        else:
            return value_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='value_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='value_t')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='value_t'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='value_t', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='value_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class value_t


class Entity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, label=None, type_=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.label = label
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Entity.subclass:
            return Entity.subclass(*args_, **kwargs_)
        else:
            return Entity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='Entity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Entity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='Entity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='Entity', fromsubclass_=False):
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('<%slabel>%s</%slabel>\n' % (namespace_, self.gds_format_string(quote_xml(self.label).encode(ExternalEncoding), input_name='label'), namespace_))
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.label is not None or
            self.type_ or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Entity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label=%s,\n' % quote_python(self.label).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'label':
            label_ = child_.text
            label_ = self.gds_validate_string(label_, node, 'label')
            self.label = label_
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'Entity')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class Entity


class Activity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, startTime=None, endTime=None, label=None, type_=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.startTime = startTime
        self.endTime = endTime
        self.label = label
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Activity.subclass:
            return Activity.subclass(*args_, **kwargs_)
        else:
            return Activity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_endTime(self): return self.endTime
    def set_endTime(self, endTime): self.endTime = endTime
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='Activity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Activity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='Activity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='Activity', fromsubclass_=False):
        if self.startTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sstartTime>%s</%sstartTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.startTime).encode(ExternalEncoding), input_name='startTime'), namespace_))
        if self.endTime is not None:
            showIndent(outfile, level)
            outfile.write('<%sendTime>%s</%sendTime>\n' % (namespace_, self.gds_format_string(quote_xml(self.endTime).encode(ExternalEncoding), input_name='endTime'), namespace_))
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('<%slabel>%s</%slabel>\n' % (namespace_, self.gds_format_string(quote_xml(self.label).encode(ExternalEncoding), input_name='label'), namespace_))
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.startTime is not None or
            self.endTime is not None or
            self.label is not None or
            self.type_ or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Activity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.startTime is not None:
            showIndent(outfile, level)
            outfile.write('startTime=%s,\n' % quote_python(self.startTime).encode(ExternalEncoding))
        if self.endTime is not None:
            showIndent(outfile, level)
            outfile.write('endTime=%s,\n' % quote_python(self.endTime).encode(ExternalEncoding))
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label=%s,\n' % quote_python(self.label).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startTime':
            startTime_ = child_.text
            startTime_ = self.gds_validate_string(startTime_, node, 'startTime')
            self.startTime = startTime_
        elif nodeName_ == 'endTime':
            endTime_ = child_.text
            endTime_ = self.gds_validate_string(endTime_, node, 'endTime')
            self.endTime = endTime_
        elif nodeName_ == 'label':
            label_ = child_.text
            label_ = self.gds_validate_string(label_, node, 'label')
            self.label = label_
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'Activity')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class Activity


class Used(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, time=None, activity=None, entity=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.time = time
        self.activity = activity
        self.entity = entity
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Used.subclass:
            return Used.subclass(*args_, **kwargs_)
        else:
            return Used(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_activity(self): return self.activity
    def set_activity(self, activity): self.activity = activity
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='Used', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Used')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='Used'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='Used', fromsubclass_=False):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('<%stime>%s</%stime>\n' % (namespace_, self.gds_format_string(quote_xml(self.time).encode(ExternalEncoding), input_name='time'), namespace_))
        if self.activity is not None:
            self.activity.export(outfile, level, namespace_, name_='activity', )
        if self.entity is not None:
            self.entity.export(outfile, level, namespace_, name_='entity', )
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.time is not None or
            self.activity is not None or
            self.entity is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Used'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('time=%s,\n' % quote_python(self.time).encode(ExternalEncoding))
        if self.activity is not None:
            showIndent(outfile, level)
            outfile.write('activity=model_.ActivityRef(\n')
            self.activity.exportLiteral(outfile, level, name_='activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.entity is not None:
            showIndent(outfile, level)
            outfile.write('entity=model_.EntityRef(\n')
            self.entity.exportLiteral(outfile, level, name_='entity')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'time':
            time_ = child_.text
            time_ = self.gds_validate_string(time_, node, 'time')
            self.time = time_
        elif nodeName_ == 'activity':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_activity(obj_)
        elif nodeName_ == 'entity':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_entity(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'Used')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class Used


class WasGeneratedBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, time=None, entity=None, activity=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.time = time
        self.entity = entity
        self.activity = activity
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasGeneratedBy.subclass:
            return WasGeneratedBy.subclass(*args_, **kwargs_)
        else:
            return WasGeneratedBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_activity(self): return self.activity
    def set_activity(self, activity): self.activity = activity
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasGeneratedBy', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasGeneratedBy')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasGeneratedBy'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasGeneratedBy', fromsubclass_=False):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('<%stime>%s</%stime>\n' % (namespace_, self.gds_format_string(quote_xml(self.time).encode(ExternalEncoding), input_name='time'), namespace_))
        if self.entity is not None:
            self.entity.export(outfile, level, namespace_, name_='entity', )
        if self.activity is not None:
            self.activity.export(outfile, level, namespace_, name_='activity')
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.time is not None or
            self.entity is not None or
            self.activity is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasGeneratedBy'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('time=%s,\n' % quote_python(self.time).encode(ExternalEncoding))
        if self.entity is not None:
            showIndent(outfile, level)
            outfile.write('entity=model_.EntityRef(\n')
            self.entity.exportLiteral(outfile, level, name_='entity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.activity is not None:
            showIndent(outfile, level)
            outfile.write('activity=model_.ActivityRef(\n')
            self.activity.exportLiteral(outfile, level, name_='activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'time':
            time_ = child_.text
            time_ = self.gds_validate_string(time_, node, 'time')
            self.time = time_
        elif nodeName_ == 'entity':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_entity(obj_)
        elif nodeName_ == 'activity':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_activity(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasGeneratedBy')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasGeneratedBy


class WasStartedBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, time=None, activity=None, trigger=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.time = time
        self.activity = activity
        self.trigger = trigger
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasStartedBy.subclass:
            return WasStartedBy.subclass(*args_, **kwargs_)
        else:
            return WasStartedBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_activity(self): return self.activity
    def set_activity(self, activity): self.activity = activity
    def get_trigger(self): return self.trigger
    def set_trigger(self, trigger): self.trigger = trigger
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasStartedBy', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasStartedBy')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasStartedBy'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasStartedBy', fromsubclass_=False):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('<%stime>%s</%stime>\n' % (namespace_, self.gds_format_string(quote_xml(self.time).encode(ExternalEncoding), input_name='time'), namespace_))
        if self.activity is not None:
            self.activity.export(outfile, level, namespace_, name_='activity', )
        if self.trigger is not None:
            self.trigger.export(outfile, level, namespace_, name_='trigger')
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.time is not None or
            self.activity is not None or
            self.trigger is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasStartedBy'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('time=%s,\n' % quote_python(self.time).encode(ExternalEncoding))
        if self.activity is not None:
            showIndent(outfile, level)
            outfile.write('activity=model_.ActivityRef(\n')
            self.activity.exportLiteral(outfile, level, name_='activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.trigger is not None:
            showIndent(outfile, level)
            outfile.write('trigger=model_.EntityRef(\n')
            self.trigger.exportLiteral(outfile, level, name_='trigger')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'time':
            time_ = child_.text
            time_ = self.gds_validate_string(time_, node, 'time')
            self.time = time_
        elif nodeName_ == 'activity':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_activity(obj_)
        elif nodeName_ == 'trigger':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_trigger(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasStartedBy')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasStartedBy


class WasEndedBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, time=None, activity=None, trigger=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.time = time
        self.activity = activity
        self.trigger = trigger
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasEndedBy.subclass:
            return WasEndedBy.subclass(*args_, **kwargs_)
        else:
            return WasEndedBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_activity(self): return self.activity
    def set_activity(self, activity): self.activity = activity
    def get_trigger(self): return self.trigger
    def set_trigger(self, trigger): self.trigger = trigger
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasEndedBy', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasEndedBy')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasEndedBy'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasEndedBy', fromsubclass_=False):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('<%stime>%s</%stime>\n' % (namespace_, self.gds_format_string(quote_xml(self.time).encode(ExternalEncoding), input_name='time'), namespace_))
        if self.activity is not None:
            self.activity.export(outfile, level, namespace_, name_='activity', )
        if self.trigger is not None:
            self.trigger.export(outfile, level, namespace_, name_='trigger')
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.time is not None or
            self.activity is not None or
            self.trigger is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasEndedBy'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('time=%s,\n' % quote_python(self.time).encode(ExternalEncoding))
        if self.activity is not None:
            showIndent(outfile, level)
            outfile.write('activity=model_.ActivityRef(\n')
            self.activity.exportLiteral(outfile, level, name_='activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.trigger is not None:
            showIndent(outfile, level)
            outfile.write('trigger=model_.EntityRef(\n')
            self.trigger.exportLiteral(outfile, level, name_='trigger')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'time':
            time_ = child_.text
            time_ = self.gds_validate_string(time_, node, 'time')
            self.time = time_
        elif nodeName_ == 'activity':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_activity(obj_)
        elif nodeName_ == 'trigger':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_trigger(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasEndedBy')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasEndedBy


class WasInformedBy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, time=None, effect=None, cause=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.time = time
        self.effect = effect
        self.cause = cause
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasInformedBy.subclass:
            return WasInformedBy.subclass(*args_, **kwargs_)
        else:
            return WasInformedBy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def get_effect(self): return self.effect
    def set_effect(self, effect): self.effect = effect
    def get_cause(self): return self.cause
    def set_cause(self, cause): self.cause = cause
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasInformedBy', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasInformedBy')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasInformedBy'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasInformedBy', fromsubclass_=False):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('<%stime>%s</%stime>\n' % (namespace_, self.gds_format_string(quote_xml(self.time).encode(ExternalEncoding), input_name='time'), namespace_))
        if self.effect is not None:
            self.effect.export(outfile, level, namespace_, name_='effect', )
        if self.cause is not None:
            self.cause.export(outfile, level, namespace_, name_='cause', )
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.time is not None or
            self.effect is not None or
            self.cause is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasInformedBy'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.time is not None:
            showIndent(outfile, level)
            outfile.write('time=%s,\n' % quote_python(self.time).encode(ExternalEncoding))
        if self.effect is not None:
            showIndent(outfile, level)
            outfile.write('effect=model_.ActivityRef(\n')
            self.effect.exportLiteral(outfile, level, name_='effect')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cause is not None:
            showIndent(outfile, level)
            outfile.write('cause=model_.ActivityRef(\n')
            self.cause.exportLiteral(outfile, level, name_='cause')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'time':
            time_ = child_.text
            time_ = self.gds_validate_string(time_, node, 'time')
            self.time = time_
        elif nodeName_ == 'effect':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_effect(obj_)
        elif nodeName_ == 'cause':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_cause(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasInformedBy')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasInformedBy


class WasStartedByActivity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, started=None, starter=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.started = started
        self.starter = starter
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasStartedByActivity.subclass:
            return WasStartedByActivity.subclass(*args_, **kwargs_)
        else:
            return WasStartedByActivity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_started(self): return self.started
    def set_started(self, started): self.started = started
    def get_starter(self): return self.starter
    def set_starter(self, starter): self.starter = starter
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasStartedByActivity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasStartedByActivity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasStartedByActivity'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasStartedByActivity', fromsubclass_=False):
        if self.started is not None:
            self.started.export(outfile, level, namespace_, name_='started', )
        if self.starter is not None:
            self.starter.export(outfile, level, namespace_, name_='starter', )
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.started is not None or
            self.starter is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasStartedByActivity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.started is not None:
            showIndent(outfile, level)
            outfile.write('started=model_.ActivityRef(\n')
            self.started.exportLiteral(outfile, level, name_='started')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.starter is not None:
            showIndent(outfile, level)
            outfile.write('starter=model_.ActivityRef(\n')
            self.starter.exportLiteral(outfile, level, name_='starter')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'started':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_started(obj_)
        elif nodeName_ == 'starter':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_starter(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasStartedByActivity')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasStartedByActivity


class Agent(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, label=None, type_=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.label = label
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Agent.subclass:
            return Agent.subclass(*args_, **kwargs_)
        else:
            return Agent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='Agent', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Agent')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='Agent'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='Agent', fromsubclass_=False):
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('<%slabel>%s</%slabel>\n' % (namespace_, self.gds_format_string(quote_xml(self.label).encode(ExternalEncoding), input_name='label'), namespace_))
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.label is not None or
            self.type_ or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Agent'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.label is not None:
            showIndent(outfile, level)
            outfile.write('label=%s,\n' % quote_python(self.label).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'label':
            label_ = child_.text
            label_ = self.gds_validate_string(label_, node, 'label')
            self.label = label_
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'Agent')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class Agent


class WasAssociatedWith(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, activity=None, agent=None, plan=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.activity = activity
        self.agent = agent
        self.plan = plan
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasAssociatedWith.subclass:
            return WasAssociatedWith.subclass(*args_, **kwargs_)
        else:
            return WasAssociatedWith(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_activity(self): return self.activity
    def set_activity(self, activity): self.activity = activity
    def get_agent(self): return self.agent
    def set_agent(self, agent): self.agent = agent
    def get_plan(self): return self.plan
    def set_plan(self, plan): self.plan = plan
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasAssociatedWith', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasAssociatedWith')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasAssociatedWith'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasAssociatedWith', fromsubclass_=False):
        if self.activity is not None:
            self.activity.export(outfile, level, namespace_, name_='activity', )
        if self.agent is not None:
            self.agent.export(outfile, level, namespace_, name_='agent', )
        if self.plan is not None:
            self.plan.export(outfile, level, namespace_, name_='plan')
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.activity is not None or
            self.agent is not None or
            self.plan is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasAssociatedWith'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.activity is not None:
            showIndent(outfile, level)
            outfile.write('activity=model_.ActivityRef(\n')
            self.activity.exportLiteral(outfile, level, name_='activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.agent is not None:
            showIndent(outfile, level)
            outfile.write('agent=model_.AgentRef(\n')
            self.agent.exportLiteral(outfile, level, name_='agent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.plan is not None:
            showIndent(outfile, level)
            outfile.write('plan=model_.EntityRef(\n')
            self.plan.exportLiteral(outfile, level, name_='plan')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'activity':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_activity(obj_)
        elif nodeName_ == 'agent':
            obj_ = AgentRef.factory()
            obj_.build(child_)
            self.set_agent(obj_)
        elif nodeName_ == 'plan':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_plan(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasAssociatedWith')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasAssociatedWith


class WasAttributedTo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, entity=None, agent=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.entity = entity
        self.agent = agent
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasAttributedTo.subclass:
            return WasAttributedTo.subclass(*args_, **kwargs_)
        else:
            return WasAttributedTo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_agent(self): return self.agent
    def set_agent(self, agent): self.agent = agent
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasAttributedTo', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasAttributedTo')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasAttributedTo'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasAttributedTo', fromsubclass_=False):
        if self.entity is not None:
            self.entity.export(outfile, level, namespace_, name_='entity', )
        if self.agent is not None:
            self.agent.export(outfile, level, namespace_, name_='agent', )
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.entity is not None or
            self.agent is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasAttributedTo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.entity is not None:
            showIndent(outfile, level)
            outfile.write('entity=model_.EntityRef(\n')
            self.entity.exportLiteral(outfile, level, name_='entity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.agent is not None:
            showIndent(outfile, level)
            outfile.write('agent=model_.AgentRef(\n')
            self.agent.exportLiteral(outfile, level, name_='agent')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entity':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_entity(obj_)
        elif nodeName_ == 'agent':
            obj_ = AgentRef.factory()
            obj_.build(child_)
            self.set_agent(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasAttributedTo')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasAttributedTo


class ActedOnBehalfOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, subordinate=None, responsible=None, activity=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.subordinate = subordinate
        self.responsible = responsible
        self.activity = activity
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if ActedOnBehalfOf.subclass:
            return ActedOnBehalfOf.subclass(*args_, **kwargs_)
        else:
            return ActedOnBehalfOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subordinate(self): return self.subordinate
    def set_subordinate(self, subordinate): self.subordinate = subordinate
    def get_responsible(self): return self.responsible
    def set_responsible(self, responsible): self.responsible = responsible
    def get_activity(self): return self.activity
    def set_activity(self, activity): self.activity = activity
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='ActedOnBehalfOf', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActedOnBehalfOf')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='ActedOnBehalfOf'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='ActedOnBehalfOf', fromsubclass_=False):
        if self.subordinate is not None:
            self.subordinate.export(outfile, level, namespace_, name_='subordinate', )
        if self.responsible is not None:
            self.responsible.export(outfile, level, namespace_, name_='responsible', )
        if self.activity is not None:
            self.activity.export(outfile, level, namespace_, name_='activity', )
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.subordinate is not None or
            self.responsible is not None or
            self.activity is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActedOnBehalfOf'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.subordinate is not None:
            showIndent(outfile, level)
            outfile.write('subordinate=model_.AgentRef(\n')
            self.subordinate.exportLiteral(outfile, level, name_='subordinate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.responsible is not None:
            showIndent(outfile, level)
            outfile.write('responsible=model_.AgentRef(\n')
            self.responsible.exportLiteral(outfile, level, name_='responsible')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.activity is not None:
            showIndent(outfile, level)
            outfile.write('activity=model_.ActivityRef(\n')
            self.activity.exportLiteral(outfile, level, name_='activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subordinate':
            obj_ = AgentRef.factory()
            obj_.build(child_)
            self.set_subordinate(obj_)
        elif nodeName_ == 'responsible':
            obj_ = AgentRef.factory()
            obj_.build(child_)
            self.set_responsible(obj_)
        elif nodeName_ == 'activity':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_activity(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'ActedOnBehalfOf')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class ActedOnBehalfOf


class WasDerivedFrom(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, generation=None, usage=None, activity=None, generatedEntity=None, usedEntity=None, type_=None, role=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.generation = generation
        self.usage = usage
        self.activity = activity
        self.generatedEntity = generatedEntity
        self.usedEntity = usedEntity
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if role is None:
            self.role = []
        else:
            self.role = role
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasDerivedFrom.subclass:
            return WasDerivedFrom.subclass(*args_, **kwargs_)
        else:
            return WasDerivedFrom(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_generation(self): return self.generation
    def set_generation(self, generation): self.generation = generation
    def get_usage(self): return self.usage
    def set_usage(self, usage): self.usage = usage
    def get_activity(self): return self.activity
    def set_activity(self, activity): self.activity = activity
    def get_generatedEntity(self): return self.generatedEntity
    def set_generatedEntity(self, generatedEntity): self.generatedEntity = generatedEntity
    def get_usedEntity(self): return self.usedEntity
    def set_usedEntity(self, usedEntity): self.usedEntity = usedEntity
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def add_role(self, value): self.role.append(value)
    def insert_role(self, index, value): self.role[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasDerivedFrom', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasDerivedFrom')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasDerivedFrom'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasDerivedFrom', fromsubclass_=False):
        if self.generation is not None:
            self.generation.export(outfile, level, namespace_, name_='generation')
        if self.usage is not None:
            self.usage.export(outfile, level, namespace_, name_='usage')
        if self.activity is not None:
            self.activity.export(outfile, level, namespace_, name_='activity')
        if self.generatedEntity is not None:
            self.generatedEntity.export(outfile, level, namespace_, name_='generatedEntity', )
        if self.usedEntity is not None:
            self.usedEntity.export(outfile, level, namespace_, name_='usedEntity', )
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for role_ in self.role:
            role_.export(outfile, level, namespace_, name_='role')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.generation is not None or
            self.usage is not None or
            self.activity is not None or
            self.generatedEntity is not None or
            self.usedEntity is not None or
            self.type_ or
            self.role or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasDerivedFrom'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.generation is not None:
            showIndent(outfile, level)
            outfile.write('generation=model_.DependencyRef(\n')
            self.generation.exportLiteral(outfile, level, name_='generation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.usage is not None:
            showIndent(outfile, level)
            outfile.write('usage=model_.DependencyRef(\n')
            self.usage.exportLiteral(outfile, level, name_='usage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.activity is not None:
            showIndent(outfile, level)
            outfile.write('activity=model_.ActivityRef(\n')
            self.activity.exportLiteral(outfile, level, name_='activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generatedEntity is not None:
            showIndent(outfile, level)
            outfile.write('generatedEntity=model_.EntityRef(\n')
            self.generatedEntity.exportLiteral(outfile, level, name_='generatedEntity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.usedEntity is not None:
            showIndent(outfile, level)
            outfile.write('usedEntity=model_.EntityRef(\n')
            self.usedEntity.exportLiteral(outfile, level, name_='usedEntity')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('role=[\n')
        level += 1
        for role_ in self.role:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            role_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'generation':
            obj_ = DependencyRef.factory()
            obj_.build(child_)
            self.set_generation(obj_)
        elif nodeName_ == 'usage':
            obj_ = DependencyRef.factory()
            obj_.build(child_)
            self.set_usage(obj_)
        elif nodeName_ == 'activity':
            obj_ = ActivityRef.factory()
            obj_.build(child_)
            self.set_activity(obj_)
        elif nodeName_ == 'generatedEntity':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_generatedEntity(obj_)
        elif nodeName_ == 'usedEntity':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_usedEntity(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        elif nodeName_ == 'role':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.role.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasDerivedFrom')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasDerivedFrom


class WasRevisionOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, newer=None, older=None, responsibility=None, type_=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.newer = newer
        self.older = older
        self.responsibility = responsibility
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasRevisionOf.subclass:
            return WasRevisionOf.subclass(*args_, **kwargs_)
        else:
            return WasRevisionOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_newer(self): return self.newer
    def set_newer(self, newer): self.newer = newer
    def get_older(self): return self.older
    def set_older(self, older): self.older = older
    def get_responsibility(self): return self.responsibility
    def set_responsibility(self, responsibility): self.responsibility = responsibility
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasRevisionOf', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasRevisionOf')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasRevisionOf'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasRevisionOf', fromsubclass_=False):
        if self.newer is not None:
            self.newer.export(outfile, level, namespace_, name_='newer', )
        if self.older is not None:
            self.older.export(outfile, level, namespace_, name_='older', )
        if self.responsibility is not None:
            self.responsibility.export(outfile, level, namespace_, name_='responsibility')
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.newer is not None or
            self.older is not None or
            self.responsibility is not None or
            self.type_ or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasRevisionOf'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.newer is not None:
            showIndent(outfile, level)
            outfile.write('newer=model_.EntityRef(\n')
            self.newer.exportLiteral(outfile, level, name_='newer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.older is not None:
            showIndent(outfile, level)
            outfile.write('older=model_.EntityRef(\n')
            self.older.exportLiteral(outfile, level, name_='older')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.responsibility is not None:
            showIndent(outfile, level)
            outfile.write('responsibility=model_.AgentRef(\n')
            self.responsibility.exportLiteral(outfile, level, name_='responsibility')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'newer':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_newer(obj_)
        elif nodeName_ == 'older':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_older(obj_)
        elif nodeName_ == 'responsibility':
            obj_ = AgentRef.factory()
            obj_.build(child_)
            self.set_responsibility(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasRevisionOf')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasRevisionOf


class WasQuotedFrom(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, quote=None, original=None, quoterAgent=None, quotedAgent=None, type_=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.quote = quote
        self.original = original
        self.quoterAgent = quoterAgent
        self.quotedAgent = quotedAgent
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if WasQuotedFrom.subclass:
            return WasQuotedFrom.subclass(*args_, **kwargs_)
        else:
            return WasQuotedFrom(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quote(self): return self.quote
    def set_quote(self, quote): self.quote = quote
    def get_original(self): return self.original
    def set_original(self, original): self.original = original
    def get_quoterAgent(self): return self.quoterAgent
    def set_quoterAgent(self, quoterAgent): self.quoterAgent = quoterAgent
    def get_quotedAgent(self): return self.quotedAgent
    def set_quotedAgent(self, quotedAgent): self.quotedAgent = quotedAgent
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='WasQuotedFrom', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WasQuotedFrom')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='WasQuotedFrom'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='WasQuotedFrom', fromsubclass_=False):
        if self.quote is not None:
            self.quote.export(outfile, level, namespace_, name_='quote', )
        if self.original is not None:
            self.original.export(outfile, level, namespace_, name_='original', )
        if self.quoterAgent is not None:
            self.quoterAgent.export(outfile, level, namespace_, name_='quoterAgent')
        if self.quotedAgent is not None:
            self.quotedAgent.export(outfile, level, namespace_, name_='quotedAgent')
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.quote is not None or
            self.original is not None or
            self.quoterAgent is not None or
            self.quotedAgent is not None or
            self.type_ or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WasQuotedFrom'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.quote is not None:
            showIndent(outfile, level)
            outfile.write('quote=model_.EntityRef(\n')
            self.quote.exportLiteral(outfile, level, name_='quote')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.original is not None:
            showIndent(outfile, level)
            outfile.write('original=model_.EntityRef(\n')
            self.original.exportLiteral(outfile, level, name_='original')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.quoterAgent is not None:
            showIndent(outfile, level)
            outfile.write('quoterAgent=model_.AgentRef(\n')
            self.quoterAgent.exportLiteral(outfile, level, name_='quoterAgent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.quotedAgent is not None:
            showIndent(outfile, level)
            outfile.write('quotedAgent=model_.AgentRef(\n')
            self.quotedAgent.exportLiteral(outfile, level, name_='quotedAgent')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quote':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_quote(obj_)
        elif nodeName_ == 'original':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_original(obj_)
        elif nodeName_ == 'quoterAgent':
            obj_ = AgentRef.factory()
            obj_.build(child_)
            self.set_quoterAgent(obj_)
        elif nodeName_ == 'quotedAgent':
            obj_ = AgentRef.factory()
            obj_.build(child_)
            self.set_quotedAgent(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'WasQuotedFrom')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class WasQuotedFrom


class HadOriginalSource(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, derived=None, source=None, type_=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.derived = derived
        self.source = source
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if HadOriginalSource.subclass:
            return HadOriginalSource.subclass(*args_, **kwargs_)
        else:
            return HadOriginalSource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_derived(self): return self.derived
    def set_derived(self, derived): self.derived = derived
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='HadOriginalSource', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HadOriginalSource')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='HadOriginalSource'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='HadOriginalSource', fromsubclass_=False):
        if self.derived is not None:
            self.derived.export(outfile, level, namespace_, name_='derived', )
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', )
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.derived is not None or
            self.source is not None or
            self.type_ or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HadOriginalSource'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.derived is not None:
            showIndent(outfile, level)
            outfile.write('derived=model_.EntityRef(\n')
            self.derived.exportLiteral(outfile, level, name_='derived')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.EntityRef(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'derived':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_derived(obj_)
        elif nodeName_ == 'source':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'HadOriginalSource')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class HadOriginalSource


class TracedTo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, entity=None, ancestor=None, type_=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.entity = entity
        self.ancestor = ancestor
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if TracedTo.subclass:
            return TracedTo.subclass(*args_, **kwargs_)
        else:
            return TracedTo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_ancestor(self): return self.ancestor
    def set_ancestor(self, ancestor): self.ancestor = ancestor
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='TracedTo', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TracedTo')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='TracedTo'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='TracedTo', fromsubclass_=False):
        if self.entity is not None:
            self.entity.export(outfile, level, namespace_, name_='entity', )
        if self.ancestor is not None:
            self.ancestor.export(outfile, level, namespace_, name_='ancestor', )
        for type_ in self.type_:
            type_.export(outfile, level, namespace_, name_='type')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.entity is not None or
            self.ancestor is not None or
            self.type_ or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TracedTo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.entity is not None:
            showIndent(outfile, level)
            outfile.write('entity=model_.EntityRef(\n')
            self.entity.exportLiteral(outfile, level, name_='entity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ancestor is not None:
            showIndent(outfile, level)
            outfile.write('ancestor=model_.EntityRef(\n')
            self.ancestor.exportLiteral(outfile, level, name_='ancestor')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('model_.xs_anySimpleType(\n')
            type_.exportLiteral(outfile, level, name_='xs:anySimpleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entity':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_entity(obj_)
        elif nodeName_ == 'ancestor':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_ancestor(obj_)
        elif nodeName_ == 'type':
            obj_ = xs_anySimpleType.factory()
            obj_.build(child_)
            self.type_.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'TracedTo')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class TracedTo


class AlternateOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, entity2=None, entity1=None):
        self.entity2 = entity2
        self.entity1 = entity1
    def factory(*args_, **kwargs_):
        if AlternateOf.subclass:
            return AlternateOf.subclass(*args_, **kwargs_)
        else:
            return AlternateOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity2(self): return self.entity2
    def set_entity2(self, entity2): self.entity2 = entity2
    def get_entity1(self): return self.entity1
    def set_entity1(self, entity1): self.entity1 = entity1
    def export(self, outfile, level, namespace_='xcede2:', name_='AlternateOf', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AlternateOf')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='AlternateOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='AlternateOf', fromsubclass_=False):
        if self.entity2 is not None:
            self.entity2.export(outfile, level, namespace_, name_='entity2', )
        if self.entity1 is not None:
            self.entity1.export(outfile, level, namespace_, name_='entity1', )
    def hasContent_(self):
        if (
            self.entity2 is not None or
            self.entity1 is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AlternateOf'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.entity2 is not None:
            showIndent(outfile, level)
            outfile.write('entity2=model_.EntityRef(\n')
            self.entity2.exportLiteral(outfile, level, name_='entity2')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.entity1 is not None:
            showIndent(outfile, level)
            outfile.write('entity1=model_.EntityRef(\n')
            self.entity1.exportLiteral(outfile, level, name_='entity1')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entity2':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_entity2(obj_)
        elif nodeName_ == 'entity1':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_entity1(obj_)
# end class AlternateOf


class SpecializationOf(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, specializedEntity=None, generalEntity=None):
        self.specializedEntity = specializedEntity
        self.generalEntity = generalEntity
    def factory(*args_, **kwargs_):
        if SpecializationOf.subclass:
            return SpecializationOf.subclass(*args_, **kwargs_)
        else:
            return SpecializationOf(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_specializedEntity(self): return self.specializedEntity
    def set_specializedEntity(self, specializedEntity): self.specializedEntity = specializedEntity
    def get_generalEntity(self): return self.generalEntity
    def set_generalEntity(self, generalEntity): self.generalEntity = generalEntity
    def export(self, outfile, level, namespace_='xcede2:', name_='SpecializationOf', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpecializationOf')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='SpecializationOf'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='SpecializationOf', fromsubclass_=False):
        if self.specializedEntity is not None:
            self.specializedEntity.export(outfile, level, namespace_, name_='specializedEntity', )
        if self.generalEntity is not None:
            self.generalEntity.export(outfile, level, namespace_, name_='generalEntity', )
    def hasContent_(self):
        if (
            self.specializedEntity is not None or
            self.generalEntity is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SpecializationOf'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.specializedEntity is not None:
            showIndent(outfile, level)
            outfile.write('specializedEntity=model_.EntityRef(\n')
            self.specializedEntity.exportLiteral(outfile, level, name_='specializedEntity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generalEntity is not None:
            showIndent(outfile, level)
            outfile.write('generalEntity=model_.EntityRef(\n')
            self.generalEntity.exportLiteral(outfile, level, name_='generalEntity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'specializedEntity':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_specializedEntity(obj_)
        elif nodeName_ == 'generalEntity':
            obj_ = EntityRef.factory()
            obj_.build(child_)
            self.set_generalEntity(obj_)
# end class SpecializationOf


class Note(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if Note.subclass:
            return Note.subclass(*args_, **kwargs_)
        else:
            return Note(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='Note', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Note')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='Note'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='Note', fromsubclass_=False):
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Note'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'Note')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class Note


class HasAnnotation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, thing=None, note=None, anytypeobjs_=None):
        self.id = _cast(None, id)
        self.thing = thing
        self.note = note
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if HasAnnotation.subclass:
            return HasAnnotation.subclass(*args_, **kwargs_)
        else:
            return HasAnnotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_thing(self): return self.thing
    def set_thing(self, thing): self.thing = thing
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='HasAnnotation', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HasAnnotation')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='HasAnnotation'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='HasAnnotation', fromsubclass_=False):
        if self.thing is not None:
            self.thing.export(outfile, level, namespace_, name_='thing', )
        if self.note is not None:
            self.note.export(outfile, level, namespace_, name_='note', )
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.thing is not None or
            self.note is not None or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='HasAnnotation'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.thing is not None:
            showIndent(outfile, level)
            outfile.write('thing=model_.NoteRef(\n')
            self.thing.exportLiteral(outfile, level, name_='thing')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.note is not None:
            showIndent(outfile, level)
            outfile.write('note=model_.NoteRef(\n')
            self.note.exportLiteral(outfile, level, name_='note')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'thing':
            obj_ = NoteRef.factory()
            obj_.build(child_)
            self.set_thing(obj_)
        elif nodeName_ == 'note':
            obj_ = NoteRef.factory()
            obj_.build(child_)
            self.set_note(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'HasAnnotation')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class HasAnnotation


class ActivityRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if ActivityRef.subclass:
            return ActivityRef.subclass(*args_, **kwargs_)
        else:
            return ActivityRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def export(self, outfile, level, namespace_='xcede2:', name_='ActivityRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActivityRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='ActivityRef'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='ActivityRef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ActivityRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            showIndent(outfile, level)
            outfile.write('ref = "%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ActivityRef


class EntityRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if EntityRef.subclass:
            return EntityRef.subclass(*args_, **kwargs_)
        else:
            return EntityRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def export(self, outfile, level, namespace_='xcede2:', name_='EntityRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='EntityRef'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='EntityRef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            showIndent(outfile, level)
            outfile.write('ref = "%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntityRef


class AgentRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if AgentRef.subclass:
            return AgentRef.subclass(*args_, **kwargs_)
        else:
            return AgentRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def export(self, outfile, level, namespace_='xcede2:', name_='AgentRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgentRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='AgentRef'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='AgentRef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AgentRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            showIndent(outfile, level)
            outfile.write('ref = "%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AgentRef


class DependencyRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if DependencyRef.subclass:
            return DependencyRef.subclass(*args_, **kwargs_)
        else:
            return DependencyRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def export(self, outfile, level, namespace_='xcede2:', name_='DependencyRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DependencyRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='DependencyRef'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='DependencyRef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DependencyRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            showIndent(outfile, level)
            outfile.write('ref = "%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DependencyRef


class NoteRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ref=None):
        self.ref = _cast(None, ref)
        pass
    def factory(*args_, **kwargs_):
        if NoteRef.subclass:
            return NoteRef.subclass(*args_, **kwargs_)
        else:
            return NoteRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ref(self): return self.ref
    def set_ref(self, ref): self.ref = ref
    def export(self, outfile, level, namespace_='xcede2:', name_='NoteRef', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NoteRef')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='NoteRef'):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            outfile.write(' ref=%s' % (self.gds_format_string(quote_attrib(self.ref).encode(ExternalEncoding), input_name='ref'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='NoteRef', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NoteRef'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ref is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            showIndent(outfile, level)
            outfile.write('ref = "%s",\n' % (self.ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ref', node)
        if value is not None and 'ref' not in already_processed:
            already_processed.append('ref')
            self.ref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NoteRef


class Dependencies(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, used=None, wasGeneratedBy=None, wasStartedBy=None, wasEndedBy=None, wasInformedBy=None, wasStartedByActivity=None, wasAttributedTo=None, wasAssociatedWith=None, actedOnBehalfOf=None, wasDerivedFrom=None, wasRevisionOf=None, wasQuotedFrom=None, hadOriginalSource=None, tracedTo=None, alternateOf=None, specializationOf=None, hasAnnotation=None):
        if used is None:
            self.used = []
        else:
            self.used = used
        if wasGeneratedBy is None:
            self.wasGeneratedBy = []
        else:
            self.wasGeneratedBy = wasGeneratedBy
        if wasStartedBy is None:
            self.wasStartedBy = []
        else:
            self.wasStartedBy = wasStartedBy
        if wasEndedBy is None:
            self.wasEndedBy = []
        else:
            self.wasEndedBy = wasEndedBy
        if wasInformedBy is None:
            self.wasInformedBy = []
        else:
            self.wasInformedBy = wasInformedBy
        if wasStartedByActivity is None:
            self.wasStartedByActivity = []
        else:
            self.wasStartedByActivity = wasStartedByActivity
        if wasAttributedTo is None:
            self.wasAttributedTo = []
        else:
            self.wasAttributedTo = wasAttributedTo
        if wasAssociatedWith is None:
            self.wasAssociatedWith = []
        else:
            self.wasAssociatedWith = wasAssociatedWith
        if actedOnBehalfOf is None:
            self.actedOnBehalfOf = []
        else:
            self.actedOnBehalfOf = actedOnBehalfOf
        if wasDerivedFrom is None:
            self.wasDerivedFrom = []
        else:
            self.wasDerivedFrom = wasDerivedFrom
        if wasRevisionOf is None:
            self.wasRevisionOf = []
        else:
            self.wasRevisionOf = wasRevisionOf
        if wasQuotedFrom is None:
            self.wasQuotedFrom = []
        else:
            self.wasQuotedFrom = wasQuotedFrom
        if hadOriginalSource is None:
            self.hadOriginalSource = []
        else:
            self.hadOriginalSource = hadOriginalSource
        if tracedTo is None:
            self.tracedTo = []
        else:
            self.tracedTo = tracedTo
        if alternateOf is None:
            self.alternateOf = []
        else:
            self.alternateOf = alternateOf
        if specializationOf is None:
            self.specializationOf = []
        else:
            self.specializationOf = specializationOf
        if hasAnnotation is None:
            self.hasAnnotation = []
        else:
            self.hasAnnotation = hasAnnotation
    def factory(*args_, **kwargs_):
        if Dependencies.subclass:
            return Dependencies.subclass(*args_, **kwargs_)
        else:
            return Dependencies(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_used(self): return self.used
    def set_used(self, used): self.used = used
    def add_used(self, value): self.used.append(value)
    def insert_used(self, index, value): self.used[index] = value
    def get_wasGeneratedBy(self): return self.wasGeneratedBy
    def set_wasGeneratedBy(self, wasGeneratedBy): self.wasGeneratedBy = wasGeneratedBy
    def add_wasGeneratedBy(self, value): self.wasGeneratedBy.append(value)
    def insert_wasGeneratedBy(self, index, value): self.wasGeneratedBy[index] = value
    def get_wasStartedBy(self): return self.wasStartedBy
    def set_wasStartedBy(self, wasStartedBy): self.wasStartedBy = wasStartedBy
    def add_wasStartedBy(self, value): self.wasStartedBy.append(value)
    def insert_wasStartedBy(self, index, value): self.wasStartedBy[index] = value
    def get_wasEndedBy(self): return self.wasEndedBy
    def set_wasEndedBy(self, wasEndedBy): self.wasEndedBy = wasEndedBy
    def add_wasEndedBy(self, value): self.wasEndedBy.append(value)
    def insert_wasEndedBy(self, index, value): self.wasEndedBy[index] = value
    def get_wasInformedBy(self): return self.wasInformedBy
    def set_wasInformedBy(self, wasInformedBy): self.wasInformedBy = wasInformedBy
    def add_wasInformedBy(self, value): self.wasInformedBy.append(value)
    def insert_wasInformedBy(self, index, value): self.wasInformedBy[index] = value
    def get_wasStartedByActivity(self): return self.wasStartedByActivity
    def set_wasStartedByActivity(self, wasStartedByActivity): self.wasStartedByActivity = wasStartedByActivity
    def add_wasStartedByActivity(self, value): self.wasStartedByActivity.append(value)
    def insert_wasStartedByActivity(self, index, value): self.wasStartedByActivity[index] = value
    def get_wasAttributedTo(self): return self.wasAttributedTo
    def set_wasAttributedTo(self, wasAttributedTo): self.wasAttributedTo = wasAttributedTo
    def add_wasAttributedTo(self, value): self.wasAttributedTo.append(value)
    def insert_wasAttributedTo(self, index, value): self.wasAttributedTo[index] = value
    def get_wasAssociatedWith(self): return self.wasAssociatedWith
    def set_wasAssociatedWith(self, wasAssociatedWith): self.wasAssociatedWith = wasAssociatedWith
    def add_wasAssociatedWith(self, value): self.wasAssociatedWith.append(value)
    def insert_wasAssociatedWith(self, index, value): self.wasAssociatedWith[index] = value
    def get_actedOnBehalfOf(self): return self.actedOnBehalfOf
    def set_actedOnBehalfOf(self, actedOnBehalfOf): self.actedOnBehalfOf = actedOnBehalfOf
    def add_actedOnBehalfOf(self, value): self.actedOnBehalfOf.append(value)
    def insert_actedOnBehalfOf(self, index, value): self.actedOnBehalfOf[index] = value
    def get_wasDerivedFrom(self): return self.wasDerivedFrom
    def set_wasDerivedFrom(self, wasDerivedFrom): self.wasDerivedFrom = wasDerivedFrom
    def add_wasDerivedFrom(self, value): self.wasDerivedFrom.append(value)
    def insert_wasDerivedFrom(self, index, value): self.wasDerivedFrom[index] = value
    def get_wasRevisionOf(self): return self.wasRevisionOf
    def set_wasRevisionOf(self, wasRevisionOf): self.wasRevisionOf = wasRevisionOf
    def add_wasRevisionOf(self, value): self.wasRevisionOf.append(value)
    def insert_wasRevisionOf(self, index, value): self.wasRevisionOf[index] = value
    def get_wasQuotedFrom(self): return self.wasQuotedFrom
    def set_wasQuotedFrom(self, wasQuotedFrom): self.wasQuotedFrom = wasQuotedFrom
    def add_wasQuotedFrom(self, value): self.wasQuotedFrom.append(value)
    def insert_wasQuotedFrom(self, index, value): self.wasQuotedFrom[index] = value
    def get_hadOriginalSource(self): return self.hadOriginalSource
    def set_hadOriginalSource(self, hadOriginalSource): self.hadOriginalSource = hadOriginalSource
    def add_hadOriginalSource(self, value): self.hadOriginalSource.append(value)
    def insert_hadOriginalSource(self, index, value): self.hadOriginalSource[index] = value
    def get_tracedTo(self): return self.tracedTo
    def set_tracedTo(self, tracedTo): self.tracedTo = tracedTo
    def add_tracedTo(self, value): self.tracedTo.append(value)
    def insert_tracedTo(self, index, value): self.tracedTo[index] = value
    def get_alternateOf(self): return self.alternateOf
    def set_alternateOf(self, alternateOf): self.alternateOf = alternateOf
    def add_alternateOf(self, value): self.alternateOf.append(value)
    def insert_alternateOf(self, index, value): self.alternateOf[index] = value
    def get_specializationOf(self): return self.specializationOf
    def set_specializationOf(self, specializationOf): self.specializationOf = specializationOf
    def add_specializationOf(self, value): self.specializationOf.append(value)
    def insert_specializationOf(self, index, value): self.specializationOf[index] = value
    def get_hasAnnotation(self): return self.hasAnnotation
    def set_hasAnnotation(self, hasAnnotation): self.hasAnnotation = hasAnnotation
    def add_hasAnnotation(self, value): self.hasAnnotation.append(value)
    def insert_hasAnnotation(self, index, value): self.hasAnnotation[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='Dependencies', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Dependencies')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='Dependencies'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='Dependencies', fromsubclass_=False):
        for used_ in self.used:
            used_.export(outfile, level, namespace_, name_='used')
        for wasGeneratedBy_ in self.wasGeneratedBy:
            wasGeneratedBy_.export(outfile, level, namespace_, name_='wasGeneratedBy')
        for wasStartedBy_ in self.wasStartedBy:
            wasStartedBy_.export(outfile, level, namespace_, name_='wasStartedBy')
        for wasEndedBy_ in self.wasEndedBy:
            wasEndedBy_.export(outfile, level, namespace_, name_='wasEndedBy')
        for wasInformedBy_ in self.wasInformedBy:
            wasInformedBy_.export(outfile, level, namespace_, name_='wasInformedBy')
        for wasStartedByActivity_ in self.wasStartedByActivity:
            wasStartedByActivity_.export(outfile, level, namespace_, name_='wasStartedByActivity')
        for wasAttributedTo_ in self.wasAttributedTo:
            wasAttributedTo_.export(outfile, level, namespace_, name_='wasAttributedTo')
        for wasAssociatedWith_ in self.wasAssociatedWith:
            wasAssociatedWith_.export(outfile, level, namespace_, name_='wasAssociatedWith')
        for actedOnBehalfOf_ in self.actedOnBehalfOf:
            actedOnBehalfOf_.export(outfile, level, namespace_, name_='actedOnBehalfOf')
        for wasDerivedFrom_ in self.wasDerivedFrom:
            wasDerivedFrom_.export(outfile, level, namespace_, name_='wasDerivedFrom')
        for wasRevisionOf_ in self.wasRevisionOf:
            wasRevisionOf_.export(outfile, level, namespace_, name_='wasRevisionOf')
        for wasQuotedFrom_ in self.wasQuotedFrom:
            wasQuotedFrom_.export(outfile, level, namespace_, name_='wasQuotedFrom')
        for hadOriginalSource_ in self.hadOriginalSource:
            hadOriginalSource_.export(outfile, level, namespace_, name_='hadOriginalSource')
        for tracedTo_ in self.tracedTo:
            tracedTo_.export(outfile, level, namespace_, name_='tracedTo')
        for alternateOf_ in self.alternateOf:
            alternateOf_.export(outfile, level, namespace_, name_='alternateOf')
        for specializationOf_ in self.specializationOf:
            specializationOf_.export(outfile, level, namespace_, name_='specializationOf')
        for hasAnnotation_ in self.hasAnnotation:
            hasAnnotation_.export(outfile, level, namespace_, name_='hasAnnotation')
    def hasContent_(self):
        if (
            self.used or
            self.wasGeneratedBy or
            self.wasStartedBy or
            self.wasEndedBy or
            self.wasInformedBy or
            self.wasStartedByActivity or
            self.wasAttributedTo or
            self.wasAssociatedWith or
            self.actedOnBehalfOf or
            self.wasDerivedFrom or
            self.wasRevisionOf or
            self.wasQuotedFrom or
            self.hadOriginalSource or
            self.tracedTo or
            self.alternateOf or
            self.specializationOf or
            self.hasAnnotation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Dependencies'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('used=[\n')
        level += 1
        for used_ in self.used:
            showIndent(outfile, level)
            outfile.write('model_.Used(\n')
            used_.exportLiteral(outfile, level, name_='Used')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasGeneratedBy=[\n')
        level += 1
        for wasGeneratedBy_ in self.wasGeneratedBy:
            showIndent(outfile, level)
            outfile.write('model_.WasGeneratedBy(\n')
            wasGeneratedBy_.exportLiteral(outfile, level, name_='WasGeneratedBy')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasStartedBy=[\n')
        level += 1
        for wasStartedBy_ in self.wasStartedBy:
            showIndent(outfile, level)
            outfile.write('model_.WasStartedBy(\n')
            wasStartedBy_.exportLiteral(outfile, level, name_='WasStartedBy')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasEndedBy=[\n')
        level += 1
        for wasEndedBy_ in self.wasEndedBy:
            showIndent(outfile, level)
            outfile.write('model_.WasEndedBy(\n')
            wasEndedBy_.exportLiteral(outfile, level, name_='WasEndedBy')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasInformedBy=[\n')
        level += 1
        for wasInformedBy_ in self.wasInformedBy:
            showIndent(outfile, level)
            outfile.write('model_.WasInformedBy(\n')
            wasInformedBy_.exportLiteral(outfile, level, name_='WasInformedBy')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasStartedByActivity=[\n')
        level += 1
        for wasStartedByActivity_ in self.wasStartedByActivity:
            showIndent(outfile, level)
            outfile.write('model_.WasStartedByActivity(\n')
            wasStartedByActivity_.exportLiteral(outfile, level, name_='WasStartedByActivity')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasAttributedTo=[\n')
        level += 1
        for wasAttributedTo_ in self.wasAttributedTo:
            showIndent(outfile, level)
            outfile.write('model_.WasAttributedTo(\n')
            wasAttributedTo_.exportLiteral(outfile, level, name_='WasAttributedTo')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasAssociatedWith=[\n')
        level += 1
        for wasAssociatedWith_ in self.wasAssociatedWith:
            showIndent(outfile, level)
            outfile.write('model_.WasAssociatedWith(\n')
            wasAssociatedWith_.exportLiteral(outfile, level, name_='WasAssociatedWith')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('actedOnBehalfOf=[\n')
        level += 1
        for actedOnBehalfOf_ in self.actedOnBehalfOf:
            showIndent(outfile, level)
            outfile.write('model_.ActedOnBehalfOf(\n')
            actedOnBehalfOf_.exportLiteral(outfile, level, name_='ActedOnBehalfOf')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasDerivedFrom=[\n')
        level += 1
        for wasDerivedFrom_ in self.wasDerivedFrom:
            showIndent(outfile, level)
            outfile.write('model_.WasDerivedFrom(\n')
            wasDerivedFrom_.exportLiteral(outfile, level, name_='WasDerivedFrom')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasRevisionOf=[\n')
        level += 1
        for wasRevisionOf_ in self.wasRevisionOf:
            showIndent(outfile, level)
            outfile.write('model_.WasRevisionOf(\n')
            wasRevisionOf_.exportLiteral(outfile, level, name_='WasRevisionOf')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('wasQuotedFrom=[\n')
        level += 1
        for wasQuotedFrom_ in self.wasQuotedFrom:
            showIndent(outfile, level)
            outfile.write('model_.WasQuotedFrom(\n')
            wasQuotedFrom_.exportLiteral(outfile, level, name_='WasQuotedFrom')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hadOriginalSource=[\n')
        level += 1
        for hadOriginalSource_ in self.hadOriginalSource:
            showIndent(outfile, level)
            outfile.write('model_.HadOriginalSource(\n')
            hadOriginalSource_.exportLiteral(outfile, level, name_='HadOriginalSource')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('tracedTo=[\n')
        level += 1
        for tracedTo_ in self.tracedTo:
            showIndent(outfile, level)
            outfile.write('model_.TracedTo(\n')
            tracedTo_.exportLiteral(outfile, level, name_='TracedTo')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('alternateOf=[\n')
        level += 1
        for alternateOf_ in self.alternateOf:
            showIndent(outfile, level)
            outfile.write('model_.AlternateOf(\n')
            alternateOf_.exportLiteral(outfile, level, name_='AlternateOf')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('specializationOf=[\n')
        level += 1
        for specializationOf_ in self.specializationOf:
            showIndent(outfile, level)
            outfile.write('model_.SpecializationOf(\n')
            specializationOf_.exportLiteral(outfile, level, name_='SpecializationOf')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hasAnnotation=[\n')
        level += 1
        for hasAnnotation_ in self.hasAnnotation:
            showIndent(outfile, level)
            outfile.write('model_.HasAnnotation(\n')
            hasAnnotation_.exportLiteral(outfile, level, name_='HasAnnotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'used':
            obj_ = Used.factory()
            obj_.build(child_)
            self.used.append(obj_)
        elif nodeName_ == 'wasGeneratedBy':
            obj_ = WasGeneratedBy.factory()
            obj_.build(child_)
            self.wasGeneratedBy.append(obj_)
        elif nodeName_ == 'wasStartedBy':
            obj_ = WasStartedBy.factory()
            obj_.build(child_)
            self.wasStartedBy.append(obj_)
        elif nodeName_ == 'wasEndedBy':
            obj_ = WasEndedBy.factory()
            obj_.build(child_)
            self.wasEndedBy.append(obj_)
        elif nodeName_ == 'wasInformedBy':
            obj_ = WasInformedBy.factory()
            obj_.build(child_)
            self.wasInformedBy.append(obj_)
        elif nodeName_ == 'wasStartedByActivity':
            obj_ = WasStartedByActivity.factory()
            obj_.build(child_)
            self.wasStartedByActivity.append(obj_)
        elif nodeName_ == 'wasAttributedTo':
            obj_ = WasAttributedTo.factory()
            obj_.build(child_)
            self.wasAttributedTo.append(obj_)
        elif nodeName_ == 'wasAssociatedWith':
            obj_ = WasAssociatedWith.factory()
            obj_.build(child_)
            self.wasAssociatedWith.append(obj_)
        elif nodeName_ == 'actedOnBehalfOf':
            obj_ = ActedOnBehalfOf.factory()
            obj_.build(child_)
            self.actedOnBehalfOf.append(obj_)
        elif nodeName_ == 'wasDerivedFrom':
            obj_ = WasDerivedFrom.factory()
            obj_.build(child_)
            self.wasDerivedFrom.append(obj_)
        elif nodeName_ == 'wasRevisionOf':
            obj_ = WasRevisionOf.factory()
            obj_.build(child_)
            self.wasRevisionOf.append(obj_)
        elif nodeName_ == 'wasQuotedFrom':
            obj_ = WasQuotedFrom.factory()
            obj_.build(child_)
            self.wasQuotedFrom.append(obj_)
        elif nodeName_ == 'hadOriginalSource':
            obj_ = HadOriginalSource.factory()
            obj_.build(child_)
            self.hadOriginalSource.append(obj_)
        elif nodeName_ == 'tracedTo':
            obj_ = TracedTo.factory()
            obj_.build(child_)
            self.tracedTo.append(obj_)
        elif nodeName_ == 'alternateOf':
            obj_ = AlternateOf.factory()
            obj_.build(child_)
            self.alternateOf.append(obj_)
        elif nodeName_ == 'specializationOf':
            obj_ = SpecializationOf.factory()
            obj_.build(child_)
            self.specializationOf.append(obj_)
        elif nodeName_ == 'hasAnnotation':
            obj_ = HasAnnotation.factory()
            obj_.build(child_)
            self.hasAnnotation.append(obj_)
# end class Dependencies


class Account(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, asserter=None, records=None):
        self.id = _cast(None, id)
        if asserter is None:
            self.asserter = []
        else:
            self.asserter = asserter
        self.records = records
    def factory(*args_, **kwargs_):
        if Account.subclass:
            return Account.subclass(*args_, **kwargs_)
        else:
            return Account(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_asserter(self): return self.asserter
    def set_asserter(self, asserter): self.asserter = asserter
    def add_asserter(self, value): self.asserter.append(value)
    def insert_asserter(self, index, value): self.asserter[index] = value
    def get_records(self): return self.records
    def set_records(self, records): self.records = records
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='Account', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Account')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='Account'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='Account', fromsubclass_=False):
        for asserter_ in self.asserter:
            asserter_.export(outfile, level, namespace_, name_='asserter')
        if self.records is not None:
            self.records.export(outfile, level, namespace_, name_='records', )
    def hasContent_(self):
        if (
            self.asserter or
            self.records is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Account'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('asserter=[\n')
        level += 1
        for asserter_ in self.asserter:
            showIndent(outfile, level)
            outfile.write('model_.AgentRef(\n')
            asserter_.exportLiteral(outfile, level, name_='AgentRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.records is not None:
            showIndent(outfile, level)
            outfile.write('records=model_.records(\n')
            self.records.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'asserter':
            obj_ = AgentRef.factory()
            obj_.build(child_)
            self.asserter.append(obj_)
        elif nodeName_ == 'records':
            obj_ = Records.factory()
            obj_.build(child_)
            self.set_records(obj_)
# end class Account


class Records(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, account=None, activity=None, entity=None, agent=None, note=None, dependencies=None):
        self.id = _cast(None, id)
        if account is None:
            self.account = []
        else:
            self.account = account
        if activity is None:
            self.activity = []
        else:
            self.activity = activity
        if entity is None:
            self.entity = []
        else:
            self.entity = entity
        if agent is None:
            self.agent = []
        else:
            self.agent = agent
        if note is None:
            self.note = []
        else:
            self.note = note
        self.dependencies = dependencies
    def factory(*args_, **kwargs_):
        if Records.subclass:
            return Records.subclass(*args_, **kwargs_)
        else:
            return Records(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account(self): return self.account
    def set_account(self, account): self.account = account
    def add_account(self, value): self.account.append(value)
    def insert_account(self, index, value): self.account[index] = value
    def get_activity(self): return self.activity
    def set_activity(self, activity): self.activity = activity
    def add_activity(self, value): self.activity.append(value)
    def insert_activity(self, index, value): self.activity[index] = value
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def add_entity(self, value): self.entity.append(value)
    def insert_entity(self, index, value): self.entity[index] = value
    def get_agent(self): return self.agent
    def set_agent(self, agent): self.agent = agent
    def add_agent(self, value): self.agent.append(value)
    def insert_agent(self, index, value): self.agent[index] = value
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def get_dependencies(self): return self.dependencies
    def set_dependencies(self, dependencies): self.dependencies = dependencies
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='Records', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Records')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='Records'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='Records', fromsubclass_=False):
        for account_ in self.account:
            account_.export(outfile, level, namespace_, name_='account')
        for activity_ in self.activity:
            activity_.export(outfile, level, namespace_, name_='activity')
        for entity_ in self.entity:
            entity_.export(outfile, level, namespace_, name_='entity')
        for agent_ in self.agent:
            agent_.export(outfile, level, namespace_, name_='agent')
        for note_ in self.note:
            note_.export(outfile, level, namespace_, name_='note')
        if self.dependencies is not None:
            self.dependencies.export(outfile, level, namespace_, name_='dependencies')
    def hasContent_(self):
        if (
            self.account or
            self.activity or
            self.entity or
            self.agent or
            self.note or
            self.dependencies is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Records'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('account=[\n')
        level += 1
        for account_ in self.account:
            showIndent(outfile, level)
            outfile.write('model_.account(\n')
            account_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('activity=[\n')
        level += 1
        for activity_ in self.activity:
            showIndent(outfile, level)
            outfile.write('model_.activity(\n')
            activity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('entity=[\n')
        level += 1
        for entity_ in self.entity:
            showIndent(outfile, level)
            outfile.write('model_.entity(\n')
            entity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('agent=[\n')
        level += 1
        for agent_ in self.agent:
            showIndent(outfile, level)
            outfile.write('model_.agent(\n')
            agent_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('model_.note(\n')
            note_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.dependencies is not None:
            showIndent(outfile, level)
            outfile.write('dependencies=model_.Dependencies(\n')
            self.dependencies.exportLiteral(outfile, level, name_='dependencies')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'account':
            obj_ = Account.factory()
            obj_.build(child_)
            self.account.append(obj_)
        elif nodeName_ == 'activity':
            obj_ = Activity.factory()
            obj_.build(child_)
            self.activity.append(obj_)
        elif nodeName_ == 'entity':
            obj_ = Entity.factory()
            obj_.build(child_)
            self.entity.append(obj_)
        elif nodeName_ == 'agent':
            obj_ = Agent.factory()
            obj_.build(child_)
            self.agent.append(obj_)
        elif nodeName_ == 'note':
            obj_ = Note.factory()
            obj_.build(child_)
            self.note.append(obj_)
        elif nodeName_ == 'dependencies':
            obj_ = Dependencies.factory()
            obj_.build(child_)
            self.set_dependencies(obj_)
# end class Records


class Container(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, records=None):
        self.id = _cast(None, id)
        self.records = records
    def factory(*args_, **kwargs_):
        if Container.subclass:
            return Container.subclass(*args_, **kwargs_)
        else:
            return Container(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_records(self): return self.records
    def set_records(self, records): self.records = records
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='xcede2:', name_='Container', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Container')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='Container'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='Container', fromsubclass_=False):
        if self.records is not None:
            self.records.export(outfile, level, namespace_, name_='records', )
    def hasContent_(self):
        if (
            self.records is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='Container'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.records is not None:
            showIndent(outfile, level)
            outfile.write('records=model_.records(\n')
            self.records.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'records':
            obj_ = Records.factory()
            obj_.build(child_)
            self.set_records(obj_)
# end class Container


class annotationListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, annotation=None):
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
    def factory(*args_, **kwargs_):
        if annotationListType.subclass:
            return annotationListType.subclass(*args_, **kwargs_)
        else:
            return annotationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def add_annotation(self, value): self.annotation.append(value)
    def insert_annotation(self, index, value): self.annotation[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='annotationListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annotationListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='annotationListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='annotationListType', fromsubclass_=False):
        for annotation_ in self.annotation:
            annotation_.export(outfile, level, namespace_, name_='annotation')
    def hasContent_(self):
        if (
            self.annotation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='annotationListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('annotation=[\n')
        level += 1
        for annotation_ in self.annotation:
            showIndent(outfile, level)
            outfile.write('model_.textAnnotation_t(\n')
            annotation_.exportLiteral(outfile, level, name_='textAnnotation_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotation':
            obj_ = textAnnotation_t.factory()
            obj_.build(child_)
            self.annotation.append(obj_)
# end class annotationListType


class revisionListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, revision=None):
        if revision is None:
            self.revision = []
        else:
            self.revision = revision
    def factory(*args_, **kwargs_):
        if revisionListType.subclass:
            return revisionListType.subclass(*args_, **kwargs_)
        else:
            return revisionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_revision(self): return self.revision
    def set_revision(self, revision): self.revision = revision
    def add_revision(self, value): self.revision.append(value)
    def insert_revision(self, index, value): self.revision[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='revisionListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='revisionListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='revisionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='revisionListType', fromsubclass_=False):
        for revision_ in self.revision:
            revision_.export(outfile, level, namespace_, name_='revision')
    def hasContent_(self):
        if (
            self.revision
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='revisionListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('revision=[\n')
        level += 1
        for revision_ in self.revision:
            showIndent(outfile, level)
            outfile.write('model_.revision_t(\n')
            revision_.exportLiteral(outfile, level, name_='revision_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'revision':
            obj_ = revision_t.factory()
            obj_.build(child_)
            self.revision.append(obj_)
# end class revisionListType


class contributorListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, contributor=None):
        if contributor is None:
            self.contributor = []
        else:
            self.contributor = contributor
    def factory(*args_, **kwargs_):
        if contributorListType.subclass:
            return contributorListType.subclass(*args_, **kwargs_)
        else:
            return contributorListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contributor(self): return self.contributor
    def set_contributor(self, contributor): self.contributor = contributor
    def add_contributor(self, value): self.contributor.append(value)
    def insert_contributor(self, index, value): self.contributor[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='contributorListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contributorListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='contributorListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='contributorListType', fromsubclass_=False):
        for contributor_ in self.contributor:
            contributor_.export(outfile, level, namespace_, name_='contributor')
    def hasContent_(self):
        if (
            self.contributor
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='contributorListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('contributor=[\n')
        level += 1
        for contributor_ in self.contributor:
            showIndent(outfile, level)
            outfile.write('model_.person_t(\n')
            contributor_.exportLiteral(outfile, level, name_='person_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contributor':
            obj_ = person_t.factory()
            obj_.build(child_)
            self.contributor.append(obj_)
# end class contributorListType


class stepsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, step=None, stepRef=None):
        if step is None:
            self.step = []
        else:
            self.step = step
        if stepRef is None:
            self.stepRef = []
        else:
            self.stepRef = stepRef
    def factory(*args_, **kwargs_):
        if stepsType.subclass:
            return stepsType.subclass(*args_, **kwargs_)
        else:
            return stepsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_step(self): return self.step
    def set_step(self, step): self.step = step
    def add_step(self, value): self.step.append(value)
    def insert_step(self, index, value): self.step[index] = value
    def get_stepRef(self): return self.stepRef
    def set_stepRef(self, stepRef): self.stepRef = stepRef
    def add_stepRef(self, value): self.stepRef.append(value)
    def insert_stepRef(self, index, value): self.stepRef[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='stepsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stepsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='stepsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='stepsType', fromsubclass_=False):
        for step_ in self.step:
            step_.export(outfile, level, namespace_, name_='step')
        for stepRef_ in self.stepRef:
            stepRef_.export(outfile, level, namespace_, name_='stepRef')
    def hasContent_(self):
        if (
            self.step or
            self.stepRef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stepsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('step=[\n')
        level += 1
        for step_ in self.step:
            showIndent(outfile, level)
            outfile.write('model_.protocol_t(\n')
            step_.exportLiteral(outfile, level, name_='protocol_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('stepRef=[\n')
        level += 1
        for stepRef_ in self.stepRef:
            showIndent(outfile, level)
            outfile.write('model_.ref_t(\n')
            stepRef_.exportLiteral(outfile, level, name_='ref_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'step':
            obj_ = protocol_t.factory()
            obj_.build(child_)
            self.step.append(obj_)
        elif nodeName_ == 'stepRef':
            obj_ = ref_t.factory()
            obj_.build(child_)
            self.stepRef.append(obj_)
# end class stepsType


class itemsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, item=None):
        if item is None:
            self.item = []
        else:
            self.item = item
    def factory(*args_, **kwargs_):
        if itemsType.subclass:
            return itemsType.subclass(*args_, **kwargs_)
        else:
            return itemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_item(self): return self.item
    def set_item(self, item): self.item = item
    def add_item(self, value): self.item.append(value)
    def insert_item(self, index, value): self.item[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='itemsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='itemsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='itemsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='itemsType', fromsubclass_=False):
        for item_ in self.item:
            item_.export(outfile, level, namespace_, name_='item')
    def hasContent_(self):
        if (
            self.item
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='itemsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('item=[\n')
        level += 1
        for item_ in self.item:
            showIndent(outfile, level)
            outfile.write('model_.protocolItem_t(\n')
            item_.exportLiteral(outfile, level, name_='protocolItem_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'item':
            class_obj_ = self.get_class_obj_(child_, protocolItem_t)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.item.append(obj_)
# end class itemsType


class catalogListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, catalog=None, catalogRef=None):
        if catalog is None:
            self.catalog = []
        else:
            self.catalog = catalog
        if catalogRef is None:
            self.catalogRef = []
        else:
            self.catalogRef = catalogRef
    def factory(*args_, **kwargs_):
        if catalogListType.subclass:
            return catalogListType.subclass(*args_, **kwargs_)
        else:
            return catalogListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_catalog(self): return self.catalog
    def set_catalog(self, catalog): self.catalog = catalog
    def add_catalog(self, value): self.catalog.append(value)
    def insert_catalog(self, index, value): self.catalog[index] = value
    def get_catalogRef(self): return self.catalogRef
    def set_catalogRef(self, catalogRef): self.catalogRef = catalogRef
    def add_catalogRef(self, value): self.catalogRef.append(value)
    def insert_catalogRef(self, index, value): self.catalogRef[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='catalogListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='catalogListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='catalogListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='catalogListType', fromsubclass_=False):
        for catalog_ in self.catalog:
            catalog_.export(outfile, level, namespace_, name_='catalog')
        for catalogRef_ in self.catalogRef:
            catalogRef_.export(outfile, level, namespace_, name_='catalogRef')
    def hasContent_(self):
        if (
            self.catalog or
            self.catalogRef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='catalogListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('catalog=[\n')
        level += 1
        for catalog_ in self.catalog:
            showIndent(outfile, level)
            outfile.write('model_.catalog_t(\n')
            catalog_.exportLiteral(outfile, level, name_='catalog_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('catalogRef=[\n')
        level += 1
        for catalogRef_ in self.catalogRef:
            showIndent(outfile, level)
            outfile.write('model_.catalogRefType(\n')
            catalogRef_.exportLiteral(outfile, level, name_='catalogRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'catalog':
            obj_ = catalog_t.factory()
            obj_.build(child_)
            self.catalog.append(obj_)
        elif nodeName_ == 'catalogRef':
            obj_ = catalogRefType.factory()
            obj_.build(child_)
            self.catalogRef.append(obj_)
# end class catalogListType


class catalogRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, catalogID=None):
        self.catalogID = _cast(None, catalogID)
        pass
    def factory(*args_, **kwargs_):
        if catalogRefType.subclass:
            return catalogRefType.subclass(*args_, **kwargs_)
        else:
            return catalogRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_catalogID(self): return self.catalogID
    def set_catalogID(self, catalogID): self.catalogID = catalogID
    def export(self, outfile, level, namespace_='xcede2:', name_='catalogRefType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='catalogRefType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='catalogRefType'):
        if self.catalogID is not None and 'catalogID' not in already_processed:
            already_processed.append('catalogID')
            outfile.write(' catalogID=%s' % (self.gds_format_string(quote_attrib(self.catalogID).encode(ExternalEncoding), input_name='catalogID'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='catalogRefType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='catalogRefType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.catalogID is not None and 'catalogID' not in already_processed:
            already_processed.append('catalogID')
            showIndent(outfile, level)
            outfile.write('catalogID = "%s",\n' % (self.catalogID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('catalogID', node)
        if value is not None and 'catalogID' not in already_processed:
            already_processed.append('catalogID')
            self.catalogID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class catalogRefType


class entryListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, entry=None, entryDataRef=None, entryResourceRef=None):
        if entry is None:
            self.entry = []
        else:
            self.entry = entry
        if entryDataRef is None:
            self.entryDataRef = []
        else:
            self.entryDataRef = entryDataRef
        if entryResourceRef is None:
            self.entryResourceRef = []
        else:
            self.entryResourceRef = entryResourceRef
    def factory(*args_, **kwargs_):
        if entryListType.subclass:
            return entryListType.subclass(*args_, **kwargs_)
        else:
            return entryListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entry(self): return self.entry
    def set_entry(self, entry): self.entry = entry
    def add_entry(self, value): self.entry.append(value)
    def insert_entry(self, index, value): self.entry[index] = value
    def get_entryDataRef(self): return self.entryDataRef
    def set_entryDataRef(self, entryDataRef): self.entryDataRef = entryDataRef
    def add_entryDataRef(self, value): self.entryDataRef.append(value)
    def insert_entryDataRef(self, index, value): self.entryDataRef[index] = value
    def get_entryResourceRef(self): return self.entryResourceRef
    def set_entryResourceRef(self, entryResourceRef): self.entryResourceRef = entryResourceRef
    def add_entryResourceRef(self, value): self.entryResourceRef.append(value)
    def insert_entryResourceRef(self, index, value): self.entryResourceRef[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='entryListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entryListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='entryListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='entryListType', fromsubclass_=False):
        for entry_ in self.entry:
            entry_.export(outfile, level, namespace_, name_='entry')
        for entryDataRef_ in self.entryDataRef:
            entryDataRef_.export(outfile, level, namespace_, name_='entryDataRef')
        for entryResourceRef_ in self.entryResourceRef:
            entryResourceRef_.export(outfile, level, namespace_, name_='entryResourceRef')
    def hasContent_(self):
        if (
            self.entry or
            self.entryDataRef or
            self.entryResourceRef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='entryListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('entry=[\n')
        level += 1
        for entry_ in self.entry:
            showIndent(outfile, level)
            outfile.write('model_.resource_t(\n')
            entry_.exportLiteral(outfile, level, name_='resource_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('entryDataRef=[\n')
        level += 1
        for entryDataRef_ in self.entryDataRef:
            showIndent(outfile, level)
            outfile.write('model_.ref_t(\n')
            entryDataRef_.exportLiteral(outfile, level, name_='ref_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('entryResourceRef=[\n')
        level += 1
        for entryResourceRef_ in self.entryResourceRef:
            showIndent(outfile, level)
            outfile.write('model_.ref_t(\n')
            entryResourceRef_.exportLiteral(outfile, level, name_='ref_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entry':
            class_obj_ = self.get_class_obj_(child_, resource_t)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.entry.append(obj_)
        elif nodeName_ == 'entryDataRef':
            obj_ = ref_t.factory()
            obj_.build(child_)
            self.entryDataRef.append(obj_)
        elif nodeName_ == 'entryResourceRef':
            obj_ = ref_t.factory()
            obj_.build(child_)
            self.entryResourceRef.append(obj_)
# end class entryListType


class commentListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, comment=None):
        if comment is None:
            self.comment = []
        else:
            self.comment = comment
    def factory(*args_, **kwargs_):
        if commentListType.subclass:
            return commentListType.subclass(*args_, **kwargs_)
        else:
            return commentListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def add_comment(self, value): self.comment.append(value)
    def insert_comment(self, index, value): self.comment[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='commentListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='commentListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='commentListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='commentListType', fromsubclass_=False):
        for comment_ in self.comment:
            comment_.export(outfile, level, namespace_, name_='comment')
    def hasContent_(self):
        if (
            self.comment
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='commentListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('comment=[\n')
        level += 1
        for comment_ in self.comment:
            showIndent(outfile, level)
            outfile.write('model_.authoredText_t(\n')
            comment_.exportLiteral(outfile, level, name_='authoredText_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'comment':
            obj_ = authoredText_t.factory()
            obj_.build(child_)
            self.comment.append(obj_)
# end class commentListType


class annotationListType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, annotation=None):
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
    def factory(*args_, **kwargs_):
        if annotationListType1.subclass:
            return annotationListType1.subclass(*args_, **kwargs_)
        else:
            return annotationListType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def add_annotation(self, value): self.annotation.append(value)
    def insert_annotation(self, index, value): self.annotation[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='annotationListType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annotationListType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='annotationListType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='annotationListType1', fromsubclass_=False):
        for annotation_ in self.annotation:
            annotation_.export(outfile, level, namespace_, name_='annotation')
    def hasContent_(self):
        if (
            self.annotation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='annotationListType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('annotation=[\n')
        level += 1
        for annotation_ in self.annotation:
            showIndent(outfile, level)
            outfile.write('model_.textAnnotation_t(\n')
            annotation_.exportLiteral(outfile, level, name_='textAnnotation_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'annotation':
            obj_ = textAnnotation_t.factory()
            obj_.build(child_)
            self.annotation.append(obj_)
# end class annotationListType1


class resourceListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resource=None):
        if resource is None:
            self.resource = []
        else:
            self.resource = resource
    def factory(*args_, **kwargs_):
        if resourceListType.subclass:
            return resourceListType.subclass(*args_, **kwargs_)
        else:
            return resourceListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def add_resource(self, value): self.resource.append(value)
    def insert_resource(self, index, value): self.resource[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='resourceListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resourceListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='resourceListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='resourceListType', fromsubclass_=False):
        for resource_ in self.resource:
            resource_.export(outfile, level, namespace_, name_='resource')
    def hasContent_(self):
        if (
            self.resource
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='resourceListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('resource=[\n')
        level += 1
        for resource_ in self.resource:
            showIndent(outfile, level)
            outfile.write('model_.informationResource_t(\n')
            resource_.exportLiteral(outfile, level, name_='informationResource_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'resource':
            class_obj_ = self.get_class_obj_(child_, informationResource_t)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.resource.append(obj_)
# end class resourceListType


class exptDesignListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, exptDesign=None, exptDesignRef=None):
        if exptDesign is None:
            self.exptDesign = []
        else:
            self.exptDesign = exptDesign
        if exptDesignRef is None:
            self.exptDesignRef = []
        else:
            self.exptDesignRef = exptDesignRef
    def factory(*args_, **kwargs_):
        if exptDesignListType.subclass:
            return exptDesignListType.subclass(*args_, **kwargs_)
        else:
            return exptDesignListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exptDesign(self): return self.exptDesign
    def set_exptDesign(self, exptDesign): self.exptDesign = exptDesign
    def add_exptDesign(self, value): self.exptDesign.append(value)
    def insert_exptDesign(self, index, value): self.exptDesign[index] = value
    def get_exptDesignRef(self): return self.exptDesignRef
    def set_exptDesignRef(self, exptDesignRef): self.exptDesignRef = exptDesignRef
    def add_exptDesignRef(self, value): self.exptDesignRef.append(value)
    def insert_exptDesignRef(self, index, value): self.exptDesignRef[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='exptDesignListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exptDesignListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='exptDesignListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='exptDesignListType', fromsubclass_=False):
        for exptDesign_ in self.exptDesign:
            showIndent(outfile, level)
            outfile.write('<%sexptDesign>%s</%sexptDesign>\n' % (namespace_, self.gds_format_string(quote_xml(exptDesign_).encode(ExternalEncoding), input_name='exptDesign'), namespace_))
        for exptDesignRef_ in self.exptDesignRef:
            exptDesignRef_.export(outfile, level, namespace_, name_='exptDesignRef')
    def hasContent_(self):
        if (
            self.exptDesign or
            self.exptDesignRef
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='exptDesignListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('exptDesign=[\n')
        level += 1
        for exptDesign_ in self.exptDesign:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(exptDesign_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('exptDesignRef=[\n')
        level += 1
        for exptDesignRef_ in self.exptDesignRef:
            showIndent(outfile, level)
            outfile.write('model_.ref_t(\n')
            exptDesignRef_.exportLiteral(outfile, level, name_='ref_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'exptDesign':
            exptDesign_ = child_.text
            exptDesign_ = self.gds_validate_string(exptDesign_, node, 'exptDesign')
            self.exptDesign.append(exptDesign_)
        elif nodeName_ == 'exptDesignRef':
            obj_ = ref_t.factory()
            obj_.build(child_)
            self.exptDesignRef.append(obj_)
# end class exptDesignListType


class exptDesign(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if exptDesign.subclass:
            return exptDesign.subclass(*args_, **kwargs_)
        else:
            return exptDesign(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xcede2:', name_='exptDesign', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='exptDesign')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='exptDesign'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='exptDesign', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='exptDesign'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class exptDesign


class subjectGroupListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, subjectGroup=None):
        if subjectGroup is None:
            self.subjectGroup = []
        else:
            self.subjectGroup = subjectGroup
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if subjectGroupListType.subclass:
            return subjectGroupListType.subclass(*args_, **kwargs_)
        else:
            return subjectGroupListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subjectGroup(self): return self.subjectGroup
    def set_subjectGroup(self, subjectGroup): self.subjectGroup = subjectGroup
    def add_subjectGroup(self, value): self.subjectGroup.append(value)
    def insert_subjectGroup(self, index, value): self.subjectGroup[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='subjectGroupListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subjectGroupListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='subjectGroupListType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='subjectGroupListType', fromsubclass_=False):
        for subjectGroup_ in self.subjectGroup:
            subjectGroup_.export(outfile, level, namespace_, name_='subjectGroup')
    def hasContent_(self):
        if (
            self.subjectGroup
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subjectGroupListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('subjectGroup=[\n')
        level += 1
        for subjectGroup_ in self.subjectGroup:
            showIndent(outfile, level)
            outfile.write('model_.subjectGroup_t(\n')
            subjectGroup_.exportLiteral(outfile, level, name_='subjectGroup_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subjectGroup':
            obj_ = subjectGroup_t.factory()
            obj_.build(child_)
            self.subjectGroup.append(obj_)
# end class subjectGroupListType


class datapointsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, label=None, value=None, valueOf_=None, mixedclass_=None, content_=None):
        self.label = _cast(None, label)
        if value is None:
            self.value = []
        else:
            self.value = value
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if datapointsType.subclass:
            return datapointsType.subclass(*args_, **kwargs_)
        else:
            return datapointsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='datapointsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='datapointsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='datapointsType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='datapointsType', fromsubclass_=False):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.value or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='datapointsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'value', valuestr_)
            self.content_.append(obj_)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class datapointsType


class measurementFrameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vector=None):
        if vector is None:
            self.vector = []
        else:
            self.vector = vector
    def factory(*args_, **kwargs_):
        if measurementFrameType.subclass:
            return measurementFrameType.subclass(*args_, **kwargs_)
        else:
            return measurementFrameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vector(self): return self.vector
    def set_vector(self, vector): self.vector = vector
    def add_vector(self, value): self.vector.append(value)
    def insert_vector(self, index, value): self.vector[index] = value
    def validate_listoffloats_t(self, value):
        # Validate type listoffloats_t, a restriction on xs:float.
        pass
    def export(self, outfile, level, namespace_='xcede2:', name_='measurementFrameType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='measurementFrameType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='measurementFrameType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='measurementFrameType', fromsubclass_=False):
        for vector_ in self.vector:
            showIndent(outfile, level)
            outfile.write('<%svector>%s</%svector>\n' % (namespace_, self.gds_format_float_list(vector_, input_name='vector'), namespace_))
    def hasContent_(self):
        if (
            self.vector
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='measurementFrameType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('vector=[\n')
        level += 1
        for vector_ in self.vector:
            showIndent(outfile, level)
            outfile.write('%f,\n' % vector_)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vector':
            vector_ = child_.text
            vector_ = self.gds_validate_float_list(vector_, node, 'vector')
            self.vector.append(vector_)
            self.vector = self.vector.split()
            self.validate_listoffloats_t(self.vector)    # validate type listoffloats_t
# end class measurementFrameType


class documentationListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, documentation=None):
        if documentation is None:
            self.documentation = []
        else:
            self.documentation = documentation
    def factory(*args_, **kwargs_):
        if documentationListType.subclass:
            return documentationListType.subclass(*args_, **kwargs_)
        else:
            return documentationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_documentation(self): return self.documentation
    def set_documentation(self, documentation): self.documentation = documentation
    def add_documentation(self, value): self.documentation.append(value)
    def insert_documentation(self, index, value): self.documentation[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='documentationListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='documentationListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='documentationListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='documentationListType', fromsubclass_=False):
        for documentation_ in self.documentation:
            documentation_.export(outfile, level, namespace_, name_='documentation')
    def hasContent_(self):
        if (
            self.documentation
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='documentationListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('documentation=[\n')
        level += 1
        for documentation_ in self.documentation:
            showIndent(outfile, level)
            outfile.write('model_.informationResource_t(\n')
            documentation_.exportLiteral(outfile, level, name_='informationResource_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'documentation':
            class_obj_ = self.get_class_obj_(child_, informationResource_t)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.documentation.append(obj_)
# end class documentationListType


class extensionListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extension=None):
        if extension is None:
            self.extension = []
        else:
            self.extension = extension
    def factory(*args_, **kwargs_):
        if extensionListType.subclass:
            return extensionListType.subclass(*args_, **kwargs_)
        else:
            return extensionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extension(self): return self.extension
    def set_extension(self, extension): self.extension = extension
    def add_extension(self, value): self.extension.append(value)
    def insert_extension(self, index, value): self.extension[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='extensionListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extensionListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='extensionListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='extensionListType', fromsubclass_=False):
        for extension_ in self.extension:
            showIndent(outfile, level)
            outfile.write('<%sextension>%s</%sextension>\n' % (namespace_, self.gds_format_string(quote_xml(extension_).encode(ExternalEncoding), input_name='extension'), namespace_))
    def hasContent_(self):
        if (
            self.extension
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='extensionListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('extension=[\n')
        level += 1
        for extension_ in self.extension:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(extension_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'extension':
            extension_ = child_.text
            extension_ = self.gds_validate_string(extension_, node, 'extension')
            self.extension.append(extension_)
# end class extensionListType


class metaFieldsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, metaField=None):
        if metaField is None:
            self.metaField = []
        else:
            self.metaField = metaField
    def factory(*args_, **kwargs_):
        if metaFieldsType.subclass:
            return metaFieldsType.subclass(*args_, **kwargs_)
        else:
            return metaFieldsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_metaField(self): return self.metaField
    def set_metaField(self, metaField): self.metaField = metaField
    def add_metaField(self, value): self.metaField.append(value)
    def insert_metaField(self, index, value): self.metaField[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='metaFieldsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metaFieldsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='metaFieldsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='metaFieldsType', fromsubclass_=False):
        for metaField_ in self.metaField:
            metaField_.export(outfile, level, namespace_, name_='metaField')
    def hasContent_(self):
        if (
            self.metaField
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metaFieldsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('metaField=[\n')
        level += 1
        for metaField_ in self.metaField:
            showIndent(outfile, level)
            outfile.write('model_.metaFieldType(\n')
            metaField_.exportLiteral(outfile, level, name_='metaFieldType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'metaField':
            obj_ = metaFieldType.factory()
            obj_.build(child_)
            self.metaField.append(obj_)
# end class metaFieldsType


class metaFieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if metaFieldType.subclass:
            return metaFieldType.subclass(*args_, **kwargs_)
        else:
            return metaFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='xcede2:', name_='metaFieldType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metaFieldType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='metaFieldType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='metaFieldType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metaFieldType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class metaFieldType


class itemTextType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, textLabel=None):
        if textLabel is None:
            self.textLabel = []
        else:
            self.textLabel = textLabel
    def factory(*args_, **kwargs_):
        if itemTextType.subclass:
            return itemTextType.subclass(*args_, **kwargs_)
        else:
            return itemTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_textLabel(self): return self.textLabel
    def set_textLabel(self, textLabel): self.textLabel = textLabel
    def add_textLabel(self, value): self.textLabel.append(value)
    def insert_textLabel(self, index, value): self.textLabel[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='itemTextType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='itemTextType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='itemTextType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='itemTextType', fromsubclass_=False):
        for textLabel_ in self.textLabel:
            textLabel_.export(outfile, level, namespace_, name_='textLabel')
    def hasContent_(self):
        if (
            self.textLabel
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='itemTextType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('textLabel=[\n')
        level += 1
        for textLabel_ in self.textLabel:
            showIndent(outfile, level)
            outfile.write('model_.textLabelType(\n')
            textLabel_.exportLiteral(outfile, level, name_='textLabelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'textLabel':
            obj_ = textLabelType.factory()
            obj_.build(child_)
            self.textLabel.append(obj_)
# end class itemTextType


class textLabelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, location=None, value=None):
        self.location = _cast(None, location)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if textLabelType.subclass:
            return textLabelType.subclass(*args_, **kwargs_)
        else:
            return textLabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='xcede2:', name_='textLabelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='textLabelType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='textLabelType'):
        if self.location is not None and 'location' not in already_processed:
            already_processed.append('location')
            outfile.write(' location=%s' % (self.gds_format_string(quote_attrib(self.location).encode(ExternalEncoding), input_name='location'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='textLabelType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='textLabelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.location is not None and 'location' not in already_processed:
            already_processed.append('location')
            showIndent(outfile, level)
            outfile.write('location = "%s",\n' % (self.location,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('location', node)
        if value is not None and 'location' not in already_processed:
            already_processed.append('location')
            self.location = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class textLabelType


class itemChoiceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, itemCode=None, itemValue=None, ID=None):
        self.units = _cast(None, units)
        self.itemCode = _cast(None, itemCode)
        self.itemValue = _cast(None, itemValue)
        self.ID = _cast(None, ID)
        pass
    def factory(*args_, **kwargs_):
        if itemChoiceType.subclass:
            return itemChoiceType.subclass(*args_, **kwargs_)
        else:
            return itemChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def get_itemCode(self): return self.itemCode
    def set_itemCode(self, itemCode): self.itemCode = itemCode
    def get_itemValue(self): return self.itemValue
    def set_itemValue(self, itemValue): self.itemValue = itemValue
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='xcede2:', name_='itemChoiceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='itemChoiceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='itemChoiceType'):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            outfile.write(' units=%s' % (self.gds_format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
        if self.itemCode is not None and 'itemCode' not in already_processed:
            already_processed.append('itemCode')
            outfile.write(' itemCode=%s' % (self.gds_format_string(quote_attrib(self.itemCode).encode(ExternalEncoding), input_name='itemCode'), ))
        if self.itemValue is not None and 'itemValue' not in already_processed:
            already_processed.append('itemValue')
            outfile.write(' itemValue=%s' % (self.gds_format_string(quote_attrib(self.itemValue).encode(ExternalEncoding), input_name='itemValue'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='itemChoiceType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='itemChoiceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.units is not None and 'units' not in already_processed:
            already_processed.append('units')
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
        if self.itemCode is not None and 'itemCode' not in already_processed:
            already_processed.append('itemCode')
            showIndent(outfile, level)
            outfile.write('itemCode = "%s",\n' % (self.itemCode,))
        if self.itemValue is not None and 'itemValue' not in already_processed:
            already_processed.append('itemValue')
            showIndent(outfile, level)
            outfile.write('itemValue = "%s",\n' % (self.itemValue,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('units', node)
        if value is not None and 'units' not in already_processed:
            already_processed.append('units')
            self.units = value
        value = find_attr_value_('itemCode', node)
        if value is not None and 'itemCode' not in already_processed:
            already_processed.append('itemCode')
            self.itemCode = value
        value = find_attr_value_('itemValue', node)
        if value is not None and 'itemValue' not in already_processed:
            already_processed.append('itemValue')
            self.itemValue = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class itemChoiceType


class dataInstanceType(GeneratedsSuper):
    """Indicates whether the instance has been validated (e.g. by
    reconciling double-entry instances). There should be only one
    validated instance per assessment."""
    subclass = None
    superclass = None
    def __init__(self, validated=None, assessmentInfo=None, assessmentItem=None):
        self.validated = _cast(bool, validated)
        self.assessmentInfo = assessmentInfo
        if assessmentItem is None:
            self.assessmentItem = []
        else:
            self.assessmentItem = assessmentItem
    def factory(*args_, **kwargs_):
        if dataInstanceType.subclass:
            return dataInstanceType.subclass(*args_, **kwargs_)
        else:
            return dataInstanceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_assessmentInfo(self): return self.assessmentInfo
    def set_assessmentInfo(self, assessmentInfo): self.assessmentInfo = assessmentInfo
    def get_assessmentItem(self): return self.assessmentItem
    def set_assessmentItem(self, assessmentItem): self.assessmentItem = assessmentItem
    def add_assessmentItem(self, value): self.assessmentItem.append(value)
    def insert_assessmentItem(self, index, value): self.assessmentItem[index] = value
    def get_validated(self): return self.validated
    def set_validated(self, validated): self.validated = validated
    def export(self, outfile, level, namespace_='xcede2:', name_='dataInstanceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dataInstanceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='dataInstanceType'):
        if self.validated is not None and 'validated' not in already_processed:
            already_processed.append('validated')
            outfile.write(' validated="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.validated)), input_name='validated'))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='dataInstanceType', fromsubclass_=False):
        if self.assessmentInfo is not None:
            self.assessmentInfo.export(outfile, level, namespace_, name_='assessmentInfo')
        for assessmentItem_ in self.assessmentItem:
            assessmentItem_.export(outfile, level, namespace_, name_='assessmentItem')
    def hasContent_(self):
        if (
            self.assessmentInfo is not None or
            self.assessmentItem
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dataInstanceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.validated is not None and 'validated' not in already_processed:
            already_processed.append('validated')
            showIndent(outfile, level)
            outfile.write('validated = %s,\n' % (self.validated,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.assessmentInfo is not None:
            showIndent(outfile, level)
            outfile.write('assessmentInfo=model_.assessmentInfo_t(\n')
            self.assessmentInfo.exportLiteral(outfile, level, name_='assessmentInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('assessmentItem=[\n')
        level += 1
        for assessmentItem_ in self.assessmentItem:
            showIndent(outfile, level)
            outfile.write('model_.assessmentItem_t(\n')
            assessmentItem_.exportLiteral(outfile, level, name_='assessmentItem_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('validated', node)
        if value is not None and 'validated' not in already_processed:
            already_processed.append('validated')
            if value in ('true', '1'):
                self.validated = True
            elif value in ('false', '0'):
                self.validated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'assessmentInfo':
            obj_ = assessmentInfo_t.factory()
            obj_.build(child_)
            self.set_assessmentInfo(obj_)
        elif nodeName_ == 'assessmentItem':
            obj_ = assessmentItem_t.factory()
            obj_.build(child_)
            self.assessmentItem.append(obj_)
# end class dataInstanceType


class nsOntologyAnnotation_t(abstract_annotation_t):
    subclass = None
    superclass = abstract_annotation_t
    def __init__(self, timestamp=None, author=None, term=None):
        super(nsOntologyAnnotation_t, self).__init__(timestamp, author, )
        if term is None:
            self.term = []
        else:
            self.term = term
    def factory(*args_, **kwargs_):
        if nsOntologyAnnotation_t.subclass:
            return nsOntologyAnnotation_t.subclass(*args_, **kwargs_)
        else:
            return nsOntologyAnnotation_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def add_term(self, value): self.term.append(value)
    def insert_term(self, index, value): self.term[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='nsOntologyAnnotation_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nsOntologyAnnotation_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='nsOntologyAnnotation_t'):
        super(nsOntologyAnnotation_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='nsOntologyAnnotation_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='nsOntologyAnnotation_t', fromsubclass_=False):
        super(nsOntologyAnnotation_t, self).exportChildren(outfile, level, namespace_, name_, True)
        for term_ in self.term:
            showIndent(outfile, level)
            outfile.write('<%sterm>%s</%sterm>\n' % (namespace_, self.gds_format_string(quote_xml(term_).encode(ExternalEncoding), input_name='term'), namespace_))
    def hasContent_(self):
        if (
            self.term or
            super(nsOntologyAnnotation_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nsOntologyAnnotation_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(nsOntologyAnnotation_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(nsOntologyAnnotation_t, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('term=[\n')
        level += 1
        for term_ in self.term:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(term_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(nsOntologyAnnotation_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'term':
            term_ = child_.text
            term_ = self.gds_validate_string(term_, node, 'term')
            self.term.append(term_)
        super(nsOntologyAnnotation_t, self).buildChildren(child_, node, nodeName_, True)
# end class nsOntologyAnnotation_t


class nsTermAnnotation_t(abstract_annotation_t):
    subclass = None
    superclass = abstract_annotation_t
    def __init__(self, timestamp=None, author=None, ontologyClass=None):
        super(nsTermAnnotation_t, self).__init__(timestamp, author, )
        if ontologyClass is None:
            self.ontologyClass = []
        else:
            self.ontologyClass = ontologyClass
    def factory(*args_, **kwargs_):
        if nsTermAnnotation_t.subclass:
            return nsTermAnnotation_t.subclass(*args_, **kwargs_)
        else:
            return nsTermAnnotation_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ontologyClass(self): return self.ontologyClass
    def set_ontologyClass(self, ontologyClass): self.ontologyClass = ontologyClass
    def add_ontologyClass(self, value): self.ontologyClass.append(value)
    def insert_ontologyClass(self, index, value): self.ontologyClass[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='nsTermAnnotation_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nsTermAnnotation_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='nsTermAnnotation_t'):
        super(nsTermAnnotation_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='nsTermAnnotation_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='nsTermAnnotation_t', fromsubclass_=False):
        super(nsTermAnnotation_t, self).exportChildren(outfile, level, namespace_, name_, True)
        for ontologyClass_ in self.ontologyClass:
            showIndent(outfile, level)
            outfile.write('<%sontologyClass>%s</%sontologyClass>\n' % (namespace_, self.gds_format_string(quote_xml(ontologyClass_).encode(ExternalEncoding), input_name='ontologyClass'), namespace_))
    def hasContent_(self):
        if (
            self.ontologyClass or
            super(nsTermAnnotation_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nsTermAnnotation_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(nsTermAnnotation_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(nsTermAnnotation_t, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ontologyClass=[\n')
        level += 1
        for ontologyClass_ in self.ontologyClass:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ontologyClass_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(nsTermAnnotation_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ontologyClass':
            ontologyClass_ = child_.text
            ontologyClass_ = self.gds_validate_string(ontologyClass_, node, 'ontologyClass')
            self.ontologyClass.append(ontologyClass_)
        super(nsTermAnnotation_t, self).buildChildren(child_, node, nodeName_, True)
# end class nsTermAnnotation_t


class abstract_container_t(abstract_tagged_entity_t):
    """ Revision number, should correspond with an appropriate revision ID
    in the XCEDE/revisionList elementAttribute for creating
    categories within a container set. For example, within study,
    types might include 'PET' or 'MR'. One could also create sub-
    classes using colon notation: "MR:STRUCT" """
    subclass = None
    superclass = abstract_tagged_entity_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, extensiontype_=None):
        super(abstract_container_t, self).__init__(metaFields, extensiontype_, )
        self.termPath = _cast(None, termPath)
        self.rev = _cast(None, rev)
        self.nomenclature = _cast(None, nomenclature)
        self.abbreviation = _cast(None, abbreviation)
        self.preferredLabel = _cast(None, preferredLabel)
        self.termID = _cast(None, termID)
        self.type_ = _cast(None, type_)
        self.ID = _cast(None, ID)
        self.commentList = commentList
        self.annotationList = annotationList
        self.resourceList = resourceList
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstract_container_t.subclass:
            return abstract_container_t.subclass(*args_, **kwargs_)
        else:
            return abstract_container_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_commentList(self): return self.commentList
    def set_commentList(self, commentList): self.commentList = commentList
    def get_annotationList(self): return self.annotationList
    def set_annotationList(self, annotationList): self.annotationList = annotationList
    def get_resourceList(self): return self.resourceList
    def set_resourceList(self, resourceList): self.resourceList = resourceList
    def get_termPath(self): return self.termPath
    def set_termPath(self, termPath): self.termPath = termPath
    def get_rev(self): return self.rev
    def set_rev(self, rev): self.rev = rev
    def get_nomenclature(self): return self.nomenclature
    def set_nomenclature(self, nomenclature): self.nomenclature = nomenclature
    def get_abbreviation(self): return self.abbreviation
    def set_abbreviation(self, abbreviation): self.abbreviation = abbreviation
    def get_preferredLabel(self): return self.preferredLabel
    def set_preferredLabel(self, preferredLabel): self.preferredLabel = preferredLabel
    def get_termID(self): return self.termID
    def set_termID(self, termID): self.termID = termID
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_container_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_container_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_container_t'):
        super(abstract_container_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_container_t')
        if self.termPath is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            outfile.write(' termPath=%s' % (self.gds_format_string(quote_attrib(self.termPath).encode(ExternalEncoding), input_name='termPath'), ))
        if self.rev is not None and 'rev' not in already_processed:
            already_processed.append('rev')
            outfile.write(' rev=%s' % (self.gds_format_string(quote_attrib(self.rev).encode(ExternalEncoding), input_name='rev'), ))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            outfile.write(' nomenclature=%s' % (self.gds_format_string(quote_attrib(self.nomenclature).encode(ExternalEncoding), input_name='nomenclature'), ))
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            outfile.write(' abbreviation=%s' % (self.gds_format_string(quote_attrib(self.abbreviation).encode(ExternalEncoding), input_name='abbreviation'), ))
        if self.preferredLabel is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            outfile.write(' preferredLabel=%s' % (self.gds_format_string(quote_attrib(self.preferredLabel).encode(ExternalEncoding), input_name='preferredLabel'), ))
        if self.termID is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            outfile.write(' termID=%s' % (self.gds_format_string(quote_attrib(self.termID).encode(ExternalEncoding), input_name='termID'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_container_t', fromsubclass_=False):
        super(abstract_container_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.commentList is not None:
            self.commentList.export(outfile, level, namespace_, name_='commentList')
        if self.annotationList is not None:
            self.annotationList.export(outfile, level, namespace_, name_='annotationList')
        if self.resourceList is not None:
            self.resourceList.export(outfile, level, namespace_, name_='resourceList')
    def hasContent_(self):
        if (
            self.commentList is not None or
            self.annotationList is not None or
            self.resourceList is not None or
            super(abstract_container_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_container_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.termPath is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            showIndent(outfile, level)
            outfile.write('termPath = "%s",\n' % (self.termPath,))
        if self.rev is not None and 'rev' not in already_processed:
            already_processed.append('rev')
            showIndent(outfile, level)
            outfile.write('rev = "%s",\n' % (self.rev,))
        if self.nomenclature is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            showIndent(outfile, level)
            outfile.write('nomenclature = "%s",\n' % (self.nomenclature,))
        if self.abbreviation is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            showIndent(outfile, level)
            outfile.write('abbreviation = "%s",\n' % (self.abbreviation,))
        if self.preferredLabel is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            showIndent(outfile, level)
            outfile.write('preferredLabel = "%s",\n' % (self.preferredLabel,))
        if self.termID is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            showIndent(outfile, level)
            outfile.write('termID = "%s",\n' % (self.termID,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        super(abstract_container_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(abstract_container_t, self).exportLiteralChildren(outfile, level, name_)
        if self.commentList is not None:
            showIndent(outfile, level)
            outfile.write('commentList=model_.commentListType(\n')
            self.commentList.exportLiteral(outfile, level, name_='commentList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.annotationList is not None:
            showIndent(outfile, level)
            outfile.write('annotationList=model_.annotationListType1(\n')
            self.annotationList.exportLiteral(outfile, level, name_='annotationList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resourceList is not None:
            showIndent(outfile, level)
            outfile.write('resourceList=model_.resourceListType(\n')
            self.resourceList.exportLiteral(outfile, level, name_='resourceList')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('termPath', node)
        if value is not None and 'termPath' not in already_processed:
            already_processed.append('termPath')
            self.termPath = value
        value = find_attr_value_('rev', node)
        if value is not None and 'rev' not in already_processed:
            already_processed.append('rev')
            self.rev = value
        value = find_attr_value_('nomenclature', node)
        if value is not None and 'nomenclature' not in already_processed:
            already_processed.append('nomenclature')
            self.nomenclature = value
        value = find_attr_value_('abbreviation', node)
        if value is not None and 'abbreviation' not in already_processed:
            already_processed.append('abbreviation')
            self.abbreviation = value
        value = find_attr_value_('preferredLabel', node)
        if value is not None and 'preferredLabel' not in already_processed:
            already_processed.append('preferredLabel')
            self.preferredLabel = value
        value = find_attr_value_('termID', node)
        if value is not None and 'termID' not in already_processed:
            already_processed.append('termID')
            self.termID = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(abstract_container_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'commentList':
            obj_ = commentListType.factory()
            obj_.build(child_)
            self.set_commentList(obj_)
        elif nodeName_ == 'annotationList':
            obj_ = annotationListType1.factory()
            obj_.build(child_)
            self.set_annotationList(obj_)
        elif nodeName_ == 'resourceList':
            obj_ = resourceListType.factory()
            obj_.build(child_)
            self.set_resourceList(obj_)
        super(abstract_container_t, self).buildChildren(child_, node, nodeName_, True)
# end class abstract_container_t


class abstract_process_t(abstract_container_t):
    """If this level is modeled as a Activity in an PROV container, this is
    the ID of that activity element."""
    subclass = None
    superclass = abstract_container_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provActivityID=None, extensiontype_=None):
        super(abstract_process_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, extensiontype_, )
        self.provActivityID = _cast(None, provActivityID)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstract_process_t.subclass:
            return abstract_process_t.subclass(*args_, **kwargs_)
        else:
            return abstract_process_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_provActivityID(self): return self.provActivityID
    def set_provActivityID(self, provActivityID): self.provActivityID = provActivityID
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_process_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_process_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_process_t'):
        super(abstract_process_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_process_t')
        if self.provActivityID is not None and 'provActivityID' not in already_processed:
            already_processed.append('provActivityID')
            outfile.write(' provActivityID=%s' % (quote_attrib(self.provActivityID), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_process_t', fromsubclass_=False):
        super(abstract_process_t, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(abstract_process_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_process_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provActivityID is not None and 'provActivityID' not in already_processed:
            already_processed.append('provActivityID')
            showIndent(outfile, level)
            outfile.write('provActivityID = %s,\n' % (self.provActivityID,))
        super(abstract_process_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(abstract_process_t, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provActivityID', node)
        if value is not None and 'provActivityID' not in already_processed:
            already_processed.append('provActivityID')
            self.provActivityID = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(abstract_process_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(abstract_process_t, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class abstract_process_t


class abstract_data_t(abstract_container_t):
    """If this data is modeled as an Entity in an PROV container, this is
    the ID of that entity element."""
    subclass = None
    superclass = abstract_container_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provEntityID=None, level=None, extensiontype_=None):
        super(abstract_data_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, extensiontype_, )
        self.provEntityID = _cast(None, provEntityID)
        self.level = _cast(None, level)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstract_data_t.subclass:
            return abstract_data_t.subclass(*args_, **kwargs_)
        else:
            return abstract_data_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_provEntityID(self): return self.provEntityID
    def set_provEntityID(self, provEntityID): self.provEntityID = provEntityID
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def validate_levelDescriptor_t(self, value):
        # Validate type levelDescriptor_t, a restriction on xs:string.
        pass
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_data_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_data_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_data_t'):
        super(abstract_data_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_data_t')
        if self.provEntityID is not None and 'provEntityID' not in already_processed:
            already_processed.append('provEntityID')
            outfile.write(' provEntityID=%s' % (quote_attrib(self.provEntityID), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_data_t', fromsubclass_=False):
        super(abstract_data_t, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(abstract_data_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_data_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.provEntityID is not None and 'provEntityID' not in already_processed:
            already_processed.append('provEntityID')
            showIndent(outfile, level)
            outfile.write('provEntityID = %s,\n' % (self.provEntityID,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = "%s",\n' % (self.level,))
        super(abstract_data_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(abstract_data_t, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('provEntityID', node)
        if value is not None and 'provEntityID' not in already_processed:
            already_processed.append('provEntityID')
            self.provEntityID = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
            self.validate_levelDescriptor_t(self.level)    # validate type levelDescriptor_t
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(abstract_data_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(abstract_data_t, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class abstract_data_t


class resource_t(abstract_tagged_entity_t):
    """Format of file. E.g. DICOM, Analyze, 4dfpCode indicating the
    contents of the image. E.g. GFC, T88If this resource is modeled
    as an Entity in a PROV container, this is the ID of that entity
    element."""
    subclass = None
    superclass = abstract_tagged_entity_t
    def __init__(self, metaFields=None, dataID=None, description=None, format=None, dataURI=None, cachePath=None, level=None, content=None, provEntityID=None, analysisURI=None, analysisID=None, ID=None, name=None, uri=None, extensiontype_=None):
        super(resource_t, self).__init__(metaFields, extensiontype_, )
        self.dataID = _cast(None, dataID)
        self.description = _cast(None, description)
        self.format = _cast(None, format)
        self.dataURI = _cast(None, dataURI)
        self.cachePath = _cast(None, cachePath)
        self.level = _cast(None, level)
        self.content = _cast(None, content)
        self.provEntityID = _cast(None, provEntityID)
        self.analysisURI = _cast(None, analysisURI)
        self.analysisID = _cast(None, analysisID)
        self.ID = _cast(None, ID)
        self.name = _cast(None, name)
        if uri is None:
            self.uri = []
        else:
            self.uri = uri
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if resource_t.subclass:
            return resource_t.subclass(*args_, **kwargs_)
        else:
            return resource_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def add_uri(self, value): self.uri.append(value)
    def insert_uri(self, index, value): self.uri[index] = value
    def get_dataID(self): return self.dataID
    def set_dataID(self, dataID): self.dataID = dataID
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_dataURI(self): return self.dataURI
    def set_dataURI(self, dataURI): self.dataURI = dataURI
    def get_cachePath(self): return self.cachePath
    def set_cachePath(self, cachePath): self.cachePath = cachePath
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def validate_levelDescriptor_t(self, value):
        # Validate type levelDescriptor_t, a restriction on xs:string.
        pass
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_provEntityID(self): return self.provEntityID
    def set_provEntityID(self, provEntityID): self.provEntityID = provEntityID
    def get_analysisURI(self): return self.analysisURI
    def set_analysisURI(self, analysisURI): self.analysisURI = analysisURI
    def get_analysisID(self): return self.analysisID
    def set_analysisID(self, analysisID): self.analysisID = analysisID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='resource_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resource_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='resource_t'):
        super(resource_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='resource_t')
        if self.dataID is not None and 'dataID' not in already_processed:
            already_processed.append('dataID')
            outfile.write(' dataID=%s' % (self.gds_format_string(quote_attrib(self.dataID).encode(ExternalEncoding), input_name='dataID'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.format is not None and 'format' not in already_processed:
            already_processed.append('format')
            outfile.write(' format=%s' % (self.gds_format_string(quote_attrib(self.format).encode(ExternalEncoding), input_name='format'), ))
        if self.dataURI is not None and 'dataURI' not in already_processed:
            already_processed.append('dataURI')
            outfile.write(' dataURI=%s' % (self.gds_format_string(quote_attrib(self.dataURI).encode(ExternalEncoding), input_name='dataURI'), ))
        if self.cachePath is not None and 'cachePath' not in already_processed:
            already_processed.append('cachePath')
            outfile.write(' cachePath=%s' % (self.gds_format_string(quote_attrib(self.cachePath).encode(ExternalEncoding), input_name='cachePath'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.content is not None and 'content' not in already_processed:
            already_processed.append('content')
            outfile.write(' content=%s' % (self.gds_format_string(quote_attrib(self.content).encode(ExternalEncoding), input_name='content'), ))
        if self.provEntityID is not None and 'provEntityID' not in already_processed:
            already_processed.append('provEntityID')
            outfile.write(' provEntityID=%s' % (quote_attrib(self.provEntityID), ))
        if self.analysisURI is not None and 'analysisURI' not in already_processed:
            already_processed.append('analysisURI')
            outfile.write(' analysisURI=%s' % (self.gds_format_string(quote_attrib(self.analysisURI).encode(ExternalEncoding), input_name='analysisURI'), ))
        if self.analysisID is not None and 'analysisID' not in already_processed:
            already_processed.append('analysisID')
            outfile.write(' analysisID=%s' % (self.gds_format_string(quote_attrib(self.analysisID).encode(ExternalEncoding), input_name='analysisID'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='resource_t', fromsubclass_=False):
        super(resource_t, self).exportChildren(outfile, level, namespace_, name_, True)
        for uri_ in self.uri:
            uri_.export(outfile, level, namespace_, name_='uri')
    def hasContent_(self):
        if (
            self.uri or
            super(resource_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='resource_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dataID is not None and 'dataID' not in already_processed:
            already_processed.append('dataID')
            showIndent(outfile, level)
            outfile.write('dataID = "%s",\n' % (self.dataID,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.format is not None and 'format' not in already_processed:
            already_processed.append('format')
            showIndent(outfile, level)
            outfile.write('format = "%s",\n' % (self.format,))
        if self.dataURI is not None and 'dataURI' not in already_processed:
            already_processed.append('dataURI')
            showIndent(outfile, level)
            outfile.write('dataURI = "%s",\n' % (self.dataURI,))
        if self.cachePath is not None and 'cachePath' not in already_processed:
            already_processed.append('cachePath')
            showIndent(outfile, level)
            outfile.write('cachePath = "%s",\n' % (self.cachePath,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = "%s",\n' % (self.level,))
        if self.content is not None and 'content' not in already_processed:
            already_processed.append('content')
            showIndent(outfile, level)
            outfile.write('content = "%s",\n' % (self.content,))
        if self.provEntityID is not None and 'provEntityID' not in already_processed:
            already_processed.append('provEntityID')
            showIndent(outfile, level)
            outfile.write('provEntityID = %s,\n' % (self.provEntityID,))
        if self.analysisURI is not None and 'analysisURI' not in already_processed:
            already_processed.append('analysisURI')
            showIndent(outfile, level)
            outfile.write('analysisURI = "%s",\n' % (self.analysisURI,))
        if self.analysisID is not None and 'analysisID' not in already_processed:
            already_processed.append('analysisID')
            showIndent(outfile, level)
            outfile.write('analysisID = "%s",\n' % (self.analysisID,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        super(resource_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(resource_t, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('uri=[\n')
        level += 1
        for uri_ in self.uri:
            showIndent(outfile, level)
            outfile.write('model_.frag_uri_t(\n')
            uri_.exportLiteral(outfile, level, name_='frag_uri_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataID', node)
        if value is not None and 'dataID' not in already_processed:
            already_processed.append('dataID')
            self.dataID = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.append('format')
            self.format = value
        value = find_attr_value_('dataURI', node)
        if value is not None and 'dataURI' not in already_processed:
            already_processed.append('dataURI')
            self.dataURI = value
        value = find_attr_value_('cachePath', node)
        if value is not None and 'cachePath' not in already_processed:
            already_processed.append('cachePath')
            self.cachePath = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
            self.validate_levelDescriptor_t(self.level)    # validate type levelDescriptor_t
        value = find_attr_value_('content', node)
        if value is not None and 'content' not in already_processed:
            already_processed.append('content')
            self.content = value
        value = find_attr_value_('provEntityID', node)
        if value is not None and 'provEntityID' not in already_processed:
            already_processed.append('provEntityID')
            self.provEntityID = value
        value = find_attr_value_('analysisURI', node)
        if value is not None and 'analysisURI' not in already_processed:
            already_processed.append('analysisURI')
            self.analysisURI = value
        value = find_attr_value_('analysisID', node)
        if value is not None and 'analysisID' not in already_processed:
            already_processed.append('analysisID')
            self.analysisID = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(resource_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'uri':
            obj_ = frag_uri_t.factory()
            obj_.build(child_)
            self.uri.append(obj_)
        super(resource_t, self).buildChildren(child_, node, nodeName_, True)
# end class resource_t


class catalog_t(abstract_tagged_entity_t):
    subclass = None
    superclass = abstract_tagged_entity_t
    def __init__(self, metaFields=None, level=None, description=None, name=None, ID=None, catalogList=None, entryList=None):
        super(catalog_t, self).__init__(metaFields, )
        self.level = _cast(None, level)
        self.description = _cast(None, description)
        self.name = _cast(None, name)
        self.ID = _cast(None, ID)
        self.catalogList = catalogList
        self.entryList = entryList
    def factory(*args_, **kwargs_):
        if catalog_t.subclass:
            return catalog_t.subclass(*args_, **kwargs_)
        else:
            return catalog_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_catalogList(self): return self.catalogList
    def set_catalogList(self, catalogList): self.catalogList = catalogList
    def get_entryList(self): return self.entryList
    def set_entryList(self, entryList): self.entryList = entryList
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def validate_levelDescriptor_t(self, value):
        # Validate type levelDescriptor_t, a restriction on xs:string.
        pass
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def export(self, outfile, level, namespace_='xcede2:', name_='catalog_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='catalog_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='catalog_t'):
        super(catalog_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='catalog_t')
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            outfile.write(' ID=%s' % (self.gds_format_string(quote_attrib(self.ID).encode(ExternalEncoding), input_name='ID'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='catalog_t', fromsubclass_=False):
        super(catalog_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.catalogList is not None:
            self.catalogList.export(outfile, level, namespace_, name_='catalogList')
        if self.entryList is not None:
            self.entryList.export(outfile, level, namespace_, name_='entryList')
    def hasContent_(self):
        if (
            self.catalogList is not None or
            self.entryList is not None or
            super(catalog_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='catalog_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = "%s",\n' % (self.level,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.ID is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            showIndent(outfile, level)
            outfile.write('ID = "%s",\n' % (self.ID,))
        super(catalog_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(catalog_t, self).exportLiteralChildren(outfile, level, name_)
        if self.catalogList is not None:
            showIndent(outfile, level)
            outfile.write('catalogList=model_.catalogListType(\n')
            self.catalogList.exportLiteral(outfile, level, name_='catalogList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.entryList is not None:
            showIndent(outfile, level)
            outfile.write('entryList=model_.entryListType(\n')
            self.entryList.exportLiteral(outfile, level, name_='entryList')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
            self.validate_levelDescriptor_t(self.level)    # validate type levelDescriptor_t
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('ID', node)
        if value is not None and 'ID' not in already_processed:
            already_processed.append('ID')
            self.ID = value
        super(catalog_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'catalogList':
            obj_ = catalogListType.factory()
            obj_.build(child_)
            self.set_catalogList(obj_)
        elif nodeName_ == 'entryList':
            obj_ = entryListType.factory()
            obj_.build(child_)
            self.set_entryList(obj_)
        super(catalog_t, self).buildChildren(child_, node, nodeName_, True)
# end class catalog_t


class protocol_t(abstract_protocol_t):
    subclass = None
    superclass = abstract_protocol_t
    def __init__(self, termPath=None, description=None, maxOccurences=None, required=None, nomenclature=None, minOccurences=None, abbreviation=None, preferredLabel=None, termID=None, level=None, ID=None, name=None, protocolOffset=None, steps=None, items=None):
        super(protocol_t, self).__init__(termPath, description, maxOccurences, required, nomenclature, minOccurences, abbreviation, preferredLabel, termID, level, ID, name, protocolOffset, )
        self.steps = steps
        self.items = items
    def factory(*args_, **kwargs_):
        if protocol_t.subclass:
            return protocol_t.subclass(*args_, **kwargs_)
        else:
            return protocol_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_steps(self): return self.steps
    def set_steps(self, steps): self.steps = steps
    def get_items(self): return self.items
    def set_items(self, items): self.items = items
    def export(self, outfile, level, namespace_='xcede2:', name_='protocol_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='protocol_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='protocol_t'):
        super(protocol_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='protocol_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='protocol_t', fromsubclass_=False):
        super(protocol_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.steps is not None:
            self.steps.export(outfile, level, namespace_, name_='steps')
        if self.items is not None:
            self.items.export(outfile, level, namespace_, name_='items')
    def hasContent_(self):
        if (
            self.steps is not None or
            self.items is not None or
            super(protocol_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='protocol_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(protocol_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(protocol_t, self).exportLiteralChildren(outfile, level, name_)
        if self.steps is not None:
            showIndent(outfile, level)
            outfile.write('steps=model_.stepsType(\n')
            self.steps.exportLiteral(outfile, level, name_='steps')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.items is not None:
            showIndent(outfile, level)
            outfile.write('items=model_.itemsType(\n')
            self.items.exportLiteral(outfile, level, name_='items')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(protocol_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'steps':
            obj_ = stepsType.factory()
            obj_.build(child_)
            self.set_steps(obj_)
        elif nodeName_ == 'items':
            obj_ = itemsType.factory()
            obj_.build(child_)
            self.set_items(obj_)
        super(protocol_t, self).buildChildren(child_, node, nodeName_, True)
# end class protocol_t


class analysis_t(abstract_process_t):
    """A collection of output from an analysis of data."""
    subclass = None
    superclass = abstract_process_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provActivityID=None, level=None, provenance=None, input=None, output=None, measurementGroup=None):
        super(analysis_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, provActivityID, )
        self.level = _cast(None, level)
        if provenance is None:
            self.provenance = []
        else:
            self.provenance = provenance
        if input is None:
            self.input = []
        else:
            self.input = input
        if output is None:
            self.output = []
        else:
            self.output = output
        if measurementGroup is None:
            self.measurementGroup = []
        else:
            self.measurementGroup = measurementGroup
    def factory(*args_, **kwargs_):
        if analysis_t.subclass:
            return analysis_t.subclass(*args_, **kwargs_)
        else:
            return analysis_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_provenance(self): return self.provenance
    def set_provenance(self, provenance): self.provenance = provenance
    def add_provenance(self, value): self.provenance.append(value)
    def insert_provenance(self, index, value): self.provenance[index] = value
    def get_input(self): return self.input
    def set_input(self, input): self.input = input
    def add_input(self, value): self.input.append(value)
    def insert_input(self, index, value): self.input[index] = value
    def get_output(self): return self.output
    def set_output(self, output): self.output = output
    def add_output(self, value): self.output.append(value)
    def insert_output(self, index, value): self.output[index] = value
    def get_measurementGroup(self): return self.measurementGroup
    def set_measurementGroup(self, measurementGroup): self.measurementGroup = measurementGroup
    def add_measurementGroup(self, value): self.measurementGroup.append(value)
    def insert_measurementGroup(self, index, value): self.measurementGroup[index] = value
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def validate_levelDescriptor_t(self, value):
        # Validate type levelDescriptor_t, a restriction on xs:string.
        pass
    def export(self, outfile, level, namespace_='xcede2:', name_='analysis_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='analysis_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='analysis_t'):
        super(analysis_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='analysis_t')
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='analysis_t', fromsubclass_=False):
        super(analysis_t, self).exportChildren(outfile, level, namespace_, name_, True)
        for provenance_ in self.provenance:
            provenance_.export(outfile, level, namespace_, name_='provenance')
        for input_ in self.input:
            input_.export(outfile, level, namespace_, name_='input')
        for output_ in self.output:
            output_.export(outfile, level, namespace_, name_='output')
        for measurementGroup_ in self.measurementGroup:
            measurementGroup_.export(outfile, level, namespace_, name_='measurementGroup')
    def hasContent_(self):
        if (
            self.provenance or
            self.input or
            self.output or
            self.measurementGroup or
            super(analysis_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='analysis_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.level is not None and 'level' not in already_processed:
            already_processed.append('level')
            showIndent(outfile, level)
            outfile.write('level = "%s",\n' % (self.level,))
        super(analysis_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(analysis_t, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('provenance=[\n')
        level += 1
        for provenance_ in self.provenance:
            showIndent(outfile, level)
            outfile.write('model_.provenance_t(\n')
            provenance_.exportLiteral(outfile, level, name_='provenance_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('input=[\n')
        level += 1
        for input_ in self.input:
            showIndent(outfile, level)
            outfile.write('model_.levelDataRefs_t(\n')
            input_.exportLiteral(outfile, level, name_='levelDataRefs_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('output=[\n')
        level += 1
        for output_ in self.output:
            showIndent(outfile, level)
            outfile.write('model_.levelDataRefs_t(\n')
            output_.exportLiteral(outfile, level, name_='levelDataRefs_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('measurementGroup=[\n')
        level += 1
        for measurementGroup_ in self.measurementGroup:
            showIndent(outfile, level)
            outfile.write('model_.measurementGroup_t(\n')
            measurementGroup_.exportLiteral(outfile, level, name_='measurementGroup_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.append('level')
            self.level = value
            self.validate_levelDescriptor_t(self.level)    # validate type levelDescriptor_t
        super(analysis_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'provenance':
            obj_ = provenance_t.factory()
            obj_.build(child_)
            self.provenance.append(obj_)
        elif nodeName_ == 'input':
            obj_ = levelDataRefs_t.factory()
            obj_.build(child_)
            self.input.append(obj_)
        elif nodeName_ == 'output':
            obj_ = levelDataRefs_t.factory()
            obj_.build(child_)
            self.output.append(obj_)
        elif nodeName_ == 'measurementGroup':
            obj_ = measurementGroup_t.factory()
            obj_.build(child_)
            self.measurementGroup.append(obj_)
        super(analysis_t, self).buildChildren(child_, node, nodeName_, True)
# end class analysis_t


class subject_t(abstract_container_t):
    subclass = None
    superclass = abstract_container_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, subjectInfo=None):
        super(subject_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, )
        self.subjectInfo = subjectInfo
    def factory(*args_, **kwargs_):
        if subject_t.subclass:
            return subject_t.subclass(*args_, **kwargs_)
        else:
            return subject_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subjectInfo(self): return self.subjectInfo
    def set_subjectInfo(self, subjectInfo): self.subjectInfo = subjectInfo
    def export(self, outfile, level, namespace_='xcede2:', name_='subject_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='subject_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='subject_t'):
        super(subject_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='subject_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='subject_t', fromsubclass_=False):
        super(subject_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.subjectInfo is not None:
            self.subjectInfo.export(outfile, level, namespace_, name_='subjectInfo')
    def hasContent_(self):
        if (
            self.subjectInfo is not None or
            super(subject_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='subject_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(subject_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(subject_t, self).exportLiteralChildren(outfile, level, name_)
        if self.subjectInfo is not None:
            showIndent(outfile, level)
            outfile.write('subjectInfo=model_.subjectInfo_t(\n')
            self.subjectInfo.exportLiteral(outfile, level, name_='subjectInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(subject_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subjectInfo':
            obj_ = subjectInfo_t.factory()
            obj_.build(child_)
            self.set_subjectInfo(obj_)
        super(subject_t, self).buildChildren(child_, node, nodeName_, True)
# end class subject_t


class measurementGroup_t(abstract_container_t):
    """A measurementGroup contains information and data related to the
    outcome of an analysis. For example, this could be a statistic
    (e.g. from a Statistical Parametric Map) or a measurement (e.g.
    the volume of the hippocmapus)."""
    subclass = None
    superclass = abstract_container_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, entity=None, observation=None):
        super(measurementGroup_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, )
        if entity is None:
            self.entity = []
        else:
            self.entity = entity
        if observation is None:
            self.observation = []
        else:
            self.observation = observation
    def factory(*args_, **kwargs_):
        if measurementGroup_t.subclass:
            return measurementGroup_t.subclass(*args_, **kwargs_)
        else:
            return measurementGroup_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def add_entity(self, value): self.entity.append(value)
    def insert_entity(self, index, value): self.entity[index] = value
    def get_observation(self): return self.observation
    def set_observation(self, observation): self.observation = observation
    def add_observation(self, value): self.observation.append(value)
    def insert_observation(self, index, value): self.observation[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='measurementGroup_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='measurementGroup_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='measurementGroup_t'):
        super(measurementGroup_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='measurementGroup_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='measurementGroup_t', fromsubclass_=False):
        super(measurementGroup_t, self).exportChildren(outfile, level, namespace_, name_, True)
        for entity_ in self.get_entity():
            entity_.export(outfile, level, namespace_, name_='entity')
        for observation_ in self.observation:
            observation_.export(outfile, level, namespace_, name_='observation')
    def hasContent_(self):
        if (
            self.entity or
            self.observation or
            super(measurementGroup_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='measurementGroup_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(measurementGroup_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(measurementGroup_t, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('entity=[\n')
        level += 1
        for entity_ in self.entity:
            showIndent(outfile, level)
            outfile.write('model_.abstract_entity_t(\n')
            entity_.exportLiteral(outfile, level, name_='abstract_entity_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('observation=[\n')
        level += 1
        for observation_ in self.observation:
            showIndent(outfile, level)
            outfile.write('model_.observation_t(\n')
            observation_.exportLiteral(outfile, level, name_='observation_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(measurementGroup_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entity':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <entity> element')
            self.entity.append(obj_)
        elif nodeName_ == 'observation':
            obj_ = observation_t.factory()
            obj_.build(child_)
            self.observation.append(obj_)
        super(measurementGroup_t, self).buildChildren(child_, node, nodeName_, True)
# end class measurementGroup_t


class assessment_t(abstract_data_t):
    subclass = None
    superclass = abstract_data_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provEntityID=None, level=None, name=None, dataInstance=None, annotation=None):
        super(assessment_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, provEntityID, level, )
        self.name = name
        if dataInstance is None:
            self.dataInstance = []
        else:
            self.dataInstance = dataInstance
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
    def factory(*args_, **kwargs_):
        if assessment_t.subclass:
            return assessment_t.subclass(*args_, **kwargs_)
        else:
            return assessment_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_dataInstance(self): return self.dataInstance
    def set_dataInstance(self, dataInstance): self.dataInstance = dataInstance
    def add_dataInstance(self, value): self.dataInstance.append(value)
    def insert_dataInstance(self, index, value): self.dataInstance[index] = value
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def add_annotation(self, value): self.annotation.append(value)
    def insert_annotation(self, index, value): self.annotation[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='assessment_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='assessment_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='assessment_t'):
        super(assessment_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='assessment_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='assessment_t', fromsubclass_=False):
        super(assessment_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        for dataInstance_ in self.dataInstance:
            dataInstance_.export(outfile, level, namespace_, name_='dataInstance')
        for annotation_ in self.annotation:
            annotation_.export(outfile, level, namespace_, name_='annotation')
    def hasContent_(self):
        if (
            self.name is not None or
            self.dataInstance or
            self.annotation or
            super(assessment_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='assessment_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(assessment_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(assessment_t, self).exportLiteralChildren(outfile, level, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('dataInstance=[\n')
        level += 1
        for dataInstance_ in self.dataInstance:
            showIndent(outfile, level)
            outfile.write('model_.dataInstanceType(\n')
            dataInstance_.exportLiteral(outfile, level, name_='dataInstanceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('annotation=[\n')
        level += 1
        for annotation_ in self.annotation:
            showIndent(outfile, level)
            outfile.write('model_.textAnnotation_t(\n')
            annotation_.exportLiteral(outfile, level, name_='textAnnotation_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(assessment_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'dataInstance':
            obj_ = dataInstanceType.factory()
            obj_.build(child_)
            self.dataInstance.append(obj_)
        elif nodeName_ == 'annotation':
            obj_ = textAnnotation_t.factory()
            obj_.build(child_)
            self.annotation.append(obj_)
        super(assessment_t, self).buildChildren(child_, node, nodeName_, True)
# end class assessment_t


class events_t(abstract_data_t):
    subclass = None
    superclass = abstract_data_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provEntityID=None, level=None, params=None, event=None, description=None, annotation=None):
        super(events_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, provEntityID, level, )
        self.params = params
        if event is None:
            self.event = []
        else:
            self.event = event
        self.description = description
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
    def factory(*args_, **kwargs_):
        if events_t.subclass:
            return events_t.subclass(*args_, **kwargs_)
        else:
            return events_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_params(self): return self.params
    def set_params(self, params): self.params = params
    def get_event(self): return self.event
    def set_event(self, event): self.event = event
    def add_event(self, value): self.event.append(value)
    def insert_event(self, index, value): self.event[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def add_annotation(self, value): self.annotation.append(value)
    def insert_annotation(self, index, value): self.annotation[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='events_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='events_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='events_t'):
        super(events_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='events_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='events_t', fromsubclass_=False):
        super(events_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.params is not None:
            self.params.export(outfile, level, namespace_, name_='params')
        for event_ in self.event:
            event_.export(outfile, level, namespace_, name_='event')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        for annotation_ in self.annotation:
            annotation_.export(outfile, level, namespace_, name_='annotation')
    def hasContent_(self):
        if (
            self.params is not None or
            self.event or
            self.description is not None or
            self.annotation or
            super(events_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='events_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(events_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(events_t, self).exportLiteralChildren(outfile, level, name_)
        if self.params is not None:
            showIndent(outfile, level)
            outfile.write('params=model_.eventParams_t(\n')
            self.params.exportLiteral(outfile, level, name_='params')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('event=[\n')
        level += 1
        for event_ in self.event:
            showIndent(outfile, level)
            outfile.write('model_.event_t(\n')
            event_.exportLiteral(outfile, level, name_='event_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('annotation=[\n')
        level += 1
        for annotation_ in self.annotation:
            showIndent(outfile, level)
            outfile.write('model_.textAnnotation_t(\n')
            annotation_.exportLiteral(outfile, level, name_='textAnnotation_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(events_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'params':
            obj_ = eventParams_t.factory()
            obj_.build(child_)
            self.set_params(obj_)
        elif nodeName_ == 'event':
            obj_ = event_t.factory()
            obj_.build(child_)
            self.event.append(obj_)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'annotation':
            obj_ = textAnnotation_t.factory()
            obj_.build(child_)
            self.annotation.append(obj_)
        super(events_t, self).buildChildren(child_, node, nodeName_, True)
# end class events_t


class dataResource_t(resource_t):
    subclass = None
    superclass = resource_t
    def __init__(self, metaFields=None, dataID=None, description=None, format=None, dataURI=None, cachePath=None, level=None, content=None, provEntityID=None, analysisURI=None, analysisID=None, ID=None, name=None, uri=None, provenance=None, extensiontype_=None):
        super(dataResource_t, self).__init__(metaFields, dataID, description, format, dataURI, cachePath, level, content, provEntityID, analysisURI, analysisID, ID, name, uri, extensiontype_, )
        self.provenance = provenance
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if dataResource_t.subclass:
            return dataResource_t.subclass(*args_, **kwargs_)
        else:
            return dataResource_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_provenance(self): return self.provenance
    def set_provenance(self, provenance): self.provenance = provenance
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='dataResource_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dataResource_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='dataResource_t'):
        super(dataResource_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dataResource_t')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='dataResource_t', fromsubclass_=False):
        super(dataResource_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.provenance is not None:
            self.provenance.export(outfile, level, namespace_, name_='provenance')
    def hasContent_(self):
        if (
            self.provenance is not None or
            super(dataResource_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dataResource_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(dataResource_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(dataResource_t, self).exportLiteralChildren(outfile, level, name_)
        if self.provenance is not None:
            showIndent(outfile, level)
            outfile.write('provenance=model_.provenance_t(\n')
            self.provenance.exportLiteral(outfile, level, name_='provenance')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(dataResource_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'provenance':
            obj_ = provenance_t.factory()
            obj_.build(child_)
            self.set_provenance(obj_)
        super(dataResource_t, self).buildChildren(child_, node, nodeName_, True)
# end class dataResource_t


class informationResource_t(resource_t):
    subclass = None
    superclass = resource_t
    def __init__(self, metaFields=None, dataID=None, description=None, format=None, dataURI=None, cachePath=None, level=None, content=None, provEntityID=None, analysisURI=None, analysisID=None, ID=None, name=None, uri=None, extensiontype_=None):
        super(informationResource_t, self).__init__(metaFields, dataID, description, format, dataURI, cachePath, level, content, provEntityID, analysisURI, analysisID, ID, name, uri, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if informationResource_t.subclass:
            return informationResource_t.subclass(*args_, **kwargs_)
        else:
            return informationResource_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='informationResource_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='informationResource_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='informationResource_t'):
        super(informationResource_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='informationResource_t')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='informationResource_t', fromsubclass_=False):
        super(informationResource_t, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(informationResource_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='informationResource_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(informationResource_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(informationResource_t, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(informationResource_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(informationResource_t, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class informationResource_t


class abstract_level_t(abstract_process_t):
    subclass = None
    superclass = abstract_process_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provActivityID=None, extensiontype_=None):
        super(abstract_level_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, provActivityID, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if abstract_level_t.subclass:
            return abstract_level_t.subclass(*args_, **kwargs_)
        else:
            return abstract_level_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='abstract_level_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_level_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='abstract_level_t'):
        super(abstract_level_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='abstract_level_t')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='abstract_level_t', fromsubclass_=False):
        super(abstract_level_t, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(abstract_level_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='abstract_level_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(abstract_level_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(abstract_level_t, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(abstract_level_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(abstract_level_t, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class abstract_level_t


class acquisition_t(abstract_level_t):
    subclass = None
    superclass = abstract_level_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provActivityID=None, acquisitionProtocol=None, acquisitionInfo=None, dataResourceRef=None, dataRef=None, anytypeobjs_=None):
        super(acquisition_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, provActivityID, )
        self.acquisitionProtocol = _cast(None, acquisitionProtocol)
        self.acquisitionInfo = acquisitionInfo
        self.dataResourceRef = dataResourceRef
        self.dataRef = dataRef
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if acquisition_t.subclass:
            return acquisition_t.subclass(*args_, **kwargs_)
        else:
            return acquisition_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_acquisitionInfo(self): return self.acquisitionInfo
    def set_acquisitionInfo(self, acquisitionInfo): self.acquisitionInfo = acquisitionInfo
    def get_dataResourceRef(self): return self.dataResourceRef
    def set_dataResourceRef(self, dataResourceRef): self.dataResourceRef = dataResourceRef
    def get_dataRef(self): return self.dataRef
    def set_dataRef(self, dataRef): self.dataRef = dataRef
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_acquisitionProtocol(self): return self.acquisitionProtocol
    def set_acquisitionProtocol(self, acquisitionProtocol): self.acquisitionProtocol = acquisitionProtocol
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='acquisition_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='acquisition_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='acquisition_t'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        super(acquisition_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='acquisition_t')
        if self.acquisitionProtocol is not None and 'acquisitionProtocol' not in already_processed:
            already_processed.append('acquisitionProtocol')
            outfile.write(' acquisitionProtocol=%s' % (self.gds_format_string(quote_attrib(self.acquisitionProtocol).encode(ExternalEncoding), input_name='acquisitionProtocol'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='acquisition_t', fromsubclass_=False):
        super(acquisition_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.acquisitionInfo is not None:
            self.acquisitionInfo.export(outfile, level, namespace_, name_='acquisitionInfo')
        if self.dataResourceRef is not None:
            self.dataResourceRef.export(outfile, level, namespace_, name_='dataResourceRef')
        if self.dataRef is not None:
            self.dataRef.export(outfile, level, namespace_, name_='dataRef')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.acquisitionInfo is not None or
            self.dataResourceRef is not None or
            self.dataRef is not None or
            self.anytypeobjs_ or
            super(acquisition_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='acquisition_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.acquisitionProtocol is not None and 'acquisitionProtocol' not in already_processed:
            already_processed.append('acquisitionProtocol')
            showIndent(outfile, level)
            outfile.write('acquisitionProtocol = "%s",\n' % (self.acquisitionProtocol,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
        super(acquisition_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(acquisition_t, self).exportLiteralChildren(outfile, level, name_)
        if self.acquisitionInfo is not None:
            showIndent(outfile, level)
            outfile.write('acquisitionInfo=model_.acquisitionInfo_t(\n')
            self.acquisitionInfo.exportLiteral(outfile, level, name_='acquisitionInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataResourceRef is not None:
            showIndent(outfile, level)
            outfile.write('dataResourceRef=model_.ref_t(\n')
            self.dataResourceRef.exportLiteral(outfile, level, name_='dataResourceRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataRef is not None:
            showIndent(outfile, level)
            outfile.write('dataRef=model_.ref_t(\n')
            self.dataRef.exportLiteral(outfile, level, name_='dataRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('acquisitionProtocol', node)
        if value is not None and 'acquisitionProtocol' not in already_processed:
            already_processed.append('acquisitionProtocol')
            self.acquisitionProtocol = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(acquisition_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'acquisitionInfo':
            obj_ = acquisitionInfo_t.factory()
            obj_.build(child_)
            self.set_acquisitionInfo(obj_)
        elif nodeName_ == 'dataResourceRef':
            obj_ = ref_t.factory()
            obj_.build(child_)
            self.set_dataResourceRef(obj_)
        elif nodeName_ == 'dataRef':
            obj_ = ref_t.factory()
            obj_.build(child_)
            self.set_dataRef(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'acquisition_t')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(acquisition_t, self).buildChildren(child_, node, nodeName_, True)
# end class acquisition_t


class episode_t(abstract_level_t):
    subclass = None
    superclass = abstract_level_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provActivityID=None, episodeInfo=None, anytypeobjs_=None):
        super(episode_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, provActivityID, )
        self.episodeInfo = episodeInfo
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if episode_t.subclass:
            return episode_t.subclass(*args_, **kwargs_)
        else:
            return episode_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_episodeInfo(self): return self.episodeInfo
    def set_episodeInfo(self, episodeInfo): self.episodeInfo = episodeInfo
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='episode_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='episode_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='episode_t'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        super(episode_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='episode_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='episode_t', fromsubclass_=False):
        super(episode_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.episodeInfo is not None:
            self.episodeInfo.export(outfile, level, namespace_, name_='episodeInfo')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.episodeInfo is not None or
            self.anytypeobjs_ or
            super(episode_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='episode_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
        super(episode_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(episode_t, self).exportLiteralChildren(outfile, level, name_)
        if self.episodeInfo is not None:
            showIndent(outfile, level)
            outfile.write('episodeInfo=model_.episodeInfo_t(\n')
            self.episodeInfo.exportLiteral(outfile, level, name_='episodeInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(episode_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'episodeInfo':
            obj_ = episodeInfo_t.factory()
            obj_.build(child_)
            self.set_episodeInfo(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'episode_t')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(episode_t, self).buildChildren(child_, node, nodeName_, True)
# end class episode_t


class study_t(abstract_level_t):
    subclass = None
    superclass = abstract_level_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provActivityID=None, studyInfo=None, anytypeobjs_=None):
        super(study_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, provActivityID, )
        self.studyInfo = studyInfo
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if study_t.subclass:
            return study_t.subclass(*args_, **kwargs_)
        else:
            return study_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_studyInfo(self): return self.studyInfo
    def set_studyInfo(self, studyInfo): self.studyInfo = studyInfo
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='study_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='study_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='study_t'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        super(study_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='study_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='study_t', fromsubclass_=False):
        super(study_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.studyInfo is not None:
            self.studyInfo.export(outfile, level, namespace_, name_='studyInfo')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.studyInfo is not None or
            self.anytypeobjs_ or
            super(study_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='study_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
        super(study_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(study_t, self).exportLiteralChildren(outfile, level, name_)
        if self.studyInfo is not None:
            showIndent(outfile, level)
            outfile.write('studyInfo=model_.studyInfo_t(\n')
            self.studyInfo.exportLiteral(outfile, level, name_='studyInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(study_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'studyInfo':
            obj_ = studyInfo_t.factory()
            obj_.build(child_)
            self.set_studyInfo(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'study_t')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(study_t, self).buildChildren(child_, node, nodeName_, True)
# end class study_t


class visit_t(abstract_level_t):
    subclass = None
    superclass = abstract_level_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provActivityID=None, subjectURI=None, projectID=None, subjectGroupID=None, projectURI=None, subjectID=None, visitInfo=None, anytypeobjs_=None):
        super(visit_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, provActivityID, )
        self.subjectURI = _cast(None, subjectURI)
        self.projectID = _cast(None, projectID)
        self.subjectGroupID = _cast(None, subjectGroupID)
        self.projectURI = _cast(None, projectURI)
        self.subjectID = _cast(None, subjectID)
        self.visitInfo = visitInfo
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if visit_t.subclass:
            return visit_t.subclass(*args_, **kwargs_)
        else:
            return visit_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_visitInfo(self): return self.visitInfo
    def set_visitInfo(self, visitInfo): self.visitInfo = visitInfo
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_subjectURI(self): return self.subjectURI
    def set_subjectURI(self, subjectURI): self.subjectURI = subjectURI
    def get_projectID(self): return self.projectID
    def set_projectID(self, projectID): self.projectID = projectID
    def get_subjectGroupID(self): return self.subjectGroupID
    def set_subjectGroupID(self, subjectGroupID): self.subjectGroupID = subjectGroupID
    def get_projectURI(self): return self.projectURI
    def set_projectURI(self, projectURI): self.projectURI = projectURI
    def get_subjectID(self): return self.subjectID
    def set_subjectID(self, subjectID): self.subjectID = subjectID
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def export(self, outfile, level, namespace_='xcede2:', name_='visit_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='visit_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='visit_t'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.append(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.append(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.append(name)
                        outfile.write(' %s=%s' % (name, quote_attrib(value), ))
        super(visit_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='visit_t')
        if self.subjectURI is not None and 'subjectURI' not in already_processed:
            already_processed.append('subjectURI')
            outfile.write(' subjectURI=%s' % (self.gds_format_string(quote_attrib(self.subjectURI).encode(ExternalEncoding), input_name='subjectURI'), ))
        if self.projectID is not None and 'projectID' not in already_processed:
            already_processed.append('projectID')
            outfile.write(' projectID=%s' % (self.gds_format_string(quote_attrib(self.projectID).encode(ExternalEncoding), input_name='projectID'), ))
        if self.subjectGroupID is not None and 'subjectGroupID' not in already_processed:
            already_processed.append('subjectGroupID')
            outfile.write(' subjectGroupID=%s' % (self.gds_format_string(quote_attrib(self.subjectGroupID).encode(ExternalEncoding), input_name='subjectGroupID'), ))
        if self.projectURI is not None and 'projectURI' not in already_processed:
            already_processed.append('projectURI')
            outfile.write(' projectURI=%s' % (self.gds_format_string(quote_attrib(self.projectURI).encode(ExternalEncoding), input_name='projectURI'), ))
        if self.subjectID is not None and 'subjectID' not in already_processed:
            already_processed.append('subjectID')
            outfile.write(' subjectID=%s' % (self.gds_format_string(quote_attrib(self.subjectID).encode(ExternalEncoding), input_name='subjectID'), ))
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='visit_t', fromsubclass_=False):
        super(visit_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.visitInfo is not None:
            self.visitInfo.export(outfile, level, namespace_, name_='visitInfo')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.visitInfo is not None or
            self.anytypeobjs_ or
            super(visit_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='visit_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.subjectURI is not None and 'subjectURI' not in already_processed:
            already_processed.append('subjectURI')
            showIndent(outfile, level)
            outfile.write('subjectURI = "%s",\n' % (self.subjectURI,))
        if self.projectID is not None and 'projectID' not in already_processed:
            already_processed.append('projectID')
            showIndent(outfile, level)
            outfile.write('projectID = "%s",\n' % (self.projectID,))
        if self.subjectGroupID is not None and 'subjectGroupID' not in already_processed:
            already_processed.append('subjectGroupID')
            showIndent(outfile, level)
            outfile.write('subjectGroupID = "%s",\n' % (self.subjectGroupID,))
        if self.projectURI is not None and 'projectURI' not in already_processed:
            already_processed.append('projectURI')
            showIndent(outfile, level)
            outfile.write('projectURI = "%s",\n' % (self.projectURI,))
        if self.subjectID is not None and 'subjectID' not in already_processed:
            already_processed.append('subjectID')
            showIndent(outfile, level)
            outfile.write('subjectID = "%s",\n' % (self.subjectID,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s = "%s",\n' % (name, value,))
        super(visit_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(visit_t, self).exportLiteralChildren(outfile, level, name_)
        if self.visitInfo is not None:
            showIndent(outfile, level)
            outfile.write('visitInfo=model_.visitInfo_t(\n')
            self.visitInfo.exportLiteral(outfile, level, name_='visitInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subjectURI', node)
        if value is not None and 'subjectURI' not in already_processed:
            already_processed.append('subjectURI')
            self.subjectURI = value
        value = find_attr_value_('projectID', node)
        if value is not None and 'projectID' not in already_processed:
            already_processed.append('projectID')
            self.projectID = value
        value = find_attr_value_('subjectGroupID', node)
        if value is not None and 'subjectGroupID' not in already_processed:
            already_processed.append('subjectGroupID')
            self.subjectGroupID = value
        value = find_attr_value_('projectURI', node)
        if value is not None and 'projectURI' not in already_processed:
            already_processed.append('projectURI')
            self.projectURI = value
        value = find_attr_value_('subjectID', node)
        if value is not None and 'subjectID' not in already_processed:
            already_processed.append('subjectID')
            self.subjectID = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(visit_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'visitInfo':
            obj_ = visitInfo_t.factory()
            obj_.build(child_)
            self.set_visitInfo(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'visit_t')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(visit_t, self).buildChildren(child_, node, nodeName_, True)
# end class visit_t


class project_t(abstract_level_t):
    subclass = None
    superclass = abstract_level_t
    def __init__(self, metaFields=None, termPath=None, rev=None, nomenclature=None, abbreviation=None, preferredLabel=None, termID=None, type_=None, ID=None, commentList=None, annotationList=None, resourceList=None, provActivityID=None, projectInfo=None, contributorList=None, anytypeobjs_=None):
        super(project_t, self).__init__(metaFields, termPath, rev, nomenclature, abbreviation, preferredLabel, termID, type_, ID, commentList, annotationList, resourceList, provActivityID, )
        self.projectInfo = projectInfo
        self.contributorList = contributorList
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if project_t.subclass:
            return project_t.subclass(*args_, **kwargs_)
        else:
            return project_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_projectInfo(self): return self.projectInfo
    def set_projectInfo(self, projectInfo): self.projectInfo = projectInfo
    def get_contributorList(self): return self.contributorList
    def set_contributorList(self, contributorList): self.contributorList = contributorList
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='project_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='project_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='project_t'):
        super(project_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='project_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='project_t', fromsubclass_=False):
        super(project_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.projectInfo is not None:
            self.projectInfo.export(outfile, level, namespace_, name_='projectInfo')
        if self.contributorList is not None:
            self.contributorList.export(outfile, level, namespace_, name_='contributorList')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.projectInfo is not None or
            self.contributorList is not None or
            self.anytypeobjs_ or
            super(project_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='project_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(project_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(project_t, self).exportLiteralChildren(outfile, level, name_)
        if self.projectInfo is not None:
            showIndent(outfile, level)
            outfile.write('projectInfo=model_.projectInfo_t(\n')
            self.projectInfo.exportLiteral(outfile, level, name_='projectInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.contributorList is not None:
            showIndent(outfile, level)
            outfile.write('contributorList=model_.contributorListType(\n')
            self.contributorList.exportLiteral(outfile, level, name_='contributorList')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(project_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'projectInfo':
            obj_ = projectInfo_t.factory()
            obj_.build(child_)
            self.set_projectInfo(obj_)
        elif nodeName_ == 'contributorList':
            obj_ = contributorListType.factory()
            obj_.build(child_)
            self.set_contributorList(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'project_t')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(project_t, self).buildChildren(child_, node, nodeName_, True)
# end class project_t


class binaryDataResource_t(dataResource_t):
    """The ancestor type (resource_t) can describe a stream of data. The
    extensions in this derived type (binaryDataResource_t) tell you
    that this data stream is composed of a (one-dimensional)
    sequence of data items of a given data type and byte order."""
    subclass = None
    superclass = dataResource_t
    def __init__(self, metaFields=None, dataID=None, description=None, format=None, dataURI=None, cachePath=None, level=None, content=None, provEntityID=None, analysisURI=None, analysisID=None, ID=None, name=None, uri=None, provenance=None, elementType=None, byteOrder=None, compression=None, extensiontype_=None):
        super(binaryDataResource_t, self).__init__(metaFields, dataID, description, format, dataURI, cachePath, level, content, provEntityID, analysisURI, analysisID, ID, name, uri, provenance, extensiontype_, )
        self.elementType = elementType
        self.byteOrder = byteOrder
        self.compression = compression
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if binaryDataResource_t.subclass:
            return binaryDataResource_t.subclass(*args_, **kwargs_)
        else:
            return binaryDataResource_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_elementType(self): return self.elementType
    def set_elementType(self, elementType): self.elementType = elementType
    def get_byteOrder(self): return self.byteOrder
    def set_byteOrder(self, byteOrder): self.byteOrder = byteOrder
    def get_compression(self): return self.compression
    def set_compression(self, compression): self.compression = compression
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xcede2:', name_='binaryDataResource_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='binaryDataResource_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='binaryDataResource_t'):
        super(binaryDataResource_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='binaryDataResource_t')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='binaryDataResource_t', fromsubclass_=False):
        super(binaryDataResource_t, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.elementType is not None:
            showIndent(outfile, level)
            outfile.write('<%selementType>%s</%selementType>\n' % (namespace_, self.gds_format_string(quote_xml(self.elementType).encode(ExternalEncoding), input_name='elementType'), namespace_))
        if self.byteOrder is not None:
            showIndent(outfile, level)
            outfile.write('<%sbyteOrder>%s</%sbyteOrder>\n' % (namespace_, self.gds_format_string(quote_xml(self.byteOrder).encode(ExternalEncoding), input_name='byteOrder'), namespace_))
        if self.compression is not None:
            showIndent(outfile, level)
            outfile.write('<%scompression>%s</%scompression>\n' % (namespace_, self.gds_format_string(quote_xml(self.compression).encode(ExternalEncoding), input_name='compression'), namespace_))
    def hasContent_(self):
        if (
            self.elementType is not None or
            self.byteOrder is not None or
            self.compression is not None or
            super(binaryDataResource_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='binaryDataResource_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(binaryDataResource_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(binaryDataResource_t, self).exportLiteralChildren(outfile, level, name_)
        if self.elementType is not None:
            showIndent(outfile, level)
            outfile.write('elementType=%s,\n' % quote_python(self.elementType).encode(ExternalEncoding))
        if self.byteOrder is not None:
            showIndent(outfile, level)
            outfile.write('byteOrder=%s,\n' % quote_python(self.byteOrder).encode(ExternalEncoding))
        if self.compression is not None:
            showIndent(outfile, level)
            outfile.write('compression=%s,\n' % quote_python(self.compression).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(binaryDataResource_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'elementType':
            elementType_ = child_.text
            elementType_ = self.gds_validate_string(elementType_, node, 'elementType')
            self.elementType = elementType_
        elif nodeName_ == 'byteOrder':
            byteOrder_ = child_.text
            byteOrder_ = self.gds_validate_string(byteOrder_, node, 'byteOrder')
            self.byteOrder = byteOrder_
        elif nodeName_ == 'compression':
            compression_ = child_.text
            compression_ = self.gds_validate_string(compression_, node, 'compression')
            self.compression = compression_
        super(binaryDataResource_t, self).buildChildren(child_, node, nodeName_, True)
# end class binaryDataResource_t


class dcResource_t(informationResource_t):
    subclass = None
    superclass = informationResource_t
    def __init__(self, metaFields=None, dataID=None, description=None, format=None, dataURI=None, cachePath=None, level=None, content=None, provEntityID=None, analysisURI=None, analysisID=None, ID=None, name=None, uri=None, title=None, creator=None, subject=None, publisher=None, contributor=None, date=None, type_=None, identifier=None, source=None, language=None, relation=None, coverage=None, rights=None):
        super(dcResource_t, self).__init__(metaFields, dataID, description, format, dataURI, cachePath, level, content, provEntityID, analysisURI, analysisID, ID, name, uri, )
        if title is None:
            self.title = []
        else:
            self.title = title
        if creator is None:
            self.creator = []
        else:
            self.creator = creator
        if subject is None:
            self.subject = []
        else:
            self.subject = subject
        if description is None:
            self.description = []
        else:
            self.description = description
        if publisher is None:
            self.publisher = []
        else:
            self.publisher = publisher
        if contributor is None:
            self.contributor = []
        else:
            self.contributor = contributor
        if date is None:
            self.date = []
        else:
            self.date = date
        if type_ is None:
            self.type_ = []
        else:
            self.type_ = type_
        if format is None:
            self.format = []
        else:
            self.format = format
        if identifier is None:
            self.identifier = []
        else:
            self.identifier = identifier
        if source is None:
            self.source = []
        else:
            self.source = source
        if language is None:
            self.language = []
        else:
            self.language = language
        if relation is None:
            self.relation = []
        else:
            self.relation = relation
        if coverage is None:
            self.coverage = []
        else:
            self.coverage = coverage
        if rights is None:
            self.rights = []
        else:
            self.rights = rights
    def factory(*args_, **kwargs_):
        if dcResource_t.subclass:
            return dcResource_t.subclass(*args_, **kwargs_)
        else:
            return dcResource_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def add_title(self, value): self.title.append(value)
    def insert_title(self, index, value): self.title[index] = value
    def get_creator(self): return self.creator
    def set_creator(self, creator): self.creator = creator
    def add_creator(self, value): self.creator.append(value)
    def insert_creator(self, index, value): self.creator[index] = value
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def add_subject(self, value): self.subject.append(value)
    def insert_subject(self, index, value): self.subject[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_publisher(self): return self.publisher
    def set_publisher(self, publisher): self.publisher = publisher
    def add_publisher(self, value): self.publisher.append(value)
    def insert_publisher(self, index, value): self.publisher[index] = value
    def get_contributor(self): return self.contributor
    def set_contributor(self, contributor): self.contributor = contributor
    def add_contributor(self, value): self.contributor.append(value)
    def insert_contributor(self, index, value): self.contributor[index] = value
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def add_date(self, value): self.date.append(value)
    def insert_date(self, index, value): self.date[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def add_type(self, value): self.type_.append(value)
    def insert_type(self, index, value): self.type_[index] = value
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def add_format(self, value): self.format.append(value)
    def insert_format(self, index, value): self.format[index] = value
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def add_identifier(self, value): self.identifier.append(value)
    def insert_identifier(self, index, value): self.identifier[index] = value
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def add_source(self, value): self.source.append(value)
    def insert_source(self, index, value): self.source[index] = value
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def add_language(self, value): self.language.append(value)
    def insert_language(self, index, value): self.language[index] = value
    def get_relation(self): return self.relation
    def set_relation(self, relation): self.relation = relation
    def add_relation(self, value): self.relation.append(value)
    def insert_relation(self, index, value): self.relation[index] = value
    def get_coverage(self): return self.coverage
    def set_coverage(self, coverage): self.coverage = coverage
    def add_coverage(self, value): self.coverage.append(value)
    def insert_coverage(self, index, value): self.coverage[index] = value
    def get_rights(self): return self.rights
    def set_rights(self, rights): self.rights = rights
    def add_rights(self, value): self.rights.append(value)
    def insert_rights(self, index, value): self.rights[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='dcResource_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dcResource_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='dcResource_t'):
        super(dcResource_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dcResource_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='dcResource_t', fromsubclass_=False):
        super(dcResource_t, self).exportChildren(outfile, level, namespace_, name_, True)
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('<%stitle>%s</%stitle>\n' % (namespace_, self.gds_format_string(quote_xml(title_).encode(ExternalEncoding), input_name='title'), namespace_))
        for creator_ in self.creator:
            showIndent(outfile, level)
            outfile.write('<%screator>%s</%screator>\n' % (namespace_, self.gds_format_string(quote_xml(creator_).encode(ExternalEncoding), input_name='creator'), namespace_))
        for subject_ in self.subject:
            showIndent(outfile, level)
            outfile.write('<%ssubject>%s</%ssubject>\n' % (namespace_, self.gds_format_string(quote_xml(subject_).encode(ExternalEncoding), input_name='subject'), namespace_))
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(description_).encode(ExternalEncoding), input_name='description'), namespace_))
        for publisher_ in self.publisher:
            showIndent(outfile, level)
            outfile.write('<%spublisher>%s</%spublisher>\n' % (namespace_, self.gds_format_string(quote_xml(publisher_).encode(ExternalEncoding), input_name='publisher'), namespace_))
        for contributor_ in self.contributor:
            contributor_.export(outfile, level, namespace_, name_='contributor')
        for date_ in self.date:
            showIndent(outfile, level)
            outfile.write('<%sdate>%s</%sdate>\n' % (namespace_, self.gds_format_string(quote_xml(date_).encode(ExternalEncoding), input_name='date'), namespace_))
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('<%stype>%s</%stype>\n' % (namespace_, self.gds_format_string(quote_xml(type_).encode(ExternalEncoding), input_name='type'), namespace_))
        for format_ in self.format:
            showIndent(outfile, level)
            outfile.write('<%sformat>%s</%sformat>\n' % (namespace_, self.gds_format_string(quote_xml(format_).encode(ExternalEncoding), input_name='format'), namespace_))
        for identifier_ in self.identifier:
            showIndent(outfile, level)
            outfile.write('<%sidentifier>%s</%sidentifier>\n' % (namespace_, self.gds_format_string(quote_xml(identifier_).encode(ExternalEncoding), input_name='identifier'), namespace_))
        for source_ in self.source:
            showIndent(outfile, level)
            outfile.write('<%ssource>%s</%ssource>\n' % (namespace_, self.gds_format_string(quote_xml(source_).encode(ExternalEncoding), input_name='source'), namespace_))
        for language_ in self.language:
            showIndent(outfile, level)
            outfile.write('<%slanguage>%s</%slanguage>\n' % (namespace_, self.gds_format_string(quote_xml(language_).encode(ExternalEncoding), input_name='language'), namespace_))
        for relation_ in self.relation:
            showIndent(outfile, level)
            outfile.write('<%srelation>%s</%srelation>\n' % (namespace_, self.gds_format_string(quote_xml(relation_).encode(ExternalEncoding), input_name='relation'), namespace_))
        for coverage_ in self.coverage:
            showIndent(outfile, level)
            outfile.write('<%scoverage>%s</%scoverage>\n' % (namespace_, self.gds_format_string(quote_xml(coverage_).encode(ExternalEncoding), input_name='coverage'), namespace_))
        for rights_ in self.rights:
            showIndent(outfile, level)
            outfile.write('<%srights>%s</%srights>\n' % (namespace_, self.gds_format_string(quote_xml(rights_).encode(ExternalEncoding), input_name='rights'), namespace_))
    def hasContent_(self):
        if (
            self.title or
            self.creator or
            self.subject or
            self.description or
            self.publisher or
            self.contributor or
            self.date or
            self.type_ or
            self.format or
            self.identifier or
            self.source or
            self.language or
            self.relation or
            self.coverage or
            self.rights or
            super(dcResource_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dcResource_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(dcResource_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(dcResource_t, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('title=[\n')
        level += 1
        for title_ in self.title:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(title_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('creator=[\n')
        level += 1
        for creator_ in self.creator:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(creator_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('subject=[\n')
        level += 1
        for subject_ in self.subject:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(subject_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(description_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('publisher=[\n')
        level += 1
        for publisher_ in self.publisher:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(publisher_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contributor=[\n')
        level += 1
        for contributor_ in self.contributor:
            showIndent(outfile, level)
            outfile.write('model_.orderedString_t(\n')
            contributor_.exportLiteral(outfile, level, name_='orderedString_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('date=[\n')
        level += 1
        for date_ in self.date:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(date_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('type_=[\n')
        level += 1
        for type_ in self.type_:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('format=[\n')
        level += 1
        for format_ in self.format:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(format_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('identifier=[\n')
        level += 1
        for identifier_ in self.identifier:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(identifier_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('source=[\n')
        level += 1
        for source_ in self.source:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(source_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('language=[\n')
        level += 1
        for language_ in self.language:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(language_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('relation=[\n')
        level += 1
        for relation_ in self.relation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(relation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('coverage=[\n')
        level += 1
        for coverage_ in self.coverage:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(coverage_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('rights=[\n')
        level += 1
        for rights_ in self.rights:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(rights_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(dcResource_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'title':
            title_ = child_.text
            title_ = self.gds_validate_string(title_, node, 'title')
            self.title.append(title_)
        elif nodeName_ == 'creator':
            creator_ = child_.text
            creator_ = self.gds_validate_string(creator_, node, 'creator')
            self.creator.append(creator_)
        elif nodeName_ == 'subject':
            subject_ = child_.text
            subject_ = self.gds_validate_string(subject_, node, 'subject')
            self.subject.append(subject_)
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description.append(description_)
        elif nodeName_ == 'publisher':
            publisher_ = child_.text
            publisher_ = self.gds_validate_string(publisher_, node, 'publisher')
            self.publisher.append(publisher_)
        elif nodeName_ == 'contributor':
            obj_ = orderedString_t.factory()
            obj_.build(child_)
            self.contributor.append(obj_)
        elif nodeName_ == 'date':
            date_ = child_.text
            date_ = self.gds_validate_string(date_, node, 'date')
            self.date.append(date_)
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_.append(type_)
        elif nodeName_ == 'format':
            format_ = child_.text
            format_ = self.gds_validate_string(format_, node, 'format')
            self.format.append(format_)
        elif nodeName_ == 'identifier':
            identifier_ = child_.text
            identifier_ = self.gds_validate_string(identifier_, node, 'identifier')
            self.identifier.append(identifier_)
        elif nodeName_ == 'source':
            source_ = child_.text
            source_ = self.gds_validate_string(source_, node, 'source')
            self.source.append(source_)
        elif nodeName_ == 'language':
            language_ = child_.text
            language_ = self.gds_validate_string(language_, node, 'language')
            self.language.append(language_)
        elif nodeName_ == 'relation':
            relation_ = child_.text
            relation_ = self.gds_validate_string(relation_, node, 'relation')
            self.relation.append(relation_)
        elif nodeName_ == 'coverage':
            coverage_ = child_.text
            coverage_ = self.gds_validate_string(coverage_, node, 'coverage')
            self.coverage.append(coverage_)
        elif nodeName_ == 'rights':
            rights_ = child_.text
            rights_ = self.gds_validate_string(rights_, node, 'rights')
            self.rights.append(rights_)
        super(dcResource_t, self).buildChildren(child_, node, nodeName_, True)
# end class dcResource_t


class mappedBinaryDataResource_t(binaryDataResource_t):
    """This type places the multi-dimensional data array (say a
    3-dimensional cube) into a coordinate space (say MR scanner
    coordinates)."""
    subclass = None
    superclass = binaryDataResource_t
    def __init__(self, metaFields=None, dataID=None, description=None, format=None, dataURI=None, cachePath=None, level=None, content=None, provEntityID=None, analysisURI=None, analysisID=None, ID=None, name=None, uri=None, provenance=None, elementType=None, byteOrder=None, compression=None, dimension=None, originCoords=None):
        super(mappedBinaryDataResource_t, self).__init__(metaFields, dataID, description, format, dataURI, cachePath, level, content, provEntityID, analysisURI, analysisID, ID, name, uri, provenance, elementType, byteOrder, compression, )
        if dimension is None:
            self.dimension = []
        else:
            self.dimension = dimension
        self.originCoords = originCoords
    def factory(*args_, **kwargs_):
        if mappedBinaryDataResource_t.subclass:
            return mappedBinaryDataResource_t.subclass(*args_, **kwargs_)
        else:
            return mappedBinaryDataResource_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dimension(self): return self.dimension
    def set_dimension(self, dimension): self.dimension = dimension
    def add_dimension(self, value): self.dimension.append(value)
    def insert_dimension(self, index, value): self.dimension[index] = value
    def get_originCoords(self): return self.originCoords
    def set_originCoords(self, originCoords): self.originCoords = originCoords
    def export(self, outfile, level, namespace_='xcede2:', name_='mappedBinaryDataResource_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mappedBinaryDataResource_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='mappedBinaryDataResource_t'):
        super(mappedBinaryDataResource_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='mappedBinaryDataResource_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='mappedBinaryDataResource_t', fromsubclass_=False):
        super(mappedBinaryDataResource_t, self).exportChildren(outfile, level, namespace_, name_, True)
        for dimension_ in self.dimension:
            dimension_.export(outfile, level, namespace_, name_='dimension')
        if self.originCoords is not None:
            showIndent(outfile, level)
            outfile.write('<%soriginCoords>%s</%soriginCoords>\n' % (namespace_, self.gds_format_string(quote_xml(self.originCoords).encode(ExternalEncoding), input_name='originCoords'), namespace_))
    def hasContent_(self):
        if (
            self.dimension or
            self.originCoords is not None or
            super(mappedBinaryDataResource_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='mappedBinaryDataResource_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(mappedBinaryDataResource_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(mappedBinaryDataResource_t, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('dimension=[\n')
        level += 1
        for dimension_ in self.dimension:
            showIndent(outfile, level)
            outfile.write('model_.mappedBinaryDataDimension_t(\n')
            dimension_.exportLiteral(outfile, level, name_='mappedBinaryDataDimension_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.originCoords is not None:
            showIndent(outfile, level)
            outfile.write('originCoords=%s,\n' % quote_python(self.originCoords).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(mappedBinaryDataResource_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dimension':
            obj_ = mappedBinaryDataDimension_t.factory()
            obj_.build(child_)
            self.dimension.append(obj_)
        elif nodeName_ == 'originCoords':
            originCoords_ = child_.text
            originCoords_ = self.gds_validate_string(originCoords_, node, 'originCoords')
            self.originCoords = originCoords_
        super(mappedBinaryDataResource_t, self).buildChildren(child_, node, nodeName_, True)
# end class mappedBinaryDataResource_t


class dimensionedBinaryDataResource_t(binaryDataResource_t):
    """This type adds multi-dimensionality to the (uni-dimensional) data
    stream represented by binaryDataResource_t."""
    subclass = None
    superclass = binaryDataResource_t
    def __init__(self, metaFields=None, dataID=None, description=None, format=None, dataURI=None, cachePath=None, level=None, content=None, provEntityID=None, analysisURI=None, analysisID=None, ID=None, name=None, uri=None, provenance=None, elementType=None, byteOrder=None, compression=None, dimension=None):
        super(dimensionedBinaryDataResource_t, self).__init__(metaFields, dataID, description, format, dataURI, cachePath, level, content, provEntityID, analysisURI, analysisID, ID, name, uri, provenance, elementType, byteOrder, compression, )
        if dimension is None:
            self.dimension = []
        else:
            self.dimension = dimension
    def factory(*args_, **kwargs_):
        if dimensionedBinaryDataResource_t.subclass:
            return dimensionedBinaryDataResource_t.subclass(*args_, **kwargs_)
        else:
            return dimensionedBinaryDataResource_t(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dimension(self): return self.dimension
    def set_dimension(self, dimension): self.dimension = dimension
    def add_dimension(self, value): self.dimension.append(value)
    def insert_dimension(self, index, value): self.dimension[index] = value
    def export(self, outfile, level, namespace_='xcede2:', name_='dimensionedBinaryDataResource_t', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dimensionedBinaryDataResource_t')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xcede2:', name_='dimensionedBinaryDataResource_t'):
        super(dimensionedBinaryDataResource_t, self).exportAttributes(outfile, level, already_processed, namespace_, name_='dimensionedBinaryDataResource_t')
    def exportChildren(self, outfile, level, namespace_='xcede2:', name_='dimensionedBinaryDataResource_t', fromsubclass_=False):
        super(dimensionedBinaryDataResource_t, self).exportChildren(outfile, level, namespace_, name_, True)
        for dimension_ in self.dimension:
            dimension_.export(outfile, level, namespace_, name_='dimension')
    def hasContent_(self):
        if (
            self.dimension or
            super(dimensionedBinaryDataResource_t, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dimensionedBinaryDataResource_t'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(dimensionedBinaryDataResource_t, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(dimensionedBinaryDataResource_t, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('dimension=[\n')
        level += 1
        for dimension_ in self.dimension:
            showIndent(outfile, level)
            outfile.write('model_.binaryDataDimension_t(\n')
            dimension_.exportLiteral(outfile, level, name_='binaryDataDimension_t')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(dimensionedBinaryDataResource_t, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dimension':
            class_obj_ = self.get_class_obj_(child_, binaryDataDimension_t)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.dimension.append(obj_)
        super(dimensionedBinaryDataResource_t, self).buildChildren(child_, node, nodeName_, True)
# end class dimensionedBinaryDataResource_t


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'XCEDE'
        rootClass = XCEDE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='xmlns:xcede2="http://www.xcede.org/xcede-2"')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'XCEDE'
        rootClass = XCEDE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="XCEDE",
        namespacedef_='xmlns:xcede2="http://www.xcede.org/xcede-2"')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'XCEDE'
        rootClass = XCEDE
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from xcede_bindings import *\n\n')
    sys.stdout.write('import xcede_bindings as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Account",
    "ActedOnBehalfOf",
    "Activity",
    "ActivityRef",
    "Agent",
    "AgentRef",
    "AlternateOf",
    "Container",
    "Dependencies",
    "DependencyRef",
    "Entity",
    "EntityRef",
    "HadOriginalSource",
    "HasAnnotation",
    "Note",
    "NoteRef",
    "Records",
    "SpecializationOf",
    "TracedTo",
    "Used",
    "WasAssociatedWith",
    "WasAttributedTo",
    "WasDerivedFrom",
    "WasEndedBy",
    "WasGeneratedBy",
    "WasInformedBy",
    "WasQuotedFrom",
    "WasRevisionOf",
    "WasStartedBy",
    "WasStartedByActivity",
    "XCEDE",
    "abstract_annotation_t",
    "abstract_container_t",
    "abstract_data_t",
    "abstract_entity_t",
    "abstract_geometry_t",
    "abstract_info_t",
    "abstract_level_t",
    "abstract_process_t",
    "abstract_protocol_t",
    "abstract_tagged_entity_t",
    "acquisitionInfo_t",
    "acquisition_t",
    "analysis_t",
    "anatomicalEntity_t",
    "annotationListType",
    "annotationListType1",
    "argumentsType_t",
    "assessmentDescItem_t",
    "assessmentInfo_t",
    "assessmentItem_t",
    "assessment_t",
    "atlasEntity_t",
    "authoredText_t",
    "binaryDataDimension_t",
    "binaryDataResource_t",
    "byteOrder",
    "catalogListType",
    "catalogRefType",
    "catalog_t",
    "commentListType",
    "contributorListType",
    "dataInstanceType",
    "dataResource_t",
    "datapointsType",
    "dcResource_t",
    "dimensionedBinaryDataResource_t",
    "documentationListType",
    "elementType",
    "entryListType",
    "episodeInfo_t",
    "episode_t",
    "eventParams_t",
    "eventValue_t",
    "event_t",
    "events_t",
    "exptDesign",
    "exptDesignListType",
    "extensionListType",
    "format_t",
    "frag_uri_t",
    "generator_t",
    "informationResource_t",
    "itemChoiceType",
    "itemTextType",
    "itemsType",
    "levelDataRefs_t",
    "mappedBinaryDataDimension_t",
    "mappedBinaryDataResource_t",
    "measurementFrameType",
    "measurementGroup_t",
    "metaFieldType",
    "metaFieldsType",
    "metadataList_t",
    "nameValue_t",
    "namedParameterList_t",
    "namedParameter_t",
    "nomenclature_t",
    "nsOntologyAnnotation_t",
    "nsTermAnnotation_t",
    "observation_t",
    "orderedString_t",
    "person_t",
    "processStep_t",
    "projectInfo_t",
    "project_t",
    "protocolItemChoice_t",
    "protocolItemRange_t",
    "protocolItem_t",
    "protocolOffset_t",
    "protocol_t",
    "provenance_t",
    "ref_t",
    "resourceListType",
    "resource_t",
    "revisionListType",
    "revision_t",
    "stepsType",
    "studyInfo_t",
    "study_t",
    "subjectGroupListType",
    "subjectGroup_t",
    "subjectID",
    "subjectInfo_t",
    "subject_t",
    "terminologyString_t",
    "textAnnotation_t",
    "textLabelType",
    "unitString_t",
    "value_t",
    "versionedEntity_t",
    "versionedProgramEntity_t",
    "visitInfo_t",
    "visit_t"
    ]
